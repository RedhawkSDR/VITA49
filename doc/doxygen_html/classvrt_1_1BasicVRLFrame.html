<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VRT: vrt::BasicVRLFrame Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>vrt</b>::<a class="el" href="classvrt_1_1BasicVRLFrame.html">BasicVRLFrame</a>
  </div>
</div>
<div class="contents">
<h1>vrt::BasicVRLFrame Class Reference</h1><!-- doxytag: class="vrt::BasicVRLFrame" --><!-- doxytag: inherits="vrt::VRTObject" -->
<p>Defines a VITA 49.1 VRL frame type.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BasicVRLFrame_8h_source.html">BasicVRLFrame.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vrt::BasicVRLFrame:</div>
<div class="dynsection">
 <div class="center">
  <img src="classvrt_1_1BasicVRLFrame.gif" usemap="#vrt::BasicVRLFrame_map" alt=""/>
  <map id="vrt::BasicVRLFrame_map" name="vrt::BasicVRLFrame_map">
<area href="classvrt_1_1VRTObject.html" alt="vrt::VRTObject" shape="rect" coords="0,0,124,24"/>
</map>
 </div>
</div>

<p><a href="classvrt_1_1BasicVRLFrame-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a53b891fef5f5568769487057683b697c">BasicVRLFrame</a> (const void *ptr, size_t size, bool readOnly=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new instance.  <a href="#a53b891fef5f5568769487057683b697c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a7368c21598bd668a048ff44413258a43">BasicVRLFrame</a> (const vector&lt; char &gt; &amp;buf, size_t size, bool readOnly=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new instance.  <a href="#a7368c21598bd668a048ff44413258a43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a63fbc2da5b33bf1221a0f0132c9562de">BasicVRLFrame</a> (vector&lt; char &gt; *buf, bool readOnly=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new instance.  <a href="#a63fbc2da5b33bf1221a0f0132c9562de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a46e9cb5fa5ad94dfd23836f6c5a4ae94">BasicVRLFrame</a> (const vector&lt; char &gt; &amp;buf, bool readOnly=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new instance.  <a href="#a46e9cb5fa5ad94dfd23836f6c5a4ae94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#ada7edf99e496867173334dbcaeb84beb">BasicVRLFrame</a> (const <a class="el" href="classvrt_1_1BasicVRLFrame.html">BasicVRLFrame</a> &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic copy constructor for the class.  <a href="#ada7edf99e496867173334dbcaeb84beb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a669ae02517212d1bb783e192f8f471d8">BasicVRLFrame</a> (int32_t bufsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new instance with a default anticipated length that can be written to.  <a href="#a669ae02517212d1bb783e192f8f471d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a374125f881e663aeebc57ff53f099856">BasicVRLFrame</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new instance with no packets in the frame.  <a href="#a374125f881e663aeebc57ff53f099856"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a16c20faa1c397479e483878f827f12bd">~BasicVRLFrame</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic destructor for the class.  <a href="#a16c20faa1c397479e483878f827f12bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrt_1_1BasicVRLFrame.html">BasicVRLFrame</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a5756cebbf5f9b2753808515cfe6fdfef">copy</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a copy of this frame that is independent of the original.  <a href="#a5756cebbf5f9b2753808515cfe6fdfef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#aa2c195196f6e08221c459bdd6fa89c72">equals</a> (const <a class="el" href="classvrt_1_1VRTObject.html">VRTObject</a> &amp;o) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for equality with an unknown object.  <a href="#aa2c195196f6e08221c459bdd6fa89c72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a623fd476baacfb2712e772471e0633b5">equals</a> (const <a class="el" href="classvrt_1_1BasicVRLFrame.html">BasicVRLFrame</a> &amp;o) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for equality with an unknown object.  <a href="#a623fd476baacfb2712e772471e0633b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a96cd57e76b850307a0bfd33dfc48020a">getFrameCount</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value of the 12-bit frame counter.  <a href="#a96cd57e76b850307a0bfd33dfc48020a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a488f7da9d6603bc79acbf5f18849ed30">getFrameLength</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the total length of the frame in octets including the header and trailer.  <a href="#a488f7da9d6603bc79acbf5f18849ed30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#aa451c8f66b1b05e70439b4e39548a066">getFramePointer</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a pointer to the frame's buffer.  <a href="#aa451c8f66b1b05e70439b4e39548a066"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a13df3d602d6e91d3e9728d20a1ccd261">getFrameValid</a> (bool strict, int32_t length) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks to see if the frame is valid.  <a href="#a13df3d602d6e91d3e9728d20a1ccd261"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a1ebea70c84cb056233466dd2db163e94">getFrameValid</a> (bool strict) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks to see if the frame is valid.  <a href="#a1ebea70c84cb056233466dd2db163e94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a4b3d1f5cf44a5abb942351018bc519e1">getPacketCount</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of packets contained in this frame.  <a href="#a4b3d1f5cf44a5abb942351018bc519e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a39a94f3cb5c1d0450328b0eba8bfbb11">getVRTPackets</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets all of the VRT packets contained in the VRL frame.  <a href="#a39a94f3cb5c1d0450328b0eba8bfbb11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; void * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a7aff369f3d081cebfb641639879a30b8">getVRTPacketsRW</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Gets pointers to the start of all of the VRT packets contained in the VRL frame.  <a href="#a7aff369f3d081cebfb641639879a30b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a92b84899fa8e8d40623fb3af50c77241">hashCode</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the hash code for a VRL frame.  <a href="#a92b84899fa8e8d40623fb3af50c77241"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a4bf1d10f064684609c6907ba3ce12a46">isCRCValid</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks to see if the CRC for the frame is valid.  <a href="#a4bf1d10f064684609c6907ba3ce12a46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#affd27163e28ad37b798af6f3855a0bcb">isFrameValid</a> (int32_t length) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks to see if the frame is valid.  <a href="#affd27163e28ad37b798af6f3855a0bcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a83b3a30637407ba9438691e15cda2739">isFrameValid</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks to see if the frame is valid.  <a href="#a83b3a30637407ba9438691e15cda2739"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#ac01d0380e486a4d372277be29dce908d">setFrameCount</a> (int32_t count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets the value of the 12-bit frame counter.  <a href="#ac01d0380e486a4d372277be29dce908d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a7429d4a028423b869c173efacc39d1aa">setFrameLength</a> (int32_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets the total length of the frame in octets including the header and trailer.  <a href="#a7429d4a028423b869c173efacc39d1aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a1b7b47d1452286fac5de03faa6f1f71c">setVRTPackets</a> (int32_t maxFrameLength, const vector&lt; <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> * &gt; &amp;packets)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets all of the VRT packets contained in the VRL frame.  <a href="#a1b7b47d1452286fac5de03faa6f1f71c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a92fa269d2799462acbd7bdc95e4d7b56">setVRTPackets</a> (int32_t maxFrameLength, const vector&lt; <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &gt; &amp;packets)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets all of the VRT packets contained in the VRL frame.  <a href="#a92fa269d2799462acbd7bdc95e4d7b56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#ae87a374b98e3c198393b2547f2feb76d">setVRTPackets</a> (const vector&lt; <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> * &gt; &amp;packets)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets all of the VRT packets contained in the VRL frame.  <a href="#ae87a374b98e3c198393b2547f2feb76d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a8459555aaf6234e2f1b3ee5153d9a2e5">setVRTPackets</a> (const vector&lt; <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &gt; &amp;packets)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets all of the VRT packets contained in the VRL frame.  <a href="#a8459555aaf6234e2f1b3ee5153d9a2e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#aff07dcbd0aca7170057873fce92d12e5">setVRTPackets</a> (int32_t maxFrameLength, const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> *packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets all of the VRT packets contained in the VRL frame.  <a href="#aff07dcbd0aca7170057873fce92d12e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a50f7b5f33571e78d49d98fbf6b223b5c">setVRTPackets</a> (int32_t maxFrameLength, const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets all of the VRT packets contained in the VRL frame.  <a href="#a50f7b5f33571e78d49d98fbf6b223b5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#ad0bbbb0d50a2596da7acb0ac6bad09f5">setVRTPackets</a> (const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> *packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets all of the VRT packets contained in the VRL frame.  <a href="#ad0bbbb0d50a2596da7acb0ac6bad09f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#ac21b7c8bdba4bd190247fed3b07a21c5">setVRTPackets</a> (const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets all of the VRT packets contained in the VRL frame.  <a href="#ac21b7c8bdba4bd190247fed3b07a21c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a54c557c8fbb31eca704379882f3d9853">swap</a> (vector&lt; char &gt; *buffer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Does a buffer swap.  <a href="#a54c557c8fbb31eca704379882f3d9853"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a40d1dca344f27e95fd2e7e056eddc237">toString</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a free-form description of the frame.  <a href="#a40d1dca344f27e95fd2e7e056eddc237"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#af75f534bcc125bf11679a275c335b6c9">updateCRC</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This will compute the CRC value for the frame and set it in the CRC field.  <a href="#af75f534bcc125bf11679a275c335b6c9"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a11a83d025ee398ef64d248050e8c5b8f">getFrameLength</a> (const void *ptr, int32_t off)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Get VRL frame length using a buffer input.  <a href="#a11a83d025ee398ef64d248050e8c5b8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a7a89e558b5cc1b9ed1b4b7b630b6cfa3">getFrameLength</a> (const vector&lt; char &gt; &amp;buf, int32_t off)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Get VRL frame length using a buffer input.  <a href="#a7a89e558b5cc1b9ed1b4b7b630b6cfa3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static vector&lt; vector&lt; char &gt; * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a5d2dbbaeaeda39d2ecb751038c7921fc">getVRTPackets</a> (const vector&lt; char &gt; &amp;buffer, int32_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Gets all of the VRT packets contained in the VRL frame.  <a href="#a5d2dbbaeaeda39d2ecb751038c7921fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#ac2f7ba9d4cd72e63274b72efac597c53">isVRL</a> (const void *ptr, int32_t off)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Does the given buffer contain a VRL frame?  <a href="#ac2f7ba9d4cd72e63274b72efac597c53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a15e0e67d74a33a457ea5fd3d4230f2b9">isVRL</a> (const vector&lt; char &gt; &amp;buf, int32_t off)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Does the given buffer contain a VRL frame?  <a href="#a15e0e67d74a33a457ea5fd3d4230f2b9"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b68146567b98ad2816e0e7aece15c11"></a><!-- doxytag: member="vrt::BasicVRLFrame::bbuf" ref="a6b68146567b98ad2816e0e7aece15c11" args="" -->
vector&lt; char &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>bbuf</b></td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a6add1783362e99b36a0e62b009dbff54">HEADER_LENGTH</a> = 8</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The length of the header in octets.  <a href="#a6add1783362e99b36a0e62b009dbff54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#af8d8814f57ece97ba8ffadb34a1021dd">MAX_FRAME_LENGTH</a> = 0x000FFFFF*4</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum length of the frame in octets (header + payload + trailer).  <a href="#af8d8814f57ece97ba8ffadb34a1021dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a6becbd1792ac4c8fd992034df213edc0">MAX_PAYLOAD_LENGTH</a> = <a class="el" href="classvrt_1_1BasicVRLFrame.html#af8d8814f57ece97ba8ffadb34a1021dd">MAX_FRAME_LENGTH</a> - <a class="el" href="classvrt_1_1BasicVRLFrame.html#a6add1783362e99b36a0e62b009dbff54">HEADER_LENGTH</a> - <a class="el" href="classvrt_1_1BasicVRLFrame.html#ac5ff60567f3a51615fff929895363f76">TRAILER_LENGTH</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum length of the payload in octets.  <a href="#a6becbd1792ac4c8fd992034df213edc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#aa45b2161a0b5ee723ed26b2ec0049e65">MIN_FRAME_LENGTH</a> = <a class="el" href="classvrt_1_1BasicVRLFrame.html#a6add1783362e99b36a0e62b009dbff54">HEADER_LENGTH</a> + <a class="el" href="classvrt_1_1BasicVRLFrame.html#ac5ff60567f3a51615fff929895363f76">TRAILER_LENGTH</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The minimum length of the frame in octets (header + no payload + trailer).  <a href="#aa45b2161a0b5ee723ed26b2ec0049e65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#afcb1723c47875d18f590908170f1eb6d">NO_CRC</a> = 0x56454E44</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the special code that can be used in place of the CRC32 in cases where a CRC is not considered unnecessary, and not included.  <a href="#afcb1723c47875d18f590908170f1eb6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#aa099395e26f78c48e915c7079afa86aa">NO_CRC_0</a> = 0x56</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the 1st transmitted int8_t of the 32-bit <a class="el" href="classvrt_1_1BasicVRLFrame.html#afcb1723c47875d18f590908170f1eb6d">NO_CRC</a> code.  <a href="#aa099395e26f78c48e915c7079afa86aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#ab08f1374b479c0bbd61ac14d7b843566">NO_CRC_1</a> = 0x45</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the 2nd transmitted int8_t of the 32-bit <a class="el" href="classvrt_1_1BasicVRLFrame.html#afcb1723c47875d18f590908170f1eb6d">NO_CRC</a> code.  <a href="#ab08f1374b479c0bbd61ac14d7b843566"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#aba106d0fcfc0431f104baaa276f597f8">NO_CRC_2</a> = 0x4E</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the 3rd transmitted int8_t of the 32-bit <a class="el" href="classvrt_1_1BasicVRLFrame.html#afcb1723c47875d18f590908170f1eb6d">NO_CRC</a> code.  <a href="#aba106d0fcfc0431f104baaa276f597f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#aba86f4a59ea8d6d53adc7974e7508fa6">NO_CRC_3</a> = 0x44</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the 4th transmitted int8_t of the 32-bit <a class="el" href="classvrt_1_1BasicVRLFrame.html#afcb1723c47875d18f590908170f1eb6d">NO_CRC</a> code.  <a href="#aba86f4a59ea8d6d53adc7974e7508fa6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#ac5ff60567f3a51615fff929895363f76">TRAILER_LENGTH</a> = 4</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The length of the trailer in octets.  <a href="#ac5ff60567f3a51615fff929895363f76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a2f82c7c9cb96dd6e78359461be9c8f72">VRL_FAW</a> = 0x56524C50</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the 32-bit FWA (frame alignment word) marking the start of the frame.  <a href="#a2f82c7c9cb96dd6e78359461be9c8f72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a7a5af0cd5a4607c7803b4cd5378aea21">VRL_FAW_0</a> = 0x56</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the 1st transmitted int8_t of the 32-bit FWA (<a class="el" href="classvrt_1_1BasicVRLFrame.html#a2f82c7c9cb96dd6e78359461be9c8f72">VRL_FAW</a>).  <a href="#a7a5af0cd5a4607c7803b4cd5378aea21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a105fb25594da02a6cd3ae72b7729f7a8">VRL_FAW_1</a> = 0x52</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the 2nd transmitted int8_t of the 32-bit FWA (<a class="el" href="classvrt_1_1BasicVRLFrame.html#a2f82c7c9cb96dd6e78359461be9c8f72">VRL_FAW</a>).  <a href="#a105fb25594da02a6cd3ae72b7729f7a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#a13ed766a1fafb47a5e27d9f213b1e482">VRL_FAW_2</a> = 0x4C</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the 3rd transmitted int8_t of the 32-bit FWA (<a class="el" href="classvrt_1_1BasicVRLFrame.html#a2f82c7c9cb96dd6e78359461be9c8f72">VRL_FAW</a>).  <a href="#a13ed766a1fafb47a5e27d9f213b1e482"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRLFrame.html#aba85f2b68615e4edf3653abb70535199">VRL_FAW_3</a> = 0x50</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the 4th transmitted int8_t of the 32-bit FWA (<a class="el" href="classvrt_1_1BasicVRLFrame.html#a2f82c7c9cb96dd6e78359461be9c8f72">VRL_FAW</a>).  <a href="#aba85f2b68615e4edf3653abb70535199"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Defines a VITA 49.1 VRL frame type. </p>
<p><br/>
 <br/>
 Note that the numeric representation (byte order) used by all VRL frames is <code>BIG_ENDIAN</code>. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a16c20faa1c397479e483878f827f12bd"></a><!-- doxytag: member="vrt::BasicVRLFrame::~BasicVRLFrame" ref="a16c20faa1c397479e483878f827f12bd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicVRLFrame::~BasicVRLFrame </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Basic destructor for the class. </p>

</div>
</div>
<a class="anchor" id="a374125f881e663aeebc57ff53f099856"></a><!-- doxytag: member="vrt::BasicVRLFrame::BasicVRLFrame" ref="a374125f881e663aeebc57ff53f099856" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicVRLFrame::BasicVRLFrame </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new instance with no packets in the frame. </p>

</div>
</div>
<a class="anchor" id="a669ae02517212d1bb783e192f8f471d8"></a><!-- doxytag: member="vrt::BasicVRLFrame::BasicVRLFrame" ref="a669ae02517212d1bb783e192f8f471d8" args="(int32_t bufsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicVRLFrame::BasicVRLFrame </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bufsize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new instance with a default anticipated length that can be written to. </p>
<p>Initially this will have no packets in the frame, but will have the underlying buffers pre-allocated as required. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufsize</em>&nbsp;</td><td>The anticipated buffer size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada7edf99e496867173334dbcaeb84beb"></a><!-- doxytag: member="vrt::BasicVRLFrame::BasicVRLFrame" ref="ada7edf99e496867173334dbcaeb84beb" args="(const BasicVRLFrame &amp;f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicVRLFrame::BasicVRLFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1BasicVRLFrame.html">BasicVRLFrame</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Basic copy constructor for the class. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>The frame to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46e9cb5fa5ad94dfd23836f6c5a4ae94"></a><!-- doxytag: member="vrt::BasicVRLFrame::BasicVRLFrame" ref="a46e9cb5fa5ad94dfd23836f6c5a4ae94" args="(const vector&lt; char &gt; &amp;buf, bool readOnly=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicVRLFrame::BasicVRLFrame </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>readOnly</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The data to initialize the frame with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>readOnly</em>&nbsp;</td><td>Should the frame be treated as read-only? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63fbc2da5b33bf1221a0f0132c9562de"></a><!-- doxytag: member="vrt::BasicVRLFrame::BasicVRLFrame" ref="a63fbc2da5b33bf1221a0f0132c9562de" args="(vector&lt; char &gt; *buf, bool readOnly=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicVRLFrame::BasicVRLFrame </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>readOnly</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The data to initialize the frame with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>readOnly</em>&nbsp;</td><td>Should the frame be treated as read-only? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7368c21598bd668a048ff44413258a43"></a><!-- doxytag: member="vrt::BasicVRLFrame::BasicVRLFrame" ref="a7368c21598bd668a048ff44413258a43" args="(const vector&lt; char &gt; &amp;buf, size_t size, bool readOnly=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicVRLFrame::BasicVRLFrame </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>readOnly</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The data to initialize the frame with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size of buffer to read in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>readOnly</em>&nbsp;</td><td>Should the frame be treated as read-only? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53b891fef5f5568769487057683b697c"></a><!-- doxytag: member="vrt::BasicVRLFrame::BasicVRLFrame" ref="a53b891fef5f5568769487057683b697c" args="(const void *ptr, size_t size, bool readOnly=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicVRLFrame::BasicVRLFrame </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>readOnly</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>The pointer to the data to initialize the frame with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size of buffer to read in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>readOnly</em>&nbsp;</td><td>Should the frame be treated as read-only? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5756cebbf5f9b2753808515cfe6fdfef"></a><!-- doxytag: member="vrt::BasicVRLFrame::copy" ref="a5756cebbf5f9b2753808515cfe6fdfef" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrt_1_1BasicVRLFrame.html">BasicVRLFrame</a> vrt::BasicVRLFrame::copy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a copy of this frame that is independent of the original. </p>
<p>The copy will not be read only and will not be "direct" (i.e. will not share data with the original). This method's behavior is undefined if the frame is invalid and may throw an exception in that event. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A copy of this frame. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2c195196f6e08221c459bdd6fa89c72"></a><!-- doxytag: member="vrt::BasicVRLFrame::equals" ref="aa2c195196f6e08221c459bdd6fa89c72" args="(const VRTObject &amp;o) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool vrt::BasicVRLFrame::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1VRTObject.html">VRTObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>o</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for equality with an unknown object. </p>
<p>Two VRL frames are considered equal if the content of the frames is bit-for-bit identical. The actual implementation classes are not considered relevant for checking equality. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>The unknown object (can be null). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if they are identical, false otherwise. (This will always returns false if the object is null.) </dd></dl>

</div>
</div>
<a class="anchor" id="a623fd476baacfb2712e772471e0633b5"></a><!-- doxytag: member="vrt::BasicVRLFrame::equals" ref="a623fd476baacfb2712e772471e0633b5" args="(const BasicVRLFrame &amp;o) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::BasicVRLFrame::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1BasicVRLFrame.html">BasicVRLFrame</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>o</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for equality with an unknown object. </p>
<p>Two VRL frames are considered equal if the content of the frames is bit-for-bit identical. The actual implementation classes are not considered relevant for checking equality. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>The unknown object (can be null). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if they are identical, false otherwise. (This will always returns false if the object is null.) </dd></dl>

<p>Reimplemented from <a class="el" href="classvrt_1_1VRTObject.html#a2f18f4efc73c423629510033039536fc">vrt::VRTObject</a>.</p>

</div>
</div>
<a class="anchor" id="a96cd57e76b850307a0bfd33dfc48020a"></a><!-- doxytag: member="vrt::BasicVRLFrame::getFrameCount" ref="a96cd57e76b850307a0bfd33dfc48020a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicVRLFrame::getFrameCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the value of the 12-bit frame counter. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of the frame counter. </dd></dl>

</div>
</div>
<a class="anchor" id="a11a83d025ee398ef64d248050e8c5b8f"></a><!-- doxytag: member="vrt::BasicVRLFrame::getFrameLength" ref="a11a83d025ee398ef64d248050e8c5b8f" args="(const void *ptr, int32_t off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t vrt::BasicVRLFrame::getFrameLength </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Get VRL frame length using a buffer input. </p>

<p>References <a class="el" href="VRTMath_8h_source.html#l00813">vrt::VRTMath::unpackInt()</a>.</p>

</div>
</div>
<a class="anchor" id="a7a89e558b5cc1b9ed1b4b7b630b6cfa3"></a><!-- doxytag: member="vrt::BasicVRLFrame::getFrameLength" ref="a7a89e558b5cc1b9ed1b4b7b630b6cfa3" args="(const vector&lt; char &gt; &amp;buf, int32_t off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t vrt::BasicVRLFrame::getFrameLength </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Get VRL frame length using a buffer input. </p>

<p>References <a class="el" href="BasicVRLFrame_8h_source.html#l00482">getFrameLength()</a>.</p>

</div>
</div>
<a class="anchor" id="a488f7da9d6603bc79acbf5f18849ed30"></a><!-- doxytag: member="vrt::BasicVRLFrame::getFrameLength" ref="a488f7da9d6603bc79acbf5f18849ed30" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicVRLFrame::getFrameLength </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the total length of the frame in octets including the header and trailer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The total length of the frame in octets. </dd></dl>

<p>Referenced by <a class="el" href="BasicVRLFrame_8h_source.html#l00487">getFrameLength()</a>.</p>

</div>
</div>
<a class="anchor" id="aa451c8f66b1b05e70439b4e39548a066"></a><!-- doxytag: member="vrt::BasicVRLFrame::getFramePointer" ref="aa451c8f66b1b05e70439b4e39548a066" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* vrt::BasicVRLFrame::getFramePointer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a pointer to the frame's buffer. </p>

</div>
</div>
<a class="anchor" id="a13df3d602d6e91d3e9728d20a1ccd261"></a><!-- doxytag: member="vrt::BasicVRLFrame::getFrameValid" ref="a13df3d602d6e91d3e9728d20a1ccd261" args="(bool strict, int32_t length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vrt::BasicVRLFrame::getFrameValid </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>strict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks to see if the frame is valid. </p>
<p>This is identical to <code>isFrameValid(..)</code> except that a description of the error is returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strict</em>&nbsp;</td><td>Should strict checking be done, or just enough to verify that things are OK for reading. No frame failing strict checking should ever be sent out, but it may be useful to disable strict checking when reading in a frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Verifies that the length of the frame matches this value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty string if it is valid, a description of the error otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ebea70c84cb056233466dd2db163e94"></a><!-- doxytag: member="vrt::BasicVRLFrame::getFrameValid" ref="a1ebea70c84cb056233466dd2db163e94" args="(bool strict) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vrt::BasicVRLFrame::getFrameValid </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>strict</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks to see if the frame is valid. </p>
<p>This is identical to <code><a class="el" href="classvrt_1_1BasicVRLFrame.html#a83b3a30637407ba9438691e15cda2739" title="Checks to see if the frame is valid.">isFrameValid()</a></code> except that a description of the error is returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strict</em>&nbsp;</td><td>Should strict checking be done, or just enough to verify that things are OK for reading. No frame failing strict checking should ever be sent out, but it may be useful to disable strict checking when reading in a frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty string if it is valid, a description of the error otherwise. </dd></dl>

<p>Referenced by <a class="el" href="BasicVRLFrame_8h_source.html#l00214">isFrameValid()</a>.</p>

</div>
</div>
<a class="anchor" id="a4b3d1f5cf44a5abb942351018bc519e1"></a><!-- doxytag: member="vrt::BasicVRLFrame::getPacketCount" ref="a4b3d1f5cf44a5abb942351018bc519e1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicVRLFrame::getPacketCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the number of packets contained in this frame. </p>
<p>This will be equal to <code><a class="el" href="classvrt_1_1BasicVRLFrame.html#a5d2dbbaeaeda39d2ecb751038c7921fc" title="Internal Use Only: Gets all of the VRT packets contained in the VRL frame.">getVRTPackets()</a>.size()</code> though will typically be implemented in a more efficient manner. </p>

</div>
</div>
<a class="anchor" id="a39a94f3cb5c1d0450328b0eba8bfbb11"></a><!-- doxytag: member="vrt::BasicVRLFrame::getVRTPackets" ref="a39a94f3cb5c1d0450328b0eba8bfbb11" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a>*&gt; vrt::BasicVRLFrame::getVRTPackets </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets all of the VRT packets contained in the VRL frame. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The packets. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d2dbbaeaeda39d2ecb751038c7921fc"></a><!-- doxytag: member="vrt::BasicVRLFrame::getVRTPackets" ref="a5d2dbbaeaeda39d2ecb751038c7921fc" args="(const vector&lt; char &gt; &amp;buffer, int32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;vector&lt;char&gt;*&gt;* vrt::BasicVRLFrame::getVRTPackets </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Gets all of the VRT packets contained in the VRL frame. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>The frame buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The number of valid octets in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The packets (which will be writable copies of what is in the frame) or NULL on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a7aff369f3d081cebfb641639879a30b8"></a><!-- doxytag: member="vrt::BasicVRLFrame::getVRTPacketsRW" ref="a7aff369f3d081cebfb641639879a30b8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;void*&gt; vrt::BasicVRLFrame::getVRTPacketsRW </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Gets pointers to the start of all of the VRT packets contained in the VRL frame. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The pointers. </dd></dl>

</div>
</div>
<a class="anchor" id="a92b84899fa8e8d40623fb3af50c77241"></a><!-- doxytag: member="vrt::BasicVRLFrame::hashCode" ref="a92b84899fa8e8d40623fb3af50c77241" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicVRLFrame::hashCode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the hash code for a VRL frame. </p>
<p>For performance reasons, the hash code is based on up to 32 octets at the start of the frame. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The hash code for the object. </dd></dl>

</div>
</div>
<a class="anchor" id="a4bf1d10f064684609c6907ba3ce12a46"></a><!-- doxytag: member="vrt::BasicVRLFrame::isCRCValid" ref="a4bf1d10f064684609c6907ba3ce12a46" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::BasicVRLFrame::isCRCValid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks to see if the CRC for the frame is valid. </p>
<p>This will always return true when the CRC is set to the special <a class="el" href="classvrt_1_1BasicVRLFrame.html#afcb1723c47875d18f590908170f1eb6d">NO_CRC</a> value. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if it is valid, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="affd27163e28ad37b798af6f3855a0bcb"></a><!-- doxytag: member="vrt::BasicVRLFrame::isFrameValid" ref="affd27163e28ad37b798af6f3855a0bcb" args="(int32_t length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::BasicVRLFrame::isFrameValid </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks to see if the frame is valid. </p>
<p>This method adds an extra length check onto the basic checks performed by <a class="el" href="classvrt_1_1BasicVRLFrame.html#a83b3a30637407ba9438691e15cda2739">isFrameValid()</a>. The most common use for this method is to verify that a frame read from a socket matches the length expected. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Verifies that the length of the frame matches this value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if it is valid, false otherwise. </dd></dl>

<p>References <a class="el" href="BasicVRLFrame_8h_source.html#l00236">getFrameValid()</a>.</p>

</div>
</div>
<a class="anchor" id="a83b3a30637407ba9438691e15cda2739"></a><!-- doxytag: member="vrt::BasicVRLFrame::isFrameValid" ref="a83b3a30637407ba9438691e15cda2739" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::BasicVRLFrame::isFrameValid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks to see if the frame is valid. </p>
<p>This checks the overall structure of the frame and verifies the CRC (if specified). It also checks to see that the length of the frame as reported in the frame header is equal to the length of the header and trailer plus the length of each packet in the trailer. For the purposes of the packet length check, only the length of a packet is considered, no consideration is made to the validity of the packet. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if it is valid, false otherwise. </dd></dl>

<p>References <a class="el" href="BasicVRLFrame_8h_source.html#l00236">getFrameValid()</a>.</p>

</div>
</div>
<a class="anchor" id="ac2f7ba9d4cd72e63274b72efac597c53"></a><!-- doxytag: member="vrt::BasicVRLFrame::isVRL" ref="ac2f7ba9d4cd72e63274b72efac597c53" args="(const void *ptr, int32_t off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool vrt::BasicVRLFrame::isVRL </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Does the given buffer contain a VRL frame? </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>The buffer to check. Note that the buffer can not be null and must have at least 4 octets following the offset given. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>The offset into the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if it is a VRL frame, false otherwise. </dd></dl>

<p>References <a class="el" href="BasicVRLFrame_8h_source.html#l00103">VRL_FAW_0</a>, <a class="el" href="BasicVRLFrame_8h_source.html#l00105">VRL_FAW_1</a>, <a class="el" href="BasicVRLFrame_8h_source.html#l00107">VRL_FAW_2</a>, and <a class="el" href="BasicVRLFrame_8h_source.html#l00109">VRL_FAW_3</a>.</p>

</div>
</div>
<a class="anchor" id="a15e0e67d74a33a457ea5fd3d4230f2b9"></a><!-- doxytag: member="vrt::BasicVRLFrame::isVRL" ref="a15e0e67d74a33a457ea5fd3d4230f2b9" args="(const vector&lt; char &gt; &amp;buf, int32_t off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool vrt::BasicVRLFrame::isVRL </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Does the given buffer contain a VRL frame? </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer to check. Note that the buffer can not be null and must have at least 4 octets following the offset given. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>The offset into the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if it is a VRL frame, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac01d0380e486a4d372277be29dce908d"></a><!-- doxytag: member="vrt::BasicVRLFrame::setFrameCount" ref="ac01d0380e486a4d372277be29dce908d" args="(int32_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRLFrame::setFrameCount </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>count</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets the value of the 12-bit frame counter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The frame count. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported, if the count is less than 0 or greater than 0x00000FFF. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7429d4a028423b869c173efacc39d1aa"></a><!-- doxytag: member="vrt::BasicVRLFrame::setFrameLength" ref="a7429d4a028423b869c173efacc39d1aa" args="(int32_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRLFrame::setFrameLength </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets the total length of the frame in octets including the header and trailer. </p>
<p><br/>
 <br/>
 In general the frame length should not be set directly; rather the setting of the packets in the frame should be used as the mechanism for setting the frame length. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The total length of the frame in octets. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported, if the length is less than 24 octets (the minimum length for a VRL frame) and/or not a multiple of 4-octets. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b7b47d1452286fac5de03faa6f1f71c"></a><!-- doxytag: member="vrt::BasicVRLFrame::setVRTPackets" ref="a1b7b47d1452286fac5de03faa6f1f71c" args="(int32_t maxFrameLength, const vector&lt; BasicVRTPacket * &gt; &amp;packets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicVRLFrame::setVRTPackets </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>maxFrameLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>packets</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets all of the VRT packets contained in the VRL frame. </p>
<p>Of the packets given, this method will try to put as many as possible into the frame that will fit given the specified maximum frame length. If fewer fit, it will put fewer in. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxFrameLength</em>&nbsp;</td><td>The maximum frame length in octets (inclusive of header and trailer). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packets</em>&nbsp;</td><td>The packets. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of packets inserted into the frame (could be 0). </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported or if <code>maxFrameLength</code> is invalid or if any of the packets are invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRLFrame_8h_source.html#l00066">MAX_FRAME_LENGTH</a>, <a class="el" href="BasicVRLFrame_8h_source.html#l00076">MIN_FRAME_LENGTH</a>, and <a class="el" href="BasicVRLFrame_8h_source.html#l00342">setVRTPackets()</a>.</p>

</div>
</div>
<a class="anchor" id="a92fa269d2799462acbd7bdc95e4d7b56"></a><!-- doxytag: member="vrt::BasicVRLFrame::setVRTPackets" ref="a92fa269d2799462acbd7bdc95e4d7b56" args="(int32_t maxFrameLength, const vector&lt; BasicVRTPacket &gt; &amp;packets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicVRLFrame::setVRTPackets </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>maxFrameLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>packets</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets all of the VRT packets contained in the VRL frame. </p>
<p>Of the packets given, this method will try to put as many as possible into the frame that will fit given the specified maximum frame length. If fewer fit, it will put fewer in. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxFrameLength</em>&nbsp;</td><td>The maximum frame length in octets (inclusive of header and trailer). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packets</em>&nbsp;</td><td>The packets. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of packets inserted into the frame (could be 0). </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported or if <code>maxFrameLength</code> is invalid or if any of the packets are invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRLFrame_8h_source.html#l00066">MAX_FRAME_LENGTH</a>, <a class="el" href="BasicVRLFrame_8h_source.html#l00076">MIN_FRAME_LENGTH</a>, and <a class="el" href="BasicVRLFrame_8h_source.html#l00342">setVRTPackets()</a>.</p>

</div>
</div>
<a class="anchor" id="ae87a374b98e3c198393b2547f2feb76d"></a><!-- doxytag: member="vrt::BasicVRLFrame::setVRTPackets" ref="ae87a374b98e3c198393b2547f2feb76d" args="(const vector&lt; BasicVRTPacket * &gt; &amp;packets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRLFrame::setVRTPackets </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>packets</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets all of the VRT packets contained in the VRL frame. </p>
<p>Strictly based on the maximum size of a VRT packet and the maximum size of a VRL frame, a minimum of 15 packets can be included. In normal use, only one or two tend to be included at a time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packets</em>&nbsp;</td><td>The packets. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported or if the total length of all packets exceeds the maximum that can be included in a single frame or if any of the packets are invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRLFrame_8h_source.html#l00066">MAX_FRAME_LENGTH</a>, and <a class="el" href="BasicVRLFrame_8h_source.html#l00342">setVRTPackets()</a>.</p>

</div>
</div>
<a class="anchor" id="a8459555aaf6234e2f1b3ee5153d9a2e5"></a><!-- doxytag: member="vrt::BasicVRLFrame::setVRTPackets" ref="a8459555aaf6234e2f1b3ee5153d9a2e5" args="(const vector&lt; BasicVRTPacket &gt; &amp;packets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRLFrame::setVRTPackets </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>packets</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets all of the VRT packets contained in the VRL frame. </p>
<p>Strictly based on the maximum size of a VRT packet and the maximum size of a VRL frame, a minimum of 15 packets can be included. In normal use, only one or two tend to be included at a time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packets</em>&nbsp;</td><td>The packets. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported or if the total length of all packets exceeds the maximum that can be included in a single frame or if any of the packets are invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRLFrame_8h_source.html#l00066">MAX_FRAME_LENGTH</a>, and <a class="el" href="BasicVRLFrame_8h_source.html#l00342">setVRTPackets()</a>.</p>

</div>
</div>
<a class="anchor" id="aff07dcbd0aca7170057873fce92d12e5"></a><!-- doxytag: member="vrt::BasicVRLFrame::setVRTPackets" ref="aff07dcbd0aca7170057873fce92d12e5" args="(int32_t maxFrameLength, const BasicVRTPacket *packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicVRLFrame::setVRTPackets </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>maxFrameLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets all of the VRT packets contained in the VRL frame. </p>
<p>Of the packets given, this method will try to put as many as possible into the frame that will fit given the specified maximum frame length. If fewer fit, it will put fewer in. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxFrameLength</em>&nbsp;</td><td>The maximum frame length in octets (inclusive of header and trailer). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>The packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of packets inserted into the frame (could be 0). </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported or if <code>maxFrameLength</code> is invalid or if any of the packets are invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRLFrame_8h_source.html#l00066">MAX_FRAME_LENGTH</a>, <a class="el" href="BasicVRLFrame_8h_source.html#l00076">MIN_FRAME_LENGTH</a>, and <a class="el" href="BasicVRLFrame_8h_source.html#l00342">setVRTPackets()</a>.</p>

</div>
</div>
<a class="anchor" id="a50f7b5f33571e78d49d98fbf6b223b5c"></a><!-- doxytag: member="vrt::BasicVRLFrame::setVRTPackets" ref="a50f7b5f33571e78d49d98fbf6b223b5c" args="(int32_t maxFrameLength, const BasicVRTPacket &amp;packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicVRLFrame::setVRTPackets </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>maxFrameLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets all of the VRT packets contained in the VRL frame. </p>
<p>Of the packets given, this method will try to put as many as possible into the frame that will fit given the specified maximum frame length. If fewer fit, it will put fewer in. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxFrameLength</em>&nbsp;</td><td>The maximum frame length in octets (inclusive of header and trailer). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>The packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of packets inserted into the frame (could be 0). </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported or if <code>maxFrameLength</code> is invalid or if any of the packets are invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRLFrame_8h_source.html#l00066">MAX_FRAME_LENGTH</a>, <a class="el" href="BasicVRLFrame_8h_source.html#l00076">MIN_FRAME_LENGTH</a>, and <a class="el" href="BasicVRLFrame_8h_source.html#l00342">setVRTPackets()</a>.</p>

</div>
</div>
<a class="anchor" id="ad0bbbb0d50a2596da7acb0ac6bad09f5"></a><!-- doxytag: member="vrt::BasicVRLFrame::setVRTPackets" ref="ad0bbbb0d50a2596da7acb0ac6bad09f5" args="(const BasicVRTPacket *packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRLFrame::setVRTPackets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets all of the VRT packets contained in the VRL frame. </p>
<p>Strictly based on the maximum size of a VRT packet and the maximum size of a VRL frame, a minimum of 15 packets can be included. In normal use, only one or two tend to be included at a time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>The packet. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported or if the total length of all packets exceeds the maximum that can be included in a single frame or if any of the packets are invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRLFrame_8h_source.html#l00066">MAX_FRAME_LENGTH</a>, and <a class="el" href="BasicVRLFrame_8h_source.html#l00342">setVRTPackets()</a>.</p>

</div>
</div>
<a class="anchor" id="ac21b7c8bdba4bd190247fed3b07a21c5"></a><!-- doxytag: member="vrt::BasicVRLFrame::setVRTPackets" ref="ac21b7c8bdba4bd190247fed3b07a21c5" args="(const BasicVRTPacket &amp;packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRLFrame::setVRTPackets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets all of the VRT packets contained in the VRL frame. </p>
<p>Strictly based on the maximum size of a VRT packet and the maximum size of a VRL frame, a minimum of 15 packets can be included. In normal use, only one or two tend to be included at a time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>The packet. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported or if the total length of all packets exceeds the maximum that can be included in a single frame or if any of the packets are invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRLFrame_8h_source.html#l00066">MAX_FRAME_LENGTH</a>.</p>

<p>Referenced by <a class="el" href="BasicVRLFrame_8h_source.html#l00356">setVRTPackets()</a>.</p>

</div>
</div>
<a class="anchor" id="a54c557c8fbb31eca704379882f3d9853"></a><!-- doxytag: member="vrt::BasicVRLFrame::swap" ref="a54c557c8fbb31eca704379882f3d9853" args="(vector&lt; char &gt; *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRLFrame::swap </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Does a buffer swap. </p>

</div>
</div>
<a class="anchor" id="a40d1dca344f27e95fd2e7e056eddc237"></a><!-- doxytag: member="vrt::BasicVRLFrame::toString" ref="a40d1dca344f27e95fd2e7e056eddc237" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual string vrt::BasicVRLFrame::toString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a free-form description of the frame. </p>
<p>Note that the content and structure of this string is implementation dependant and may change at any time. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A free-form string describing the frame. </dd></dl>

<p>Reimplemented from <a class="el" href="classvrt_1_1VRTObject.html#a8a8ca4be5d2b9075b6478685c2e121a1">vrt::VRTObject</a>.</p>

</div>
</div>
<a class="anchor" id="af75f534bcc125bf11679a275c335b6c9"></a><!-- doxytag: member="vrt::BasicVRLFrame::updateCRC" ref="af75f534bcc125bf11679a275c335b6c9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRLFrame::updateCRC </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This will compute the CRC value for the frame and set it in the CRC field. </p>
<p>All successful calls to one of the set methods on this packet will result in the CRC field being set, but that usually means that the CRC was merely set to the special <a class="el" href="classvrt_1_1BasicVRLFrame.html#afcb1723c47875d18f590908170f1eb6d">NO_CRC</a> value. This method must be called on the packet immediately before transmission (i.e. after the frame counter and frame length have been updated) if CRC protection is desired. <br/>
 <br/>
 Most transmission options (UDP, UDP Multicast, TCP, etc.) provide their own CRC protection, which renders the CRC field in the VRL frame redundant and just wastes extra computational time on both the sender and receiver. As such, this method should only be called when absolutely necessary and such a call should usually be the responsibility of the frame sending routines. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a6add1783362e99b36a0e62b009dbff54"></a><!-- doxytag: member="vrt::BasicVRLFrame::HEADER_LENGTH" ref="a6add1783362e99b36a0e62b009dbff54" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="classvrt_1_1BasicVRLFrame.html#a6add1783362e99b36a0e62b009dbff54">vrt::BasicVRLFrame::HEADER_LENGTH</a> = 8<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The length of the header in octets. </p>
<pre>
    MAX_HEADER_LENGTH = 8
  </pre> 
</div>
</div>
<a class="anchor" id="af8d8814f57ece97ba8ffadb34a1021dd"></a><!-- doxytag: member="vrt::BasicVRLFrame::MAX_FRAME_LENGTH" ref="af8d8814f57ece97ba8ffadb34a1021dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="classvrt_1_1BasicVRLFrame.html#af8d8814f57ece97ba8ffadb34a1021dd">vrt::BasicVRLFrame::MAX_FRAME_LENGTH</a> = 0x000FFFFF*4<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The maximum length of the frame in octets (header + payload + trailer). </p>
<p>Note that this is the absolute limit imposed by the VRL specification. The underlying transport protocols used (e.g. IP, UDP, TCP, etc.) may have limits lower than this. </p>
<pre>
    MAX_FRAME_LENGTH = 0x000FFFFF*4
  </pre> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classvrt_1_1BasicVRLFrame.html#a488f7da9d6603bc79acbf5f18849ed30" title="Gets the total length of the frame in octets including the header and trailer.">getFrameLength()</a> </dd></dl>

<p>Referenced by <a class="el" href="BasicVRLFrame_8h_source.html#l00342">setVRTPackets()</a>.</p>

</div>
</div>
<a class="anchor" id="a6becbd1792ac4c8fd992034df213edc0"></a><!-- doxytag: member="vrt::BasicVRLFrame::MAX_PAYLOAD_LENGTH" ref="a6becbd1792ac4c8fd992034df213edc0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="classvrt_1_1BasicVRLFrame.html#a6becbd1792ac4c8fd992034df213edc0">vrt::BasicVRLFrame::MAX_PAYLOAD_LENGTH</a> = <a class="el" href="classvrt_1_1BasicVRLFrame.html#af8d8814f57ece97ba8ffadb34a1021dd">MAX_FRAME_LENGTH</a> - <a class="el" href="classvrt_1_1BasicVRLFrame.html#a6add1783362e99b36a0e62b009dbff54">HEADER_LENGTH</a> - <a class="el" href="classvrt_1_1BasicVRLFrame.html#ac5ff60567f3a51615fff929895363f76">TRAILER_LENGTH</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The maximum length of the payload in octets. </p>
<p>Note that this is the absolute limit imposed by the VRL specification. The underlying transport protocols used (e.g. IP, UDP, TCP, etc.) may have limits lower than this. </p>
<pre>
    MAX_PAYLOAD_LENGTH = MAX_FRAME_LENGTH - MAX_HEADER_LENGTH - MAX_TRAILER_LENGTH
  </pre> 
</div>
</div>
<a class="anchor" id="aa45b2161a0b5ee723ed26b2ec0049e65"></a><!-- doxytag: member="vrt::BasicVRLFrame::MIN_FRAME_LENGTH" ref="aa45b2161a0b5ee723ed26b2ec0049e65" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="classvrt_1_1BasicVRLFrame.html#aa45b2161a0b5ee723ed26b2ec0049e65">vrt::BasicVRLFrame::MIN_FRAME_LENGTH</a> = <a class="el" href="classvrt_1_1BasicVRLFrame.html#a6add1783362e99b36a0e62b009dbff54">HEADER_LENGTH</a> + <a class="el" href="classvrt_1_1BasicVRLFrame.html#ac5ff60567f3a51615fff929895363f76">TRAILER_LENGTH</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The minimum length of the frame in octets (header + no payload + trailer). </p>
<p>Note that this is the absolute limit imposed by the VRL specification and results in a near-useless frame with no payload packets. </p>
<pre>
    MIN_FRAME_LENGTH = HEADER_LENGTH + TRAILER_LENGTH
  </pre> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classvrt_1_1BasicVRLFrame.html#a488f7da9d6603bc79acbf5f18849ed30" title="Gets the total length of the frame in octets including the header and trailer.">getFrameLength()</a> </dd></dl>

<p>Referenced by <a class="el" href="BasicVRLFrame_8h_source.html#l00371">setVRTPackets()</a>.</p>

</div>
</div>
<a class="anchor" id="afcb1723c47875d18f590908170f1eb6d"></a><!-- doxytag: member="vrt::BasicVRLFrame::NO_CRC" ref="afcb1723c47875d18f590908170f1eb6d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="classvrt_1_1BasicVRLFrame.html#afcb1723c47875d18f590908170f1eb6d">vrt::BasicVRLFrame::NO_CRC</a> = 0x56454E44<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the special code that can be used in place of the CRC32 in cases where a CRC is not considered unnecessary, and not included. </p>
<pre>
    NO_CRC = 0x56454E44 = { 'V', 'E', 'N', 'D' }
  </pre> 
<p>Referenced by <a class="el" href="AbstractVRAFile_8h_source.html#l00241">vrt::AbstractVRAFile::isCRCValid()</a>.</p>

</div>
</div>
<a class="anchor" id="aa099395e26f78c48e915c7079afa86aa"></a><!-- doxytag: member="vrt::BasicVRLFrame::NO_CRC_0" ref="aa099395e26f78c48e915c7079afa86aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int8_t <a class="el" href="classvrt_1_1BasicVRLFrame.html#aa099395e26f78c48e915c7079afa86aa">vrt::BasicVRLFrame::NO_CRC_0</a> = 0x56<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the 1st transmitted int8_t of the 32-bit <a class="el" href="classvrt_1_1BasicVRLFrame.html#afcb1723c47875d18f590908170f1eb6d">NO_CRC</a> code. </p>

</div>
</div>
<a class="anchor" id="ab08f1374b479c0bbd61ac14d7b843566"></a><!-- doxytag: member="vrt::BasicVRLFrame::NO_CRC_1" ref="ab08f1374b479c0bbd61ac14d7b843566" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int8_t <a class="el" href="classvrt_1_1BasicVRLFrame.html#ab08f1374b479c0bbd61ac14d7b843566">vrt::BasicVRLFrame::NO_CRC_1</a> = 0x45<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the 2nd transmitted int8_t of the 32-bit <a class="el" href="classvrt_1_1BasicVRLFrame.html#afcb1723c47875d18f590908170f1eb6d">NO_CRC</a> code. </p>

</div>
</div>
<a class="anchor" id="aba106d0fcfc0431f104baaa276f597f8"></a><!-- doxytag: member="vrt::BasicVRLFrame::NO_CRC_2" ref="aba106d0fcfc0431f104baaa276f597f8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int8_t <a class="el" href="classvrt_1_1BasicVRLFrame.html#aba106d0fcfc0431f104baaa276f597f8">vrt::BasicVRLFrame::NO_CRC_2</a> = 0x4E<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the 3rd transmitted int8_t of the 32-bit <a class="el" href="classvrt_1_1BasicVRLFrame.html#afcb1723c47875d18f590908170f1eb6d">NO_CRC</a> code. </p>

</div>
</div>
<a class="anchor" id="aba86f4a59ea8d6d53adc7974e7508fa6"></a><!-- doxytag: member="vrt::BasicVRLFrame::NO_CRC_3" ref="aba86f4a59ea8d6d53adc7974e7508fa6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int8_t <a class="el" href="classvrt_1_1BasicVRLFrame.html#aba86f4a59ea8d6d53adc7974e7508fa6">vrt::BasicVRLFrame::NO_CRC_3</a> = 0x44<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the 4th transmitted int8_t of the 32-bit <a class="el" href="classvrt_1_1BasicVRLFrame.html#afcb1723c47875d18f590908170f1eb6d">NO_CRC</a> code. </p>

</div>
</div>
<a class="anchor" id="ac5ff60567f3a51615fff929895363f76"></a><!-- doxytag: member="vrt::BasicVRLFrame::TRAILER_LENGTH" ref="ac5ff60567f3a51615fff929895363f76" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="classvrt_1_1BasicVRLFrame.html#ac5ff60567f3a51615fff929895363f76">vrt::BasicVRLFrame::TRAILER_LENGTH</a> = 4<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The length of the trailer in octets. </p>
<pre>
    MAX_TRAILER_LENGTH = 4
  </pre> 
</div>
</div>
<a class="anchor" id="a2f82c7c9cb96dd6e78359461be9c8f72"></a><!-- doxytag: member="vrt::BasicVRLFrame::VRL_FAW" ref="a2f82c7c9cb96dd6e78359461be9c8f72" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="classvrt_1_1BasicVRLFrame.html#a2f82c7c9cb96dd6e78359461be9c8f72">vrt::BasicVRLFrame::VRL_FAW</a> = 0x56524C50<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the 32-bit FWA (frame alignment word) marking the start of the frame. </p>
<pre>
    VRL_FAW = 0x56524C50 = { 'V', 'R', 'L', 'P' }
  </pre> 
</div>
</div>
<a class="anchor" id="a7a5af0cd5a4607c7803b4cd5378aea21"></a><!-- doxytag: member="vrt::BasicVRLFrame::VRL_FAW_0" ref="a7a5af0cd5a4607c7803b4cd5378aea21" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int8_t <a class="el" href="classvrt_1_1BasicVRLFrame.html#a7a5af0cd5a4607c7803b4cd5378aea21">vrt::BasicVRLFrame::VRL_FAW_0</a> = 0x56<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the 1st transmitted int8_t of the 32-bit FWA (<a class="el" href="classvrt_1_1BasicVRLFrame.html#a2f82c7c9cb96dd6e78359461be9c8f72">VRL_FAW</a>). </p>

<p>Referenced by <a class="el" href="BasicVRLFrame_8h_source.html#l00513">isVRL()</a>.</p>

</div>
</div>
<a class="anchor" id="a105fb25594da02a6cd3ae72b7729f7a8"></a><!-- doxytag: member="vrt::BasicVRLFrame::VRL_FAW_1" ref="a105fb25594da02a6cd3ae72b7729f7a8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int8_t <a class="el" href="classvrt_1_1BasicVRLFrame.html#a105fb25594da02a6cd3ae72b7729f7a8">vrt::BasicVRLFrame::VRL_FAW_1</a> = 0x52<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the 2nd transmitted int8_t of the 32-bit FWA (<a class="el" href="classvrt_1_1BasicVRLFrame.html#a2f82c7c9cb96dd6e78359461be9c8f72">VRL_FAW</a>). </p>

<p>Referenced by <a class="el" href="BasicVRLFrame_8h_source.html#l00513">isVRL()</a>.</p>

</div>
</div>
<a class="anchor" id="a13ed766a1fafb47a5e27d9f213b1e482"></a><!-- doxytag: member="vrt::BasicVRLFrame::VRL_FAW_2" ref="a13ed766a1fafb47a5e27d9f213b1e482" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int8_t <a class="el" href="classvrt_1_1BasicVRLFrame.html#a13ed766a1fafb47a5e27d9f213b1e482">vrt::BasicVRLFrame::VRL_FAW_2</a> = 0x4C<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the 3rd transmitted int8_t of the 32-bit FWA (<a class="el" href="classvrt_1_1BasicVRLFrame.html#a2f82c7c9cb96dd6e78359461be9c8f72">VRL_FAW</a>). </p>

<p>Referenced by <a class="el" href="BasicVRLFrame_8h_source.html#l00513">isVRL()</a>.</p>

</div>
</div>
<a class="anchor" id="aba85f2b68615e4edf3653abb70535199"></a><!-- doxytag: member="vrt::BasicVRLFrame::VRL_FAW_3" ref="aba85f2b68615e4edf3653abb70535199" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int8_t <a class="el" href="classvrt_1_1BasicVRLFrame.html#aba85f2b68615e4edf3653abb70535199">vrt::BasicVRLFrame::VRL_FAW_3</a> = 0x50<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the 4th transmitted int8_t of the 32-bit FWA (<a class="el" href="classvrt_1_1BasicVRLFrame.html#a2f82c7c9cb96dd6e78359461be9c8f72">VRL_FAW</a>). </p>

<p>Referenced by <a class="el" href="BasicVRLFrame_8h_source.html#l00513">isVRL()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cpp_src/vrt/lib/<a class="el" href="BasicVRLFrame_8h_source.html">BasicVRLFrame.h</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 29 Jun 2018 for VRT by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>

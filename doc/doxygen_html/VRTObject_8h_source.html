<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VRT: cpp_src/vrt/lib/VRTObject.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_d89bddcbea8627bd614e469eff23c807.html">cpp_src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_4bc80685627bb56d74fc873ad9fe5052.html">vrt</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_e56f1459fac3e34d215c0efeefbde30f.html">lib</a>
  </div>
</div>
<div class="contents">
<h1>VRTObject.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* ===================== COPYRIGHT NOTICE =====================</span>
<a name="l00002"></a>00002 <span class="comment"> * This file is protected by Copyright. Please refer to the COPYRIGHT file</span>
<a name="l00003"></a>00003 <span class="comment"> * distributed with this source distribution.</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * This file is part of REDHAWK.</span>
<a name="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007"></a>00007 <span class="comment"> * REDHAWK is free software: you can redistribute it and/or modify it</span>
<a name="l00008"></a>00008 <span class="comment"> * under the terms of the GNU Lesser General Public License as published by the</span>
<a name="l00009"></a>00009 <span class="comment"> * Free Software Foundation, either version 3 of the License, or (at your</span>
<a name="l00010"></a>00010 <span class="comment"> * option) any later version.</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> * REDHAWK is distributed in the hope that it will be useful, but WITHOUT</span>
<a name="l00013"></a>00013 <span class="comment"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<a name="l00014"></a>00014 <span class="comment"> * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License</span>
<a name="l00015"></a>00015 <span class="comment"> * for more details.</span>
<a name="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017"></a>00017 <span class="comment"> * You should have received a copy of the GNU Lesser General Public License</span>
<a name="l00018"></a>00018 <span class="comment"> * along with this program. If not, see http://www.gnu.org/licenses/.</span>
<a name="l00019"></a>00019 <span class="comment"> * ============================================================</span>
<a name="l00020"></a>00020 <span class="comment"> */</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#ifndef _VRTObject_h</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span><span class="preprocessor">#define _VRTObject_h</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;cctype&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;climits&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;exception&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;ostream&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;typeinfo&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;iostream&gt;</span>  <span class="comment">// required for std::cerr</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;limits&gt;</span>    <span class="comment">// required for numeric_limits(..) on GCC4.4/libc6 2.11.1</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;stdio.h&gt;</span>   <span class="comment">// required for printf(..) on GCC4.4/libc6 2.11.1</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>  <span class="comment">// required for free(..) under clang</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;math.h&gt;</span>    <span class="comment">// required for isnan(..)</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="preprocessor">#define __STDC_LIMIT_MACROS  1 </span><span class="comment">/* Required to include the __INT64_C(..) macro in stdint.h */</span>
<a name="l00041"></a>00041 <span class="preprocessor">#define __STDC_FORMAT_MACROS 1 </span><span class="comment">/* Required to include the PRI?64 constants in inttypes.h */</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;stdint.h&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;inttypes.h&gt;</span>
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="comment">/* This next section copied from stdint.h */</span>
<a name="l00046"></a>00046 <span class="preprocessor"># if (defined(__APPLE__) &amp;&amp; defined(__MACH__))</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="comment">// For some reason (probably historical) GCC 4.2 on OS X (APPLE+MACH) uses &quot;LL&quot; as the suffix</span>
<a name="l00048"></a>00048 <span class="comment">// regardless of architecture. To be honest, this makes more sense than the &quot;normal&quot; usage.</span>
<a name="l00049"></a>00049 <span class="preprocessor">#  define __INT64_C(c)  c ## LL</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span><span class="preprocessor">#  define __UINT64_C(c) c ## ULL</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="preprocessor"># elif __WORDSIZE == 64</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#  define __INT64_C(c)  c ## L</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span><span class="preprocessor">#  define __UINT64_C(c) c ## UL</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span><span class="preprocessor"># else</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span><span class="preprocessor">#  define __INT64_C(c)  c ## LL</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="preprocessor">#  define __UINT64_C(c) c ## ULL</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span>
<a name="l00066"></a>00066 <span class="preprocessor">#ifdef __GNUC__</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="preprocessor"># define __GCC_VERSION ((__GNUC__ * 10000) + (__GNUC_MINOR__ * 100) + __GNUC_PATCHLEVEL__)</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span><span class="preprocessor"># ifndef __INTEL_COMPILER</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span><span class="preprocessor">#  define __GNU_COMPILER __GCC_VERSION</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span>
<a name="l00077"></a>00077 <span class="preprocessor">#ifdef __clang__</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span><span class="preprocessor"># define __CLANG_COMPILER ((__clang_major__ * 10000) + (__clang_minor__ * 100) + __clang_patchlevel__)</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span>
<a name="l00085"></a>00085 <span class="preprocessor">#ifndef PRINT_ALL_EXCEPTIONS</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span><span class="preprocessor"># define PRINT_ALL_EXCEPTIONS 0</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00088"></a>00088 <span class="preprocessor"></span>
<a name="l00093"></a>00093 <span class="preprocessor">#ifndef INCLUDE_STACK_TRACE</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span><span class="preprocessor"># ifdef __CLANG_COMPILER</span>
<a name="l00095"></a>00095 <span class="preprocessor"></span>   <span class="comment">// The following line fails under Clang 2.8 due to a compiler bug:</span>
<a name="l00096"></a>00096    <span class="comment">// #define INCLUDE_STACK_TRACE __has_include(&lt;cxxabi.h&gt;)</span>
<a name="l00097"></a>00097 <span class="preprocessor">#  if __has_include(&lt;cxxabi.h&gt;)</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span><span class="preprocessor">#    define INCLUDE_STACK_TRACE 1</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span><span class="preprocessor">#   else</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span><span class="preprocessor">#    define INCLUDE_STACK_TRACE 0</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span><span class="preprocessor">#  endif</span>
<a name="l00102"></a>00102 <span class="preprocessor"></span><span class="preprocessor"># else</span>
<a name="l00103"></a>00103 <span class="preprocessor"></span><span class="preprocessor">#  define INCLUDE_STACK_TRACE 1</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00105"></a>00105 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00106"></a>00106 <span class="preprocessor"></span>
<a name="l00112"></a>00112 <span class="preprocessor">#ifndef NOT_USING_JNI</span>
<a name="l00113"></a>00113 <span class="preprocessor"></span><span class="preprocessor"># define NOT_USING_JNI 1</span>
<a name="l00114"></a>00114 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00115"></a>00115 <span class="preprocessor"></span>
<a name="l00117"></a>00117 <span class="preprocessor">#if defined(DOXYGEN)</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span>  <span class="comment">// doxygen gets confused by _Pragma(..) (see doxygen bug 643056) so</span>
<a name="l00119"></a>00119   <span class="comment">// we set NO_PRAGMAS=1 when using doxygen to avoid issues. This is</span>
<a name="l00120"></a>00120   <span class="comment">// not intended as a genearl-purpose flag, only one we use to work</span>
<a name="l00121"></a>00121   <span class="comment">// around this issue.</span>
<a name="l00122"></a>00122 <span class="preprocessor"># define _Clang_Pragma(x) </span><span class="comment">/* ignore */</span>
<a name="l00123"></a>00123 <span class="preprocessor"># define _GCC_Pragma(x)   </span><span class="comment">/* ignore */</span>
<a name="l00124"></a>00124 <span class="preprocessor"># define _Intel_Pragma(x) </span><span class="comment">/* ignore */</span>
<a name="l00125"></a>00125 <span class="preprocessor"># define __attribute__(x) </span><span class="comment">/* ignore */</span>
<a name="l00126"></a>00126 <span class="preprocessor"># define __clangattr__(x) </span><span class="comment">/* ignore */</span>
<a name="l00127"></a>00127 <span class="preprocessor"># define __intelattr__(x) </span><span class="comment">/* ignore */</span>
<a name="l00128"></a>00128 <span class="preprocessor">#elif defined(__INTEL_COMPILER) &amp;&amp; defined(__GNUC__)</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span>  <span class="comment">// Although the Intel compilers support GCC&apos;s __attribute__(..) on</span>
<a name="l00130"></a>00130   <span class="comment">// Linux (and similar) platforms, their support for it is limited.</span>
<a name="l00131"></a>00131   <span class="comment">// As a result we use __intelattr__(..) as a stand-in where it may</span>
<a name="l00132"></a>00132   <span class="comment">// be appropriate. Blanket use of all of GCC&apos;s __attribute__(..)</span>
<a name="l00133"></a>00133   <span class="comment">// flags simply gets us a lot of unnecessary warnings.</span>
<a name="l00134"></a>00134 <span class="preprocessor"># define _Clang_Pragma(x)</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span><span class="preprocessor"># define _GCC_Pragma(x)</span>
<a name="l00136"></a>00136 <span class="preprocessor"></span><span class="preprocessor"># define _Intel_Pragma(x) _Pragma(x)</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span><span class="preprocessor"># define __attribute__(x)</span>
<a name="l00138"></a>00138 <span class="preprocessor"></span><span class="preprocessor"># define __clangattr__(x)</span>
<a name="l00139"></a>00139 <span class="preprocessor"></span><span class="preprocessor"># define __intelattr__(x) __attribute__(x)</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span><span class="preprocessor">#elif defined(__INTEL_COMPILER)</span>
<a name="l00141"></a>00141 <span class="preprocessor"></span><span class="preprocessor"># define _Clang_Pragma(x)</span>
<a name="l00142"></a>00142 <span class="preprocessor"></span>  <span class="comment">// Although the Clang support GCC&apos;s __attribute__(..), its support</span>
<a name="l00143"></a>00143   <span class="comment">// for is limited. As a result we use __clangattr__(..) as a</span>
<a name="l00144"></a>00144   <span class="comment">// stand-in where it may be appropriate. Blanket use of all of</span>
<a name="l00145"></a>00145   <span class="comment">// GCC&apos;s __attribute__(..) flags simply gets us a lot of</span>
<a name="l00146"></a>00146   <span class="comment">// unnecessary warnings.</span>
<a name="l00147"></a>00147 <span class="preprocessor"># define _Clang_Pragma(x)</span>
<a name="l00148"></a>00148 <span class="preprocessor"></span><span class="preprocessor"># define _GCC_Pragma(x)</span>
<a name="l00149"></a>00149 <span class="preprocessor"></span><span class="preprocessor"># define _Intel_Pragma(x) _Pragma(x)</span>
<a name="l00150"></a>00150 <span class="preprocessor"></span><span class="preprocessor"># define __attribute__(x)</span>
<a name="l00151"></a>00151 <span class="preprocessor"></span><span class="preprocessor"># define __clangattr__(x)</span>
<a name="l00152"></a>00152 <span class="preprocessor"></span><span class="preprocessor"># define __intelattr__(x)</span>
<a name="l00153"></a>00153 <span class="preprocessor"></span><span class="preprocessor">#elif defined(__CLANG_COMPILER)</span>
<a name="l00154"></a>00154 <span class="preprocessor"></span><span class="preprocessor"># define _Clang_Pragma(x) _Pragma(x)</span>
<a name="l00155"></a>00155 <span class="preprocessor"></span><span class="preprocessor"># define _GCC_Pragma(x)</span>
<a name="l00156"></a>00156 <span class="preprocessor"></span><span class="preprocessor"># define _Intel_Pragma(x)</span>
<a name="l00157"></a>00157 <span class="preprocessor"></span><span class="preprocessor"># define __attribute__(x)</span>
<a name="l00158"></a>00158 <span class="preprocessor"></span><span class="preprocessor"># define __clangattr__(x) __attribute__(x)</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span><span class="preprocessor"># define __intelattr__(x)</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span><span class="preprocessor">#elif defined(__GNUC__)</span>
<a name="l00161"></a>00161 <span class="preprocessor"></span><span class="preprocessor"># define _Clang_Pragma(x)</span>
<a name="l00162"></a>00162 <span class="preprocessor"></span><span class="preprocessor"># define _GCC_Pragma(x)   _Pragma(x)</span>
<a name="l00163"></a>00163 <span class="preprocessor"></span><span class="preprocessor"># define _Intel_Pragma(x)</span>
<a name="l00164"></a>00164 <span class="preprocessor"></span><span class="preprocessor"># define __attribute__(x) __attribute__(x)</span>
<a name="l00165"></a>00165 <span class="preprocessor"></span><span class="preprocessor"># define __clangattr__(x)</span>
<a name="l00166"></a>00166 <span class="preprocessor"></span><span class="preprocessor"># define __intelattr__(x)</span>
<a name="l00167"></a>00167 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span>  <span class="comment">// Disable attributes/pragmas where we don&apos;t know compiler</span>
<a name="l00169"></a>00169 <span class="preprocessor"># define _Clang_Pragma(x)</span>
<a name="l00170"></a>00170 <span class="preprocessor"></span><span class="preprocessor"># define _GCC_Pragma(x)</span>
<a name="l00171"></a>00171 <span class="preprocessor"></span><span class="preprocessor"># define _Intel_Pragma(x)</span>
<a name="l00172"></a>00172 <span class="preprocessor"></span><span class="preprocessor"># define __attribute__(x)</span>
<a name="l00173"></a>00173 <span class="preprocessor"></span><span class="preprocessor"># define __clangattr__(x)</span>
<a name="l00174"></a>00174 <span class="preprocessor"></span><span class="preprocessor"># define __intelattr__(x)</span>
<a name="l00175"></a>00175 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00176"></a>00176 <span class="preprocessor"></span>
<a name="l00178"></a>00178 <span class="preprocessor">#if __GNUC__ || __CLANG_COMPILER</span>
<a name="l00179"></a>00179 <span class="preprocessor"></span><span class="preprocessor"># define UNUSED_VARIABLE(x) ((void)x)</span>
<a name="l00180"></a>00180 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00181"></a>00181 <span class="preprocessor"></span><span class="preprocessor"># define UNUSED_VARIABLE(x) </span><span class="comment">/* ignore */</span>
<a name="l00182"></a>00182 <span class="preprocessor">#endif</span>
<a name="l00183"></a>00183 <span class="preprocessor"></span>
<a name="l00187"></a>00187 <span class="preprocessor">#define END_NAMESPACE </span><span class="comment">/* ignore */</span>
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 <span class="keyword">using namespace </span>std;
<a name="l00190"></a>00190 
<a name="l00191"></a>00191 <span class="keyword">namespace </span>vrt {
<a name="l00193"></a>00193   <span class="comment">// typedefs and constants</span>
<a name="l00195"></a>00195 <span class="comment"></span>
<a name="l00198"></a>00198   <span class="keyword">enum</span> boolNull { _FALSE=-1, _NULL=0, _TRUE=+1 };
<a name="l00199"></a>00199 
<a name="l00204"></a>00204   <span class="keyword">const</span> int8_t  INT8_NULL  = numeric_limits&lt;char&gt;::min();
<a name="l00209"></a>00209   <span class="keyword">const</span> int16_t INT16_NULL = numeric_limits&lt;int16_t&gt;::min();
<a name="l00214"></a>00214   <span class="keyword">const</span> int32_t INT32_NULL = numeric_limits&lt;int32_t&gt;::min();
<a name="l00219"></a>00219   <span class="keyword">const</span> int64_t INT64_NULL = numeric_limits&lt;int64_t&gt;::min();
<a name="l00228"></a>00228   <span class="keyword">const</span> <span class="keywordtype">float</span> __attribute__((unused)) __intelattr__((unused)) FLOAT_NAN  = numeric_limits&lt;<span class="keywordtype">float</span>&gt;::quiet_NaN();
<a name="l00237"></a>00237   const <span class="keywordtype">double</span> __attribute__((unused)) __intelattr__((unused)) DOUBLE_NAN = numeric_limits&lt;<span class="keywordtype">float</span>&gt;::quiet_NaN();
<a name="l00238"></a>00238 
<a name="l00239"></a>00239 <span class="preprocessor">#if NOT_USING_JNI</span>
<a name="l00241"></a>00241 <span class="preprocessor">  // VRTObject</span>
<a name="l00243"></a>00243 <span class="preprocessor">  namespace VRTObject_private {</span>
<a name="l00244"></a>00244 <span class="preprocessor"></span>
<a name="l00252"></a>00252     <span class="keywordtype">string</span> getClassName (<span class="keyword">const</span> <span class="keywordtype">char</span> *name);
<a name="l00253"></a>00253   }
<a name="l00254"></a>00254 <span class="preprocessor">#endif</span>
<a name="l00255"></a>00255 <span class="preprocessor"></span>
<a name="l00257"></a>00257   <span class="comment">// MutexObj</span>
<a name="l00259"></a>00259 <span class="comment"></span><span class="preprocessor">#if NOT_USING_JNI</span>
<a name="l00260"></a>00260 <span class="preprocessor"></span>
<a name="l00263"></a><a class="code" href="classvrt_1_1MutexObj.html">00263</a>   <span class="keyword">class </span><a class="code" href="classvrt_1_1MutexObj.html" title="Internal Use Only: Holds a mutex object.">MutexObj</a> {
<a name="l00264"></a>00264     <span class="keyword">private</span>: pthread_mutex_t mutexLock;  <span class="comment">// the low-level lock</span>
<a name="l00265"></a>00265     <span class="keyword">private</span>: <span class="keywordtype">bool</span>            isLocked;   <span class="comment">// is it already locked?</span>
<a name="l00266"></a>00266     <span class="keyword">private</span>: pthread_t       mutexOwner; <span class="comment">// the mutex owner (if locked)</span>
<a name="l00267"></a>00267 
<a name="l00269"></a>00269     <span class="keyword">public</span>: <a class="code" href="classvrt_1_1MutexObj.html" title="Internal Use Only: Holds a mutex object.">MutexObj</a> ();
<a name="l00271"></a>00271     <span class="keyword">public</span>: <span class="keyword">virtual</span> ~<a class="code" href="classvrt_1_1MutexObj.html" title="Internal Use Only: Holds a mutex object.">MutexObj</a> ();
<a name="l00273"></a>00273     <span class="keyword">public</span>: <a class="code" href="classvrt_1_1MutexObj.html" title="Internal Use Only: Holds a mutex object.">MutexObj</a>* lock ();
<a name="l00275"></a>00275     <span class="keyword">public</span>: <span class="keywordtype">void</span> unlock ();
<a name="l00276"></a>00276   };
<a name="l00277"></a>00277 <span class="preprocessor">#endif</span>
<a name="l00278"></a>00278 <span class="preprocessor"></span>
<a name="l00280"></a>00280   <span class="comment">// VRTObject</span>
<a name="l00282"></a>00282 <span class="comment"></span><span class="preprocessor">#if NOT_USING_JNI</span>
<a name="l00283"></a>00283 <span class="preprocessor"></span>
<a name="l00286"></a><a class="code" href="classvrt_1_1VRTObject.html">00286</a>   <span class="keyword">class </span><a class="code" href="classvrt_1_1VRTObject.html" title="A basic root-level object definition.">VRTObject</a> {
<a name="l00287"></a>00287     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classvrt_1_1MutexLock.html" title="Internal Use Only: Holds a mutex lock.">MutexLock</a>;
<a name="l00288"></a>00288 
<a name="l00289"></a>00289     <span class="keyword">private</span>: <a class="code" href="classvrt_1_1MutexObj.html" title="Internal Use Only: Holds a mutex object.">MutexObj</a> mutexObj; <span class="comment">// Mutex object to use</span>
<a name="l00290"></a>00290 
<a name="l00292"></a><a class="code" href="classvrt_1_1VRTObject.html#ab4c3dc92af66dd76212bccfee0a25177">00292</a>     <span class="keyword">public</span>: <a class="code" href="classvrt_1_1VRTObject.html#ab4c3dc92af66dd76212bccfee0a25177" title="Basic copy constructor.">VRTObject</a> (<span class="keyword">const</span> <a class="code" href="classvrt_1_1VRTObject.html" title="A basic root-level object definition.">VRTObject</a> &amp;o) { UNUSED_VARIABLE(o); }
<a name="l00293"></a>00293 
<a name="l00295"></a><a class="code" href="classvrt_1_1VRTObject.html#a63fdb914d0bb40e45bce0a9a5cd24dee">00295</a>     <span class="keyword">public</span>: <a class="code" href="classvrt_1_1VRTObject.html#a63fdb914d0bb40e45bce0a9a5cd24dee" title="Basic no-argument constructor.">VRTObject</a> () { }
<a name="l00296"></a>00296 
<a name="l00298"></a><a class="code" href="classvrt_1_1VRTObject.html#a0a45b4fde7c62aa7d95722e6a9db6769">00298</a>     <span class="keyword">public</span>: <span class="keyword">virtual</span> <a class="code" href="classvrt_1_1VRTObject.html#a0a45b4fde7c62aa7d95722e6a9db6769" title="Basic destructor.">~VRTObject</a>() { }
<a name="l00299"></a>00299 
<a name="l00301"></a>00301     <span class="keyword">public</span>: <span class="keyword">virtual</span> <span class="keywordtype">string</span> toString () <span class="keyword">const</span>;
<a name="l00302"></a>00302 
<a name="l00304"></a>00304     <span class="keyword">public</span>: <span class="keyword">virtual</span> <span class="keywordtype">bool</span> equals (<span class="keyword">const</span> <a class="code" href="classvrt_1_1VRTObject.html" title="A basic root-level object definition.">VRTObject</a> &amp;o) <span class="keyword">const</span>;
<a name="l00305"></a>00305 
<a name="l00318"></a>00318     <span class="keyword">public</span>: <span class="keyword">virtual</span> <span class="keywordtype">bool</span> equals (<span class="keyword">const</span> <a class="code" href="classvrt_1_1VRTObject.html" title="A basic root-level object definition.">VRTObject</a> *o) <span class="keyword">const</span>;
<a name="l00319"></a>00319 
<a name="l00321"></a><a class="code" href="classvrt_1_1VRTObject.html#aece9190b3982d1e53dce5c638b1e33bb">00321</a>     <span class="keyword">public</span>: <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classvrt_1_1VRTObject.html#aece9190b3982d1e53dce5c638b1e33bb" title="Tests two VRTObjects for equality.">equal</a> (<span class="keyword">const</span> <a class="code" href="classvrt_1_1VRTObject.html" title="A basic root-level object definition.">VRTObject</a> &amp;a, <span class="keyword">const</span> <a class="code" href="classvrt_1_1VRTObject.html" title="A basic root-level object definition.">VRTObject</a> &amp;b) {
<a name="l00322"></a>00322       <span class="keywordflow">return</span> a.<a class="code" href="classvrt_1_1VRTObject.html#a2f18f4efc73c423629510033039536fc" title="Tests this object for equality with another one.">equals</a>(b);
<a name="l00323"></a>00323     }
<a name="l00324"></a>00324 
<a name="l00326"></a><a class="code" href="classvrt_1_1VRTObject.html#a3b0ecc4f10eb99ef3ef9a0b9c80722f5">00326</a>     <span class="keyword">public</span>: <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classvrt_1_1VRTObject.html#a3b0ecc4f10eb99ef3ef9a0b9c80722f5" title="Tests two VRTObjects for equality.">equal</a> (<span class="keyword">const</span> <a class="code" href="classvrt_1_1VRTObject.html" title="A basic root-level object definition.">VRTObject</a> *a, <span class="keyword">const</span> <a class="code" href="classvrt_1_1VRTObject.html" title="A basic root-level object definition.">VRTObject</a> *b) {
<a name="l00327"></a>00327       <span class="keyword">const</span> <span class="keywordtype">void</span> *_a = (<span class="keyword">const</span> <span class="keywordtype">void</span>*)a;
<a name="l00328"></a>00328       <span class="keyword">const</span> <span class="keywordtype">void</span> *_b = (<span class="keyword">const</span> <span class="keywordtype">void</span>*)b;
<a name="l00329"></a>00329       <span class="keywordflow">return</span> (_a == NULL)? (_b == NULL) : a-&gt;<a class="code" href="classvrt_1_1VRTObject.html#a2f18f4efc73c423629510033039536fc" title="Tests this object for equality with another one.">equals</a>(b);
<a name="l00330"></a>00330     }
<a name="l00331"></a>00331 
<a name="l00333"></a>00333     <span class="keyword">public</span>: <span class="keywordtype">string</span> getClassName () <span class="keyword">const</span>;
<a name="l00334"></a>00334 
<a name="l00336"></a>00336     <span class="keyword">public</span>: <span class="keywordtype">void</span> _delete ();
<a name="l00337"></a>00337 
<a name="l00339"></a><a class="code" href="classvrt_1_1VRTObject.html#acbbed337fea110d381e12c8d0b3ae11e">00339</a>     <span class="keyword">public</span>: <span class="keyword">inline</span> <span class="keyword">const</span> type_info &amp;<a class="code" href="classvrt_1_1VRTObject.html#acbbed337fea110d381e12c8d0b3ae11e" title="Gets the type_info for the class.">getClass</a> ()<span class="keyword"> const </span>{
<a name="l00340"></a>00340       <span class="keywordflow">return</span> <span class="keyword">typeid</span>(*this);
<a name="l00341"></a>00341     }
<a name="l00342"></a>00342 
<a name="l00344"></a><a class="code" href="classvrt_1_1VRTObject.html#a0e0124717a2dba5413c6c230a7a5581c">00344</a>     <span class="keyword">public</span>: <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator== (<span class="keyword">const</span> <a class="code" href="classvrt_1_1VRTObject.html" title="A basic root-level object definition.">VRTObject</a> &amp;o)<span class="keyword"> const </span>{
<a name="l00345"></a>00345       <span class="keywordflow">return</span> equals(o);
<a name="l00346"></a>00346     }
<a name="l00347"></a>00347 
<a name="l00349"></a><a class="code" href="classvrt_1_1VRTObject.html#adea0cac3059715eeafb24316e4a4b777">00349</a>     <span class="keyword">public</span>: <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!= (<span class="keyword">const</span> <a class="code" href="classvrt_1_1VRTObject.html" title="A basic root-level object definition.">VRTObject</a> &amp;o)<span class="keyword"> const </span>{
<a name="l00350"></a>00350       <span class="keywordflow">return</span> !equals(o);
<a name="l00351"></a>00351     }
<a name="l00352"></a>00352 
<a name="l00354"></a><a class="code" href="classvrt_1_1VRTObject.html#a769e204f208f470e0d20d23964a23d3f">00354</a>     <span class="keyword">public</span>: <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator== (<span class="keyword">const</span> <a class="code" href="classvrt_1_1VRTObject.html" title="A basic root-level object definition.">VRTObject</a> *o)<span class="keyword"> const </span>{
<a name="l00355"></a>00355       <span class="keywordflow">return</span> equals(o);
<a name="l00356"></a>00356     }
<a name="l00357"></a>00357 
<a name="l00359"></a><a class="code" href="classvrt_1_1VRTObject.html#a93fa0444bf04e1bed3547828381cee45">00359</a>     <span class="keyword">public</span>: <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!= (<span class="keyword">const</span> <a class="code" href="classvrt_1_1VRTObject.html" title="A basic root-level object definition.">VRTObject</a> *o)<span class="keyword"> const </span>{
<a name="l00360"></a>00360       <span class="keywordflow">return</span> !equals(o);
<a name="l00361"></a>00361     }
<a name="l00362"></a>00362 
<a name="l00364"></a><a class="code" href="classvrt_1_1VRTObject.html#ad5fc53758bf19350e251f4cd84670e2c">00364</a>     <span class="keyword">public</span>: <span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classvrt_1_1VRTObject.html#ad5fc53758bf19350e251f4cd84670e2c" title="Is this object equal to null.">isNullValue</a> ()<span class="keyword"> const </span>{
<a name="l00365"></a>00365       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00366"></a>00366     }
<a name="l00367"></a>00367   };
<a name="l00368"></a>00368 <span class="preprocessor">#endif</span>
<a name="l00369"></a>00369 <span class="preprocessor"></span>
<a name="l00371"></a>00371   <span class="comment">// MutexLock</span>
<a name="l00373"></a>00373 <span class="comment"></span><span class="preprocessor">#if NOT_USING_JNI</span>
<a name="l00374"></a>00374 <span class="preprocessor"></span>
<a name="l00377"></a><a class="code" href="classvrt_1_1MutexLock.html">00377</a>   <span class="keyword">class </span><a class="code" href="classvrt_1_1MutexLock.html" title="Internal Use Only: Holds a mutex lock.">MutexLock</a> {
<a name="l00378"></a>00378     <span class="keyword">private</span>: <a class="code" href="classvrt_1_1MutexObj.html" title="Internal Use Only: Holds a mutex object.">MutexObj</a> *mutexObj;
<a name="l00380"></a>00380     <span class="keyword">public</span>: <a class="code" href="classvrt_1_1MutexLock.html" title="Internal Use Only: Holds a mutex lock.">MutexLock</a> (<span class="keyword">const</span> <a class="code" href="classvrt_1_1VRTObject.html" title="A basic root-level object definition.">VRTObject</a> *obj);
<a name="l00382"></a>00382     <span class="keyword">public</span>: <a class="code" href="classvrt_1_1MutexLock.html" title="Internal Use Only: Holds a mutex lock.">MutexLock</a> (<span class="keyword">const</span> <a class="code" href="classvrt_1_1VRTObject.html" title="A basic root-level object definition.">VRTObject</a> &amp;obj);
<a name="l00384"></a><a class="code" href="classvrt_1_1MutexLock.html#aac25224566b4feb3a01f83d7790ca07f">00384</a>     <span class="keyword">public</span>: <span class="keyword">virtual</span> <a class="code" href="classvrt_1_1MutexLock.html#aac25224566b4feb3a01f83d7790ca07f" title="Destructor for the class.">~MutexLock</a> () { unlock(); }
<a name="l00386"></a>00386     <span class="keyword">public</span>: <span class="keywordtype">void</span> unlock ();
<a name="l00387"></a>00387   };
<a name="l00388"></a>00388 
<a name="l00393"></a>00393 <span class="preprocessor">#define SYNCHRONIZED(obj) \</span>
<a name="l00394"></a>00394 <span class="preprocessor">  MutexLock MutexLock_HOLD_LOCK(obj); // This relies on C++ deleting the obj at end of function</span>
<a name="l00395"></a>00395 <span class="preprocessor"></span>
<a name="l00401"></a>00401 <span class="preprocessor">#define START_SYNCHRONIZED(n,obj) \</span>
<a name="l00402"></a>00402 <span class="preprocessor">  MutexLock MutexLock_TEMP_LOCK_ ## n (obj); \</span>
<a name="l00403"></a>00403 <span class="preprocessor">  try {</span>
<a name="l00404"></a>00404 <span class="preprocessor"></span>
<a name="l00410"></a>00410 <span class="preprocessor">#define END_SYNCHRONIZED(n) \</span>
<a name="l00411"></a>00411 <span class="preprocessor">    MutexLock_TEMP_LOCK_ ## n .unlock(); \</span>
<a name="l00412"></a>00412 <span class="preprocessor">  } catch (VRTException e) { \</span>
<a name="l00413"></a>00413 <span class="preprocessor">    MutexLock_TEMP_LOCK_ ## n .unlock(); \</span>
<a name="l00414"></a>00414 <span class="preprocessor">    throw e; \</span>
<a name="l00415"></a>00415 <span class="preprocessor">  } catch (exception e) { \</span>
<a name="l00416"></a>00416 <span class="preprocessor">    MutexLock_TEMP_LOCK_ ## n .unlock(); \</span>
<a name="l00417"></a>00417 <span class="preprocessor">    throw e; \</span>
<a name="l00418"></a>00418 <span class="preprocessor">  }</span>
<a name="l00419"></a>00419 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00420"></a>00420 <span class="preprocessor"></span>
<a name="l00422"></a>00422   <span class="comment">// VRTException</span>
<a name="l00424"></a>00424 <span class="comment"></span><span class="preprocessor">#if NOT_USING_JNI</span>
<a name="l00425"></a>00425 <span class="preprocessor"></span>
<a name="l00428"></a><a class="code" href="classvrt_1_1__Exception.html">00428</a>   <span class="keyword">class </span><a class="code" href="classvrt_1_1__Exception.html" title="Internal Use Only: Minimal wrapper of std::exception that is used to avoid &amp;quot;virtual...">_Exception</a> : <span class="keyword">public</span> exception {
<a name="l00429"></a>00429     <span class="keyword">public</span>: <a class="code" href="classvrt_1_1__Exception.html" title="Internal Use Only: Minimal wrapper of std::exception that is used to avoid &amp;quot;virtual...">_Exception</a> () <span class="keywordflow">throw</span>() : exception() { }
<a name="l00430"></a>00430     <span class="keyword">public</span>: ~<a class="code" href="classvrt_1_1__Exception.html" title="Internal Use Only: Minimal wrapper of std::exception that is used to avoid &amp;quot;virtual...">_Exception</a> () <span class="keywordflow">throw</span>() { }
<a name="l00431"></a>00431   };
<a name="l00432"></a>00432 
<a name="l00436"></a><a class="code" href="classvrt_1_1__BadCast.html">00436</a>   <span class="keyword">class </span><a class="code" href="classvrt_1_1__BadCast.html" title="Internal Use Only: Minimal wrapper of std::bad_cast that is used to avoid &amp;quot;virtual...">_BadCast</a> : <span class="keyword">public</span> bad_cast {
<a name="l00437"></a>00437     <span class="keyword">public</span>: <a class="code" href="classvrt_1_1__BadCast.html" title="Internal Use Only: Minimal wrapper of std::bad_cast that is used to avoid &amp;quot;virtual...">_BadCast</a> () <span class="keywordflow">throw</span>() : bad_cast() { }
<a name="l00438"></a>00438     <span class="keyword">public</span>: ~<a class="code" href="classvrt_1_1__BadCast.html" title="Internal Use Only: Minimal wrapper of std::bad_cast that is used to avoid &amp;quot;virtual...">_BadCast</a> () <span class="keywordflow">throw</span>() { }
<a name="l00439"></a>00439   };
<a name="l00440"></a>00440 
<a name="l00444"></a>00444 <span class="preprocessor">  #define VRTEXCEPTION(args) \</span>
<a name="l00445"></a>00445 <span class="preprocessor">    _GCC_Pragma(&quot;GCC warning \&quot;Use of VRTEXCEPTION((..)) is deprecated\&quot;&quot;) \</span>
<a name="l00446"></a>00446 <span class="preprocessor">    _Intel_Pragma(&quot;message \&quot;Use of VRTEXCEPTION((..)) is deprecated\&quot;&quot;) \</span>
<a name="l00447"></a>00447 <span class="preprocessor">    VRTException args</span>
<a name="l00448"></a>00448 <span class="preprocessor"></span>
<a name="l00453"></a>00453 <span class="preprocessor">  #define ERRNO_STR vrt::VRTException::getErrorMsgFor(errno).c_str()</span>
<a name="l00454"></a>00454 <span class="preprocessor"></span>
<a name="l00459"></a><a class="code" href="classvrt_1_1VRTException.html">00459</a>   <span class="keyword">class </span><a class="code" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a> : <span class="keyword">public</span> <a class="code" href="classvrt_1_1VRTObject.html" title="A basic root-level object definition.">VRTObject</a>, <span class="keyword">public</span> <span class="keyword">virtual</span> <a class="code" href="classvrt_1_1__Exception.html" title="Internal Use Only: Minimal wrapper of std::exception that is used to avoid &amp;quot;virtual...">_Exception</a> {
<a name="l00460"></a>00460     <span class="keyword">protected</span>: <span class="keywordtype">string</span>         message;     <span class="comment">// The error message</span>
<a name="l00461"></a>00461     <span class="keyword">protected</span>: <span class="keywordtype">string</span>         description; <span class="comment">// Description of error with class name and message</span>
<a name="l00462"></a>00462     <span class="keyword">protected</span>: vector&lt;string&gt; backtrace;   <span class="comment">// The back-trace (if available)</span>
<a name="l00463"></a>00463 
<a name="l00465"></a>00465     <span class="keyword">public</span>: <a class="code" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a> () <span class="keywordflow">throw</span>();
<a name="l00466"></a>00466 
<a name="l00468"></a>00468     <span class="keyword">public</span>: <a class="code" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a> (<span class="keyword">const</span> <a class="code" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a> &amp;e) <span class="keywordflow">throw</span>();
<a name="l00469"></a>00469 
<a name="l00471"></a>00471     <span class="keyword">public</span>: <a class="code" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a> (<span class="keywordtype">string</span> msg) <span class="keywordflow">throw</span>();
<a name="l00472"></a>00472 
<a name="l00474"></a>00474     _Intel_Pragma(<span class="stringliteral">&quot;__printf_args&quot;</span>)
<a name="l00475"></a>00475     <span class="keyword">public</span>: <a class="code" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...) <span class="keywordflow">throw</span>();
<a name="l00476"></a>00476     <span class="comment">// Tried adding __attribute__((format(printf,2,3))) to the above line to enable</span>
<a name="l00477"></a>00477     <span class="comment">// additional complier checks, but GCC 4.4.5 didn&apos;t appear to handle it properly.</span>
<a name="l00478"></a>00478     <span class="comment">// Suspect this may be related to GCC bug 47634 (&quot;Incorrect checking of attribute</span>
<a name="l00479"></a>00479     <span class="comment">// format printf on constructor of derived class with virtual base&quot;) which was</span>
<a name="l00480"></a>00480     <span class="comment">// still open against GCC 4.4.5 as of July 2013 (and also affects GCC 4.4.6).</span>
<a name="l00481"></a>00481     <span class="comment">// Also could be an issue with the use of &quot;throw()&quot;. Suggest revisiting in a</span>
<a name="l00482"></a>00482     <span class="comment">// later GCC with possible #if block to disable check on buggy versions.</span>
<a name="l00483"></a>00483 
<a name="l00485"></a>00485     <span class="keyword">public</span>: <a class="code" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a> (<span class="keywordtype">int</span> errnum) <span class="keywordflow">throw</span>();
<a name="l00486"></a>00486 
<a name="l00488"></a><a class="code" href="classvrt_1_1VRTException.html#a0fd7ec700ff665c6ab810e62abf22fb7">00488</a>     <span class="keyword">public</span>: <a class="code" href="classvrt_1_1VRTException.html#a0fd7ec700ff665c6ab810e62abf22fb7" title="Basic destructor for the class.">~VRTException</a> () throw() { }
<a name="l00489"></a>00489 
<a name="l00493"></a>00493     <span class="keyword">public</span>: <span class="keyword">static</span> <span class="keywordtype">string</span> getErrorMsgFor (<span class="keywordtype">int</span> errnum) <span class="keywordflow">throw</span>();
<a name="l00494"></a>00494 
<a name="l00496"></a><a class="code" href="classvrt_1_1VRTException.html#a09a66e2157d2202b41c88cb24219f853">00496</a>     <span class="keyword">public</span>: <span class="keyword">inline</span> <span class="keywordtype">string</span> <a class="code" href="classvrt_1_1VRTException.html#a09a66e2157d2202b41c88cb24219f853" title="Gets the user-defined error message.">getMessage</a> ()<span class="keyword"> const </span>{
<a name="l00497"></a>00497       <span class="keywordflow">return</span> message;
<a name="l00498"></a>00498     }
<a name="l00499"></a>00499 
<a name="l00500"></a><a class="code" href="classvrt_1_1VRTException.html#a15890299da6ae65e3adf40890307eca6">00500</a>     <span class="keyword">public</span>: <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keywordtype">string</span> <a class="code" href="classvrt_1_1VRTException.html#a15890299da6ae65e3adf40890307eca6" title="Converts this class its string form.">toString</a> ()<span class="keyword"> const </span>{
<a name="l00501"></a>00501       <span class="keywordflow">return</span> (isNullValue())? <span class="stringliteral">&quot;&lt;null&gt;&quot;</span> : description;
<a name="l00502"></a>00502     }
<a name="l00503"></a>00503 
<a name="l00508"></a>00508     <span class="keyword">public</span>: <span class="keyword">virtual</span> <span class="keywordtype">bool</span> equals (<span class="keyword">const</span> <a class="code" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a> &amp;o) <span class="keyword">const</span>;
<a name="l00509"></a>00509 
<a name="l00510"></a>00510     <span class="keyword">using</span> VRTObject::equals;
<a name="l00511"></a>00511     <span class="keyword">public</span>: <span class="keyword">virtual</span> <span class="keywordtype">bool</span> equals (<span class="keyword">const</span> <a class="code" href="classvrt_1_1VRTObject.html" title="A basic root-level object definition.">VRTObject</a> &amp;o) <span class="keyword">const</span>;
<a name="l00512"></a>00512 
<a name="l00514"></a><a class="code" href="classvrt_1_1VRTException.html#a077ad56acae915471c77100803a01822">00514</a>     <span class="keyword">public</span>: <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classvrt_1_1VRTException.html#a077ad56acae915471c77100803a01822" title="Is this object equal to null.">isNullValue</a> ()<span class="keyword"> const </span>{
<a name="l00515"></a>00515       <span class="keywordflow">return</span> (description == <span class="stringliteral">&quot;&quot;</span>);
<a name="l00516"></a>00516     }
<a name="l00517"></a>00517 
<a name="l00519"></a><a class="code" href="classvrt_1_1VRTException.html#a372ee04479d8d7bb948c5beb76917801">00519</a>     <span class="keyword">public</span>: <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classvrt_1_1VRTException.html#a372ee04479d8d7bb948c5beb76917801" title="This is identical to calling toString().c_str().">what</a> () <span class="keyword">const</span> throw() {
<a name="l00520"></a>00520       <span class="keywordflow">return</span> toString().c_str();
<a name="l00521"></a>00521     }
<a name="l00522"></a>00522 
<a name="l00527"></a>00527     <span class="keyword">public</span>: <span class="keywordtype">void</span> printStackTrace (ostream &amp;out=std::cerr) <span class="keyword">const</span>;
<a name="l00528"></a>00528 
<a name="l00533"></a><a class="code" href="classvrt_1_1VRTException.html#ac092b7e1c9bbccf96ba8a0bf47b602b7">00533</a>     <span class="keyword">public</span>: vector&lt;string&gt; <a class="code" href="classvrt_1_1VRTException.html#ac092b7e1c9bbccf96ba8a0bf47b602b7" title="Gets the &amp;quot;back trace&amp;quot; (also called the &amp;quot;stack trace&amp;quot;).">getStackTrace</a> ()<span class="keyword"> const </span>{
<a name="l00534"></a>00534       <span class="keywordflow">return</span> backtrace;
<a name="l00535"></a>00535     }
<a name="l00536"></a>00536   };
<a name="l00537"></a>00537 
<a name="l00538"></a>00538 <span class="preprocessor">#else</span>
<a name="l00539"></a>00539 <span class="preprocessor"></span>
<a name="l00540"></a>00540   <span class="keyword">class </span>VRTException : <span class="keyword">public</span> <span class="keyword">virtual</span> exception {
<a name="l00541"></a>00541     <span class="keyword">protected</span>: <span class="keywordtype">string</span> message; <span class="comment">// The error message</span>
<a name="l00542"></a>00542 
<a name="l00544"></a>00544     <span class="keyword">public</span>: VRTException (<span class="keywordtype">string</span> msg) <span class="keywordflow">throw</span>() : message(msg) { }
<a name="l00545"></a>00545 
<a name="l00547"></a>00547     <span class="keyword">public</span>: ~VRTException () throw() { }
<a name="l00548"></a>00548 
<a name="l00550"></a>00550     <span class="keyword">public</span>: <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* what () <span class="keyword">const</span> throw() {
<a name="l00551"></a>00551       <span class="keywordflow">return</span> message.c_str();
<a name="l00552"></a>00552     }
<a name="l00553"></a>00553   };
<a name="l00554"></a>00554 <span class="preprocessor">#endif </span><span class="comment">/* NOT_USING_JNI */</span>
<a name="l00555"></a>00555 
<a name="l00556"></a>00556 <span class="preprocessor">#if NOT_USING_JNI</span>
<a name="l00557"></a>00557 <span class="preprocessor"></span>
<a name="l00558"></a><a class="code" href="classvrt_1_1ClassCastException.html">00558</a>   <span class="keyword">class </span><a class="code" href="classvrt_1_1ClassCastException.html" title="The exception thrown when a checked_dynamic_cast fails.">ClassCastException</a> : <span class="keyword">public</span> <a class="code" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a>, <span class="keyword">public</span> <span class="keyword">virtual</span> <a class="code" href="classvrt_1_1__BadCast.html" title="Internal Use Only: Minimal wrapper of std::bad_cast that is used to avoid &amp;quot;virtual...">_BadCast</a> {
<a name="l00560"></a>00560     <span class="keyword">public</span>: <a class="code" href="classvrt_1_1ClassCastException.html" title="The exception thrown when a checked_dynamic_cast fails.">ClassCastException</a> () <span class="keywordflow">throw</span>();
<a name="l00561"></a>00561 
<a name="l00563"></a>00563     <span class="keyword">public</span>: <a class="code" href="classvrt_1_1ClassCastException.html" title="The exception thrown when a checked_dynamic_cast fails.">ClassCastException</a> (<span class="keyword">const</span> <a class="code" href="classvrt_1_1ClassCastException.html" title="The exception thrown when a checked_dynamic_cast fails.">ClassCastException</a> &amp;e) <span class="keywordflow">throw</span>();
<a name="l00564"></a>00564 
<a name="l00566"></a>00566     <span class="keyword">public</span>: <a class="code" href="classvrt_1_1ClassCastException.html" title="The exception thrown when a checked_dynamic_cast fails.">ClassCastException</a> (<span class="keywordtype">string</span> msg) <span class="keywordflow">throw</span>();
<a name="l00567"></a>00567 
<a name="l00569"></a><a class="code" href="classvrt_1_1ClassCastException.html#a88141d30e098462adf45b4241e4ec81f">00569</a>     <span class="keyword">public</span>: <a class="code" href="classvrt_1_1ClassCastException.html#a88141d30e098462adf45b4241e4ec81f" title="Basic destructor for the class.">~ClassCastException</a> () throw() { }
<a name="l00570"></a>00570   };
<a name="l00571"></a>00571 <span class="preprocessor">#endif</span>
<a name="l00572"></a>00572 <span class="preprocessor"></span>
<a name="l00574"></a>00574   <span class="comment">// Type casting methods</span>
<a name="l00576"></a>00576 <span class="comment"></span><span class="preprocessor">#if NOT_USING_JNI</span>
<a name="l00577"></a>00577 <span class="preprocessor"></span>
<a name="l00583"></a>00583   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> C&gt;
<a name="l00584"></a>00584   T&amp; checked_dynamic_cast (C&amp; ref) {
<a name="l00585"></a>00585     <span class="comment">// No reason to check anything, this should not return null</span>
<a name="l00586"></a>00586     <span class="keywordflow">try</span> {
<a name="l00587"></a>00587       <span class="keywordflow">return</span> <span class="keyword">dynamic_cast&lt;</span>T&amp;<span class="keyword">&gt;</span>(ref);
<a name="l00588"></a>00588     }
<a name="l00589"></a>00589     <span class="keywordflow">catch</span> (bad_cast e) {
<a name="l00590"></a>00590       UNUSED_VARIABLE(e);
<a name="l00591"></a>00591       <span class="keyword">const</span> <span class="keywordtype">char</span>* srcName  = <span class="keyword">typeid</span>(C&amp;).name();
<a name="l00592"></a>00592       <span class="keyword">const</span> <span class="keywordtype">char</span>* destName = <span class="keyword">typeid</span>(T&amp;).name();
<a name="l00593"></a>00593       <span class="keywordtype">string</span> msg  = VRTObject_private::getClassName(srcName)+<span class="stringliteral">&quot; can not be cast to &quot;</span>
<a name="l00594"></a>00594                   + VRTObject_private::getClassName(destName);
<a name="l00595"></a>00595 
<a name="l00596"></a>00596       <span class="keywordflow">throw</span> ClassCastException(msg);
<a name="l00597"></a>00597     }
<a name="l00598"></a>00598   }
<a name="l00605"></a>00605   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> C&gt;
<a name="l00606"></a>00606   T checked_dynamic_cast (C* ptr) {
<a name="l00607"></a>00607     <span class="keywordflow">if</span> (ptr == NULL) <span class="keywordflow">return</span> (T)NULL;
<a name="l00608"></a>00608     T p = NULL;
<a name="l00609"></a>00609     <span class="keywordflow">try</span> {
<a name="l00610"></a>00610       p = <span class="keyword">dynamic_cast&lt;</span>T<span class="keyword">&gt;</span>(ptr);
<a name="l00611"></a>00611     }
<a name="l00612"></a>00612     <span class="keywordflow">catch</span> (bad_cast e) {
<a name="l00613"></a>00613       UNUSED_VARIABLE(e);
<a name="l00614"></a>00614       p = NULL;
<a name="l00615"></a>00615     }
<a name="l00616"></a>00616 
<a name="l00617"></a>00617     <span class="keywordflow">if</span> (p == NULL) {
<a name="l00618"></a>00618       <span class="keyword">const</span> <span class="keywordtype">char</span>* srcName  = <span class="keyword">typeid</span>(C*).name();
<a name="l00619"></a>00619       <span class="keyword">const</span> <span class="keywordtype">char</span>* destName = <span class="keyword">typeid</span>(T).name();
<a name="l00620"></a>00620       <span class="keywordtype">string</span> msg  = VRTObject_private::getClassName(srcName)+<span class="stringliteral">&quot; can not be cast to &quot;</span>
<a name="l00621"></a>00621                   + VRTObject_private::getClassName(destName);
<a name="l00622"></a>00622 
<a name="l00623"></a>00623       <span class="keywordflow">throw</span> ClassCastException(msg);
<a name="l00624"></a>00624     }
<a name="l00625"></a>00625     <span class="keywordflow">return</span> p;
<a name="l00626"></a>00626   }
<a name="l00627"></a>00627 <span class="preprocessor">#endif</span>
<a name="l00628"></a>00628 <span class="preprocessor"></span>
<a name="l00630"></a>00630   <span class="comment">// The safe_delete function</span>
<a name="l00632"></a>00632 <span class="comment"></span>
<a name="l00633"></a>00633   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00634"></a>00634   <span class="keywordtype">void</span> safe_delete (T*&amp; ptr) {
<a name="l00635"></a>00635     <span class="keywordflow">if</span> (ptr != NULL) {
<a name="l00636"></a>00636       <span class="keyword">delete</span> ptr;
<a name="l00637"></a>00637       ptr = NULL;
<a name="l00638"></a>00638     }
<a name="l00639"></a>00639   }
<a name="l00640"></a>00640 
<a name="l00642"></a>00642   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00643"></a>00643   <span class="keywordtype">void</span> safe_free (T*&amp; ptr) {
<a name="l00644"></a>00644     <span class="keywordflow">if</span> (ptr != NULL) {
<a name="l00645"></a>00645       ::free(ptr);
<a name="l00646"></a>00646       ptr = NULL;
<a name="l00647"></a>00647     }
<a name="l00648"></a>00648   }
<a name="l00649"></a>00649 
<a name="l00651"></a>00651   <span class="comment">// The isNull(..) Methods</span>
<a name="l00653"></a>00653 <span class="comment"></span>
<a name="l00654"></a>00654   <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNull (boolNull         val) { <span class="keywordflow">return</span> (val == _NULL     ); }
<a name="l00656"></a>00656   <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNull (int8_t           val) { <span class="keywordflow">return</span> (val == INT8_NULL ); }
<a name="l00658"></a>00658   <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNull (int16_t          val) { <span class="keywordflow">return</span> (val == INT16_NULL); }
<a name="l00660"></a>00660   <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNull (int32_t          val) { <span class="keywordflow">return</span> (val == INT32_NULL); }
<a name="l00662"></a>00662   <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNull (int64_t          val) { <span class="keywordflow">return</span> (val == INT64_NULL); }
<a name="l00667"></a>00667   <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNull (<span class="keywordtype">float</span>            val) { <span class="keywordflow">return</span> isnan(val); }
<a name="l00672"></a>00672   <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNull (<span class="keywordtype">double</span>           val) { <span class="keywordflow">return</span> isnan(val); }
<a name="l00673"></a>00673 
<a name="l00674"></a>00674 <span class="preprocessor">#if NOT_USING_JNI</span>
<a name="l00675"></a>00675 <span class="preprocessor"></span>
<a name="l00678"></a>00678   <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNull (<span class="keyword">const</span> VRTObject &amp;val) { <span class="keywordflow">return</span> val.isNullValue(); }
<a name="l00679"></a>00679 <span class="preprocessor">#endif</span>
<a name="l00680"></a>00680 <span class="preprocessor"></span>
<a name="l00683"></a>00683   <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNull (<span class="keyword">const</span> <span class="keywordtype">string</span>    &amp;val) { <span class="keywordflow">return</span> val.empty(); }
<a name="l00687"></a>00687   <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNull (<span class="keyword">const</span> wstring   &amp;val) { <span class="keywordflow">return</span> val.empty(); }
<a name="l00688"></a>00688 
<a name="l00690"></a>00690   <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNull (uint8_t          val) { UNUSED_VARIABLE(val); <span class="keywordflow">return</span> <span class="keyword">false</span>; }
<a name="l00692"></a>00692   <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNull (uint16_t         val) { UNUSED_VARIABLE(val); <span class="keywordflow">return</span> <span class="keyword">false</span>; }
<a name="l00694"></a>00694   <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNull (uint32_t         val) { UNUSED_VARIABLE(val); <span class="keywordflow">return</span> <span class="keyword">false</span>; }
<a name="l00696"></a>00696   <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNull (uint64_t         val) { UNUSED_VARIABLE(val); <span class="keywordflow">return</span> <span class="keyword">false</span>; }
<a name="l00697"></a>00697 
<a name="l00698"></a>00698 <span class="preprocessor">#if (defined(__APPLE__) &amp;&amp; defined(__MACH__))</span>
<a name="l00699"></a>00699 <span class="preprocessor"></span>  <span class="comment">// Under OS X the definition of &apos;size_t&apos; differs slightly from &apos;uint64_t&apos; so</span>
<a name="l00700"></a>00700   <span class="comment">// we need to include this to avoid issues when an isNull(..) check is done</span>
<a name="l00701"></a>00701   <span class="comment">// on a &apos;size_t&apos;, as may occur when a template is used (this is particularly</span>
<a name="l00702"></a>00702   <span class="comment">// true for the test cases).</span>
<a name="l00703"></a>00703 
<a name="l00705"></a>00705   <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNull (<span class="keywordtype">size_t</span>           val) { UNUSED_VARIABLE(val); <span class="keywordflow">return</span> <span class="keyword">false</span>; }
<a name="l00706"></a>00706 <span class="preprocessor">#endif</span>
<a name="l00707"></a>00707 <span class="preprocessor"></span>
<a name="l00709"></a>00709   <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNull (<span class="keywordtype">void</span>            *val) { <span class="keywordflow">return</span> (val == NULL); }
<a name="l00713"></a>00713   <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNull (<span class="keyword">const</span> <span class="keywordtype">string</span>    *val) { <span class="keywordflow">return</span> (val == NULL) || val-&gt;empty(); }
<a name="l00717"></a>00717   <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNull (<span class="keyword">const</span> wstring   *val) { <span class="keywordflow">return</span> (val == NULL) || val-&gt;empty(); }
<a name="l00718"></a>00718 <span class="preprocessor">#if NOT_USING_JNI</span>
<a name="l00719"></a>00719 <span class="preprocessor"></span>
<a name="l00722"></a>00722   <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNull (<span class="keyword">const</span> VRTObject *val) { <span class="keywordflow">return</span> (val == NULL) || val-&gt;isNullValue(); }
<a name="l00723"></a>00723 <span class="preprocessor">#endif</span>
<a name="l00724"></a>00724 <span class="preprocessor"></span>} END_NAMESPACE
<a name="l00725"></a>00725 
<a name="l00726"></a>00726 
<a name="l00727"></a>00727 <span class="preprocessor">#if NOT_USING_JNI</span>
<a name="l00728"></a>00728 <span class="preprocessor"></span>
<a name="l00729"></a>00729 <span class="keyword">inline</span> ostream&amp; operator&lt;&lt; (ostream &amp;s, <span class="keyword">const</span> <a class="code" href="classvrt_1_1VRTObject.html" title="A basic root-level object definition.">vrt::VRTObject</a> &amp;o) { <span class="keywordflow">return</span> s &lt;&lt; o.<a class="code" href="classvrt_1_1VRTObject.html#a8a8ca4be5d2b9075b6478685c2e121a1" title="Converts this class its string form.">toString</a>(); }
<a name="l00730"></a>00730 
<a name="l00732"></a>00732 <span class="keyword">inline</span> <span class="keywordtype">string</span>   operator+  (<span class="keywordtype">string</span>  &amp;s, <span class="keyword">const</span> <a class="code" href="classvrt_1_1VRTObject.html" title="A basic root-level object definition.">vrt::VRTObject</a> &amp;o) { <span class="keywordflow">return</span> s +  o.<a class="code" href="classvrt_1_1VRTObject.html#a8a8ca4be5d2b9075b6478685c2e121a1" title="Converts this class its string form.">toString</a>(); }
<a name="l00733"></a>00733 
<a name="l00735"></a>00735 <span class="keyword">inline</span> ostream&amp; operator&lt;&lt; (ostream &amp;s, <span class="keyword">const</span> <a class="code" href="classvrt_1_1VRTObject.html" title="A basic root-level object definition.">vrt::VRTObject</a> *o) { <span class="keywordflow">return</span> s &lt;&lt; ((o == NULL)? <span class="stringliteral">&quot;NULL&quot;</span> : o-&gt;toString()); }
<a name="l00736"></a>00736 
<a name="l00738"></a>00738 <span class="keyword">inline</span> <span class="keywordtype">string</span>   operator+  (<span class="keywordtype">string</span>  &amp;s, <span class="keyword">const</span> <a class="code" href="classvrt_1_1VRTObject.html" title="A basic root-level object definition.">vrt::VRTObject</a> *o) { <span class="keywordflow">return</span> s +  ((o == NULL)? <span class="stringliteral">&quot;NULL&quot;</span> : o-&gt;toString()); }
<a name="l00739"></a>00739 
<a name="l00741"></a>00741 <span class="comment">//inline bool    operator==  (const vrt::VRTObject *a, const vrt::VRTObject *b) {</span>
<a name="l00742"></a>00742 <span class="comment">//  return vrt::VRTObject::equal(a,b);</span>
<a name="l00743"></a>00743 <span class="comment">//}</span>
<a name="l00744"></a>00744 <span class="comment">//</span>
<a name="l00746"></a>00746 <span class="comment"></span><span class="comment">//inline bool    operator==  (const vrt::VRTObject &amp;a, const vrt::VRTObject &amp;b) {</span>
<a name="l00747"></a>00747 <span class="comment">//  return vrt::VRTObject::equal(a,b);</span>
<a name="l00748"></a>00748 <span class="comment">//}</span>
<a name="l00750"></a>00750 <span class="comment"></span><span class="comment">//inline bool    operator!=  (const vrt::VRTObject *a, const vrt::VRTObject *b) {</span>
<a name="l00751"></a>00751 <span class="comment">//  return !vrt::VRTObject::equal(a,b);</span>
<a name="l00752"></a>00752 <span class="comment">//}</span>
<a name="l00753"></a>00753 <span class="comment">//</span>
<a name="l00755"></a>00755 <span class="comment"></span><span class="comment">//inline bool    operator!=  (const vrt::VRTObject &amp;a, const vrt::VRTObject &amp;b) {</span>
<a name="l00756"></a>00756 <span class="comment">//  return !vrt::VRTObject::equal(a,b);</span>
<a name="l00757"></a>00757 <span class="comment">//}</span>
<a name="l00758"></a>00758 
<a name="l00759"></a>00759 <span class="preprocessor">#endif</span>
<a name="l00760"></a>00760 <span class="preprocessor"></span>
<a name="l00762"></a>00762 <span class="keyword">inline</span> <span class="keywordtype">string</span>   operator+ (<span class="keywordtype">string</span>  &amp;s, vrt::boolNull val) {
<a name="l00763"></a>00763   <span class="keywordflow">if</span> (val == 0) <span class="keywordflow">return</span> s + <span class="stringliteral">&quot;_NULL&quot;</span>;
<a name="l00764"></a>00764   <span class="keywordflow">if</span> (val &gt;  0) <span class="keywordflow">return</span> s + <span class="stringliteral">&quot;_TRUE&quot;</span>;
<a name="l00765"></a>00765   <span class="keywordflow">else</span>          <span class="keywordflow">return</span> s + <span class="stringliteral">&quot;_FALSE&quot;</span>;
<a name="l00766"></a>00766 }
<a name="l00767"></a>00767 
<a name="l00769"></a>00769 <span class="keyword">inline</span> ostream&amp; operator&lt;&lt;(ostream &amp;s, vrt::boolNull val) {
<a name="l00770"></a>00770   <span class="keywordflow">if</span> (val == 0) <span class="keywordflow">return</span> s &lt;&lt; <span class="stringliteral">&quot;_NULL&quot;</span>;
<a name="l00771"></a>00771   <span class="keywordflow">if</span> (val &gt;  0) <span class="keywordflow">return</span> s &lt;&lt; <span class="stringliteral">&quot;_TRUE&quot;</span>;
<a name="l00772"></a>00772   <span class="keywordflow">else</span>          <span class="keywordflow">return</span> s &lt;&lt; <span class="stringliteral">&quot;_FALSE&quot;</span>;
<a name="l00773"></a>00773 }
<a name="l00774"></a>00774 
<a name="l00778"></a>00778 <span class="keyword">inline</span> ostream&amp; operator&lt;&lt;(ostream &amp;s, <span class="keyword">const</span> wstring &amp;val) {
<a name="l00779"></a>00779   <span class="keywordtype">string</span> questionMark = <span class="stringliteral">&quot;?&quot;</span>;
<a name="l00780"></a>00780   <span class="keywordtype">string</span> asciiChar    = <span class="stringliteral">&quot;_&quot;</span>;
<a name="l00781"></a>00781 
<a name="l00782"></a>00782   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; val.length(); i++) {
<a name="l00783"></a>00783     <span class="keywordflow">if</span> ((val[i] &gt;= 0x00) &amp;&amp; (val[i] &lt;= 0x7F)) {
<a name="l00784"></a>00784       asciiChar[0] = (char)val[i];
<a name="l00785"></a>00785       s &lt;&lt; asciiChar;
<a name="l00786"></a>00786     }
<a name="l00787"></a>00787     <span class="keywordflow">else</span> {
<a name="l00788"></a>00788       s &lt;&lt; questionMark;
<a name="l00789"></a>00789     }
<a name="l00790"></a>00790   }
<a name="l00791"></a>00791   <span class="keywordflow">return</span> s;
<a name="l00792"></a>00792 }
<a name="l00793"></a>00793 <span class="preprocessor">#endif </span><span class="comment">/* _VRTObject_h */</span>
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 29 Jun 2018 for VRT by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>

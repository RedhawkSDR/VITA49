<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VRT: vrt::BasicDataPacket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>vrt</b>::<a class="el" href="classvrt_1_1BasicDataPacket.html">BasicDataPacket</a>
  </div>
</div>
<div class="contents">
<h1>vrt::BasicDataPacket Class Reference</h1><!-- doxytag: class="vrt::BasicDataPacket" --><!-- doxytag: inherits="vrt::BasicVRTPacket" -->
<p>An basic but full-featured implementation of a VRT IF Data packet.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BasicDataPacket_8h_source.html">BasicDataPacket.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vrt::BasicDataPacket:</div>
<div class="dynsection">
 <div class="center">
  <img src="classvrt_1_1BasicDataPacket.gif" usemap="#vrt::BasicDataPacket_map" alt=""/>
  <map id="vrt::BasicDataPacket_map" name="vrt::BasicDataPacket_map">
<area href="classvrt_1_1BasicVRTPacket.html" alt="vrt::BasicVRTPacket" shape="rect" coords="79,56,227,80"/>
<area href="classvrt_1_1VRTObject.html" alt="vrt::VRTObject" shape="rect" coords="0,0,148,24"/>
<area href="classvrt_1_1HasFields.html" alt="vrt::HasFields" shape="rect" coords="158,0,306,24"/>
<area href="classvrt_1_1NoDataPacket.html" alt="vrt::NoDataPacket" shape="rect" coords="0,168,148,192"/>
<area href="classvrt_1_1StandardDataPacket.html" alt="vrt::StandardDataPacket" shape="rect" coords="158,168,306,192"/>
</map>
 </div>
</div>

<p><a href="classvrt_1_1BasicDataPacket-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ada678044c661a9305ac232a7d7028c52">BasicDataPacket</a> (vector&lt; char &gt; *buf, bool <a class="el" href="classvrt_1_1BasicVRTPacket.html#a40626801621f637d0be9da791c68e788">readOnly</a>=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new instance accessing the given data buffer pointer.  <a href="#ada678044c661a9305ac232a7d7028c52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ad6dfec6d06acf005c6b67676d871497a">BasicDataPacket</a> (const vector&lt; char &gt; &amp;buf, bool <a class="el" href="classvrt_1_1BasicVRTPacket.html#a40626801621f637d0be9da791c68e788">readOnly</a>=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new instance accessing the given data buffer.  <a href="#ad6dfec6d06acf005c6b67676d871497a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a164f96f2307a10b9f501167a7ffdb1ef"></a><!-- doxytag: member="vrt::BasicDataPacket::BasicDataPacket" ref="a164f96f2307a10b9f501167a7ffdb1ef" args="(const vector&lt; char &gt; &amp;buf, ssize_t start, ssize_t end, bool readOnly=false)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>BasicDataPacket</b> (const vector&lt; char &gt; &amp;buf, ssize_t start, ssize_t end, bool <a class="el" href="classvrt_1_1BasicVRTPacket.html#a40626801621f637d0be9da791c68e788">readOnly</a>=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a5c69764c68a47846a481b14470085531">BasicDataPacket</a> (int32_t bufsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new instance with a default anticipated length that can be written to.  <a href="#a5c69764c68a47846a481b14470085531"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a3c1b6415ebd565ba680c281dbed195c5">BasicDataPacket</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new instance that can be written to.  <a href="#a3c1b6415ebd565ba680c281dbed195c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#aad3d70a6cb267860c62c83ceb854d2f4">BasicDataPacket</a> (const void *buf, size_t len, bool <a class="el" href="classvrt_1_1BasicVRTPacket.html#a40626801621f637d0be9da791c68e788">readOnly</a>=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new instance accessing the given data buffer.  <a href="#aad3d70a6cb267860c62c83ceb854d2f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a7e46e2f0697240c5777d826f1774e90d">BasicDataPacket</a> (const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic copy constructor for the class.  <a href="#a7e46e2f0697240c5777d826f1774e90d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a75133f6c839b9a806efdfb7a9d7d87ee">~BasicDataPacket</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic destructor for the class.  <a href="#a75133f6c839b9a806efdfb7a9d7d87ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#af77e88c7722a175fd3c6f52b2687abdd">getAssocPacketCount</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the associated packet count.  <a href="#af77e88c7722a175fd3c6f52b2687abdd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a162a35422149ca9b7c1f3fa932b3e385">getData</a> (void *array, bool convert=true) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it in a native byte buffer.  <a href="#a162a35422149ca9b7c1f3fa932b3e385"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a8c8496c1172d68c98e1f9dd0cd19bae5">getData</a> (vector&lt; char &gt; &amp;array, size_t offset, bool convert=true) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it in a native byte buffer.  <a href="#a8c8496c1172d68c98e1f9dd0cd19bae5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a93902944a0d6a0993b3f400210c44154">getData</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, void *array, bool convert=true) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it in a native byte buffer.  <a href="#a93902944a0d6a0993b3f400210c44154"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a64ce16ae976a184d88017323aab05092">getData</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, vector&lt; char &gt; &amp;array, size_t offset, bool convert=true) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it in a native byte buffer.  <a href="#a64ce16ae976a184d88017323aab05092"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83c13c8c6173c55cd2bcf7357af73ed4"></a><!-- doxytag: member="vrt::BasicDataPacket::getData_normal" ref="a83c13c8c6173c55cd2bcf7357af73ed4" args="(const PayloadFormat &amp;pf, int position)" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>getData_normal</b> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, int position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; int8_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#adede111fce7ad83c335701dedecae8c5">getDataByte</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a byte array.  <a href="#adede111fce7ad83c335701dedecae8c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int8_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ac3a994e1cef1e60e61f802f0427e832d">getDataByte</a> (int8_t *array) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a byte array.  <a href="#ac3a994e1cef1e60e61f802f0427e832d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; int8_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a79e11a2afa970f14f7ed7c8e3ec8e3cd">getDataByte</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a byte array.  <a href="#a79e11a2afa970f14f7ed7c8e3ec8e3cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int8_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a693d077665fc762c935234d53f84a69e">getDataByte</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, int8_t *array) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a byte array.  <a href="#a693d077665fc762c935234d53f84a69e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a12fbb106428337798aae0614116e2351">getDataDouble</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a double array.  <a href="#a12fbb106428337798aae0614116e2351"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a6721b53ffb68afac510df14298c70598">getDataDouble</a> (double *array) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a double array.  <a href="#a6721b53ffb68afac510df14298c70598"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#afc6144d5a7d91f62a55ba951edec096d">getDataDouble</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a double array.  <a href="#afc6144d5a7d91f62a55ba951edec096d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#afe10f97bbc350829bc85ead9183bff64">getDataDouble</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, double *array) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a double array.  <a href="#afe10f97bbc350829bc85ead9183bff64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ace70db4848697ffb8ccd341255e8bf28">getDataFloat</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a float array.  <a href="#ace70db4848697ffb8ccd341255e8bf28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a3c48d53f3bd665cfb888a622f09a7707">getDataFloat</a> (float *array) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a float array.  <a href="#a3c48d53f3bd665cfb888a622f09a7707"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a21b72098e924dd8812ff6994d7008249">getDataFloat</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a float array.  <a href="#a21b72098e924dd8812ff6994d7008249"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a4c3d55faf86a4a5e20e80f227061f365">getDataFloat</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, float *array) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a float array.  <a href="#a4c3d55faf86a4a5e20e80f227061f365"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; int32_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a242c9deb2ca0b5f1623458771526d072">getDataInt</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a int array.  <a href="#a242c9deb2ca0b5f1623458771526d072"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#adf9cc141682ad4053b864f215df100ad">getDataInt</a> (int32_t *array) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a int array.  <a href="#adf9cc141682ad4053b864f215df100ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; int32_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#aacc4d6b4519ab9fe18782f7607b35103">getDataInt</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a int array.  <a href="#aacc4d6b4519ab9fe18782f7607b35103"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a5e24bea830d60ff3ba7268ab72735452">getDataInt</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, int32_t *array) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a int array.  <a href="#a5e24bea830d60ff3ba7268ab72735452"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a97e6656985695861342887e3f1f4a68e">getDataLength</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the length of the data in number of elements.  <a href="#a97e6656985695861342887e3f1f4a68e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ade26b4b982fd93adf72f752cd93bf732">getDataLength</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the length of the data in number of elements.  <a href="#ade26b4b982fd93adf72f752cd93bf732"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; int64_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a17d0cb447c5569e44b7bbe53fb93f283">getDataLong</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a long array.  <a href="#a17d0cb447c5569e44b7bbe53fb93f283"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a428e8f3b7e1364e9db8f39695e4a1834">getDataLong</a> (int64_t *array) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a long array.  <a href="#a428e8f3b7e1364e9db8f39695e4a1834"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; int64_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ae64f111c47dcf42826cc1d34b1a3e592">getDataLong</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a long array.  <a href="#ae64f111c47dcf42826cc1d34b1a3e592"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a6692b2adf5376befe77b6269a1f53a62">getDataLong</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, int64_t *array) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a long array.  <a href="#a6692b2adf5376befe77b6269a1f53a62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; int16_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a797ed03a04a35214e37ddf4cb999927c">getDataShort</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a byte array.  <a href="#a797ed03a04a35214e37ddf4cb999927c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a02d46c77bb93170a86d32bc82277f165">getDataShort</a> (int16_t *array) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a short array.  <a href="#a02d46c77bb93170a86d32bc82277f165"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; int16_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a4fa85ce16ce304df41ad54e5cd567bd3">getDataShort</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a short array.  <a href="#a4fa85ce16ce304df41ad54e5cd567bd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a3af6e8b5486afc0c644c62ba9da04d7c">getDataShort</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, int16_t *array) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks the data and returns it as a short array.  <a href="#a3af6e8b5486afc0c644c62ba9da04d7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvrt_1_1Value.html">Value</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a8be80b0dbd51e2755cb04e37935eb1de">getField</a> (int32_t id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value of a field, based on the field's id.  <a href="#a8be80b0dbd51e2755cb04e37935eb1de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ad0c765c6f4e0807af2b42b92e9bc4526">getFieldCount</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of fields.  <a href="#ad0c765c6f4e0807af2b42b92e9bc4526"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ad22cc3fcdc17ebcbb2c95106ba448b61">getFieldName</a> (int32_t id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the name of the given field.  <a href="#ad22cc3fcdc17ebcbb2c95106ba448b61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ValueType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a8013a7abb16b51db23230578ba7b8d64">getFieldType</a> (int32_t id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the type associated with a given field.  <a href="#a8013a7abb16b51db23230578ba7b8d64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ae461791fa9aaeb9b8f54727cc0c6352f">getLostBytes</a> (const <a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> &amp;expected, double sampleRate) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the number of bytes lost between two packets.  <a href="#ae461791fa9aaeb9b8f54727cc0c6352f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a3a00dc41b79f3c5a81e4f35ed60f31e9">getLostBytes</a> (const <a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> &amp;expected, double sampleRate, const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the number of bytes lost between two packets.  <a href="#a3a00dc41b79f3c5a81e4f35ed60f31e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a2e03bafa6ecccfe96fdb72a1f5d2ac45">getLostSamples</a> (const <a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> &amp;expected, double sampleRate) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the number of samples lost between two packets.  <a href="#a2e03bafa6ecccfe96fdb72a1f5d2ac45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a736fb29c269b38a4cf505c30481c2087">getNextTimeStamp</a> (double sampleRate) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the next expected time stamp for a data packet on this stream.  <a href="#a736fb29c269b38a4cf505c30481c2087"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a93f2b1fa6bbb21ee8470cd36c98fef8b">getNextTimeStamp</a> (double sampleRate, const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the next expected time stamp for a data packet on this stream.  <a href="#a93f2b1fa6bbb21ee8470cd36c98fef8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#aeba2eca140af729e176d8c628f497cf5">getPacketValid</a> (bool strict, int32_t length) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks to see if the packet is valid.  <a href="#aeba2eca140af729e176d8c628f497cf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the assumed payload format used when interacting with the data in this packet.  <a href="#a218104e7d259c4e852254d65e304e3f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a72cb464bdcef67285e87fb208d7d267c">getScalarDataLength</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Utility method:</em> Gets the length of the data in number of scalar elements.  <a href="#a72cb464bdcef67285e87fb208d7d267c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a93844600fe4d42f517b585bed68bdd8e">getScalarDataLength</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Utility method:</em> Gets the length of the data in number of scalar elements.  <a href="#a93844600fe4d42f517b585bed68bdd8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">StartStopIndication&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a95ec9b3fc553ea59a173163d9257c432">getStartStopIndication</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the Sample Frame StartStopIndication value.  <a href="#a95ec9b3fc553ea59a173163d9257c432"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#adb5accb8fe2fe0833000d0baab62fcd9">isAutomaticGainControl</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the AGC/MGC indicator flag.  <a href="#adb5accb8fe2fe0833000d0baab62fcd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a7f9b875caf23be5c8572b2cd55612821">isBit10</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the #10 user-defined indicator flag.  <a href="#a7f9b875caf23be5c8572b2cd55612821"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a3369b55e7c3ba19c0b23a727bb7c8d9b">isBit11</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the #11 user-defined indicator flag.  <a href="#a3369b55e7c3ba19c0b23a727bb7c8d9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#aacc728fe6a81708be3350a2a4f00eee7">isBit8</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the #8 user-defined indicator flag.  <a href="#aacc728fe6a81708be3350a2a4f00eee7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a28f29544e95668bbb0b1597d9aa8c6e6">isBit9</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the #9 user-defined indicator flag.  <a href="#a28f29544e95668bbb0b1597d9aa8c6e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ac1bb6a09c023fb271fdf9079f1b6498e">isCalibratedTimeStamp</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the calibrated time indicator flag.  <a href="#ac1bb6a09c023fb271fdf9079f1b6498e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ada6fc402de5a89ed904d54547669043f">isDataValid</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the valid data indicator flag.  <a href="#ada6fc402de5a89ed904d54547669043f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a06600940399ba8b27417dea57be45f88">isDiscontinuious</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Deprecated:</b> Please change to using <code>isDiscontinuous</code>.  <a href="#a06600940399ba8b27417dea57be45f88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a1682d935b0b11f52a6e05531d89ad1d0">isDiscontinuous</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the sample loss indicator flag.  <a href="#a1682d935b0b11f52a6e05531d89ad1d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#aa79a316018f1588d99834886429c546e">isInvertedSpectrum</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the spectral inversion indicator flag.  <a href="#aa79a316018f1588d99834886429c546e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a83779d142c204e0a6d3ca50b7a4949ee">isOverRange</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the over-range indicator flag.  <a href="#a83779d142c204e0a6d3ca50b7a4949ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a6f66c6170e11e007cad9315861159dd0">isReferenceLocked</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the reference lock indicator flag.  <a href="#a6f66c6170e11e007cad9315861159dd0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a7c60bc192353abee3ece1b938a773400">isSignalDetected</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the signal detected indicator flag.  <a href="#a7c60bc192353abee3ece1b938a773400"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ae4ff7e66dc722b764586b76f20e1d06e">setAssocPacketCount</a> (int8_t v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Gets the associated packet count.  <a href="#ae4ff7e66dc722b764586b76f20e1d06e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a9eebebcbc89f8fb82409fb5ac5b55e84">setAutomaticGainControl</a> (boolNull v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Gets the AGC/MGC indicator flag.  <a href="#a9eebebcbc89f8fb82409fb5ac5b55e84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ab4e2ffbc35e531b5fbf4731552043e6f">setBit10</a> (boolNull v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Gets the #10 user-defined indicator flag.  <a href="#ab4e2ffbc35e531b5fbf4731552043e6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a847c7b5466bf637ba2f6cf4399926c5e">setBit11</a> (boolNull v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Gets the #11 user-defined indicator flag.  <a href="#a847c7b5466bf637ba2f6cf4399926c5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a6ac3348bafc67fcdd9e35de478a4f398">setBit8</a> (boolNull v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Gets the #8 user-defined indicator flag.  <a href="#a6ac3348bafc67fcdd9e35de478a4f398"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a4b04b626d662243a1570155cfd6960e1">setBit9</a> (boolNull v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Gets the #9 user-defined indicator flag.  <a href="#a4b04b626d662243a1570155cfd6960e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a41cdda58aaeb597bb43251d271becbf3">setCalibratedTimeStamp</a> (boolNull v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets the calibrated time indicator flag.  <a href="#a41cdda58aaeb597bb43251d271becbf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#aaa81b254acedf691984a7aa007a2cf8f">setData</a> (const void *array, int32_t length, bool convert=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data from a native byte buffer.  <a href="#aaa81b254acedf691984a7aa007a2cf8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a00ee035dea1ec9bdb3bccddf1be6ebf7">setData</a> (const vector&lt; char &gt; &amp;array, size_t offset, int32_t length, bool convert=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data from a native byte buffer.  <a href="#a00ee035dea1ec9bdb3bccddf1be6ebf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ab7ee9ff782f0248207e18d7af47fa4ae">setData</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, const void *array, int32_t length, bool convert=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data from a native byte buffer.  <a href="#ab7ee9ff782f0248207e18d7af47fa4ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a50b76b2105b9cf525f04bb21873f67d2">setData</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, const vector&lt; char &gt; &amp;array, size_t offset, int32_t length, bool convert=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data from a native byte buffer.  <a href="#a50b76b2105b9cf525f04bb21873f67d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ae8648406e9de7584268ed4cbb4e418c5">setDataByte</a> (const vector&lt; int8_t &gt; &amp;array)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a byte array.  <a href="#ae8648406e9de7584268ed4cbb4e418c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a34e1e6c3b2c9449f449bc14e8eeb7a3c">setDataByte</a> (const int8_t *array, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a byte array.  <a href="#a34e1e6c3b2c9449f449bc14e8eeb7a3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ab1576f73cf98cf705003250a756e76d5">setDataByte</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, const vector&lt; int8_t &gt; &amp;array)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a byte array.  <a href="#ab1576f73cf98cf705003250a756e76d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a41106ff8e3e3503ccbbe4881bcac2b7f">setDataByte</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, const int8_t *array, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a byte array.  <a href="#a41106ff8e3e3503ccbbe4881bcac2b7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a27001cc502eae809f9945721cb84c3c5">setDataDouble</a> (const vector&lt; double &gt; &amp;array)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a double array.  <a href="#a27001cc502eae809f9945721cb84c3c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a265b1f06283c8f327b99394cb9cff470">setDataDouble</a> (const double *array, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a double array.  <a href="#a265b1f06283c8f327b99394cb9cff470"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a46f23a25acca5a486aef41c49b035ed8">setDataDouble</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, const vector&lt; double &gt; &amp;array)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a double array.  <a href="#a46f23a25acca5a486aef41c49b035ed8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a37597b467a770f011f2e57715773b080">setDataDouble</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, const double *array, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a double array.  <a href="#a37597b467a770f011f2e57715773b080"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a9b8c714eb8400c9885218ff9707fdf77">setDataFloat</a> (const vector&lt; float &gt; &amp;array)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a float array.  <a href="#a9b8c714eb8400c9885218ff9707fdf77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a79a7c251b4685fbc2edb66c6835b78b2">setDataFloat</a> (const float *array, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a float array.  <a href="#a79a7c251b4685fbc2edb66c6835b78b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ab92a5bd661b92d8a125dad6dc9aee00a">setDataFloat</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, const vector&lt; float &gt; &amp;array)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a float array.  <a href="#ab92a5bd661b92d8a125dad6dc9aee00a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a9340ee881305f9749844f8ca4a9fe1e3">setDataFloat</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, const float *array, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a float array.  <a href="#a9340ee881305f9749844f8ca4a9fe1e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a5f18c458ece9fcbf22dcd6ad0105976a">setDataInt</a> (const vector&lt; int32_t &gt; &amp;array)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a int array.  <a href="#a5f18c458ece9fcbf22dcd6ad0105976a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a0fd50b1fdd6fdb5b056e9f1a89fd06c5">setDataInt</a> (const int32_t *array, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a int array.  <a href="#a0fd50b1fdd6fdb5b056e9f1a89fd06c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#aef5530ea23fdac9e4d1b55b5a920654d">setDataInt</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, const vector&lt; int32_t &gt; &amp;array)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a int array.  <a href="#aef5530ea23fdac9e4d1b55b5a920654d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a797aa9d37a91fdf251bc8452608a1adc">setDataInt</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, const int32_t *array, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a int array.  <a href="#a797aa9d37a91fdf251bc8452608a1adc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#af3c95c93878fbad899545e03c7d3539f">setDataLength</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, int32_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the length of the data in number of elements.  <a href="#af3c95c93878fbad899545e03c7d3539f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a> (int32_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the length of the data in number of elements.  <a href="#ae80174a71d1d015e44a57e194e72fa84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#afaaa2c807ec5e5dfe48434efe3b61721">setDataLong</a> (const vector&lt; int64_t &gt; &amp;array)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a long array.  <a href="#afaaa2c807ec5e5dfe48434efe3b61721"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a2d279916d2d3cc17090cd88c826ec1ab">setDataLong</a> (const int64_t *array, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a long array.  <a href="#a2d279916d2d3cc17090cd88c826ec1ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a67bc24f2ccd64fc0d6938585f337e668">setDataLong</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, const vector&lt; int64_t &gt; &amp;array)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a long array.  <a href="#a67bc24f2ccd64fc0d6938585f337e668"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ab678888fde37ecd54db2f4f5d140322d">setDataLong</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, const int64_t *array, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a long array.  <a href="#ab678888fde37ecd54db2f4f5d140322d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#aee0c386446f907b2da4abe8a5b443771">setDataShort</a> (const vector&lt; int16_t &gt; &amp;array)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a short array.  <a href="#aee0c386446f907b2da4abe8a5b443771"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a62ebebcf6f267bee3cdd63eb71a2b35d">setDataShort</a> (const int16_t *array, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a short array.  <a href="#a62ebebcf6f267bee3cdd63eb71a2b35d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a387f44eb2c048de551caf178298e7408">setDataShort</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, const vector&lt; int16_t &gt; &amp;array)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a short array.  <a href="#a387f44eb2c048de551caf178298e7408"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ada92f3f98c76e10c9c928e449196bc8b">setDataShort</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, const int16_t *array, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs the data using the values from a short array.  <a href="#ada92f3f98c76e10c9c928e449196bc8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a93d6e17bb22fd281f8cc37dc18c6bece">setDataValid</a> (boolNull v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Gets the valid data indicator flag.  <a href="#a93d6e17bb22fd281f8cc37dc18c6bece"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a6f10d443f5dd551422c918b0032d69a7">setDiscontinuious</a> (boolNull v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Deprecated:</b> Please change to using <code>setDiscontinuous</code>.  <a href="#a6f10d443f5dd551422c918b0032d69a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#af58c6ae90f42bfa58abf856295623516">setDiscontinuous</a> (boolNull v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Gets the sample loss indicator flag.  <a href="#af58c6ae90f42bfa58abf856295623516"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a26d23feba544bbcf35f14a38a5765d86">setField</a> (int32_t id, const <a class="el" href="classvrt_1_1Value.html">Value</a> *val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the value of a field, based on the field's id.  <a href="#a26d23feba544bbcf35f14a38a5765d86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#aeed461ab329054bbeedd18af2a6cb7f9">setInvertedSpectrum</a> (boolNull v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Gets the spectral inversion indicator flag.  <a href="#aeed461ab329054bbeedd18af2a6cb7f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ad2f482071e0b529f027e2d3265f251eb">setOverRange</a> (boolNull v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Gets the over-range indicator flag.  <a href="#ad2f482071e0b529f027e2d3265f251eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#af947fca253c101a6a97709c970e10a37">setPacketType</a> (PacketType t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets the packet type.  <a href="#af947fca253c101a6a97709c970e10a37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a93c2d36ed6000364254d48b93dcaa771">setPayloadFormat</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional Functionality:</em> Sets the payload format to be assumed when interacting with the data in this packet.  <a href="#a93c2d36ed6000364254d48b93dcaa771"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#acf42e6491de3037fc3ac7de0f0389c1d">setReferenceLocked</a> (boolNull v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Gets the reference lock indicator flag.  <a href="#acf42e6491de3037fc3ac7de0f0389c1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a117b4ff2d379bc467bb3cd2720a39392">setScalarDataLength</a> (<a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> pf, int32_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Utility method:</em> Sets the length of the data in number of scalar elements.  <a href="#a117b4ff2d379bc467bb3cd2720a39392"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#aa63c4dd3853e3c4b65fee663c8c1d3ee">setScalarDataLength</a> (int32_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Utility method:</em> Sets the length of the data in number of scalar elements.  <a href="#aa63c4dd3853e3c4b65fee663c8c1d3ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a8ed6baafc210158ff92c7f8edde8b526">setSignalDetected</a> (boolNull v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Gets the signal detected indicator flag.  <a href="#a8ed6baafc210158ff92c7f8edde8b526"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ad803d26ff68207f064f2df1b8dba572b">setStartStopIndication</a> (StartStopIndication v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets the Sample Frame Start Stop Indication value.  <a href="#ad803d26ff68207f064f2df1b8dba572b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6e88f662f761f896b3c58568865ad36"></a><!-- doxytag: member="vrt::BasicDataPacket::swapPayloadBytes" ref="aa6e88f662f761f896b3c58568865ad36" args="(const PayloadFormat &amp;pf)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>swapPayloadBytes</b> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#ac528ad3318660d948f10847c36095cc1">unsetStartStopIndication</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Unsets the Sample Frame Start Stop Indication enable bits.  <a href="#ac528ad3318660d948f10847c36095cc1"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#af837f2eeb24bab2216f9466047d4a0a9">BasicDataPacket</a> (const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;p, PacketType type, int64_t classID, int32_t minPayloadLength, int32_t maxPayloadLength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal constructor, for use by subclasses.  <a href="#af837f2eeb24bab2216f9466047d4a0a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#aee5712615c2115ab35217ab4e35f683f">dropTrailerIfEmpty</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the trailer is empty, delete it.  <a href="#aee5712615c2115ab35217ab4e35f683f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a9c1eae670dda54f59e5da8179497f15d">getDataLength</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, bool scalar) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the data length with option for scalar-only computation.  <a href="#a9c1eae670dda54f59e5da8179497f15d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a42f6521ae94c54f511316f7456cdbc8a">getTrailer</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the trailer as an integer.  <a href="#a42f6521ae94c54f511316f7456cdbc8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a2ab6592343f5322fd56ed2287f09fa02">getTrailerBit</a> (int32_t enable, int32_t indicator) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the specified bit from the trailer.  <a href="#a2ab6592343f5322fd56ed2287f09fa02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a9e6b623e1f1400d6a4896907399e5cd8">setDataLength</a> (const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;pf, int32_t length, bool scalar)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the data length with option for scalar-only computation.  <a href="#a9e6b623e1f1400d6a4896907399e5cd8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#a610c04accba684228dd36a363285fbfe">setTrailerBit</a> (int32_t enable, int32_t indicator, boolNull value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets the specified bit from the trailer.  <a href="#a610c04accba684228dd36a363285fbfe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicDataPacket.html#aec33b2c7031772f446ec0a9703f2b457">toStringStream</a> (ostringstream &amp;str) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the packet content to a string stream in a user-friendly format.  <a href="#aec33b2c7031772f446ec0a9703f2b457"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>An basic but full-featured implementation of a VRT IF Data packet. </p>
<p><br/>
 <br/>
 The following implementation is used for the <a class="el" href="classvrt_1_1HasFields.html">HasFields</a> methods: </p>
<pre>
     ID | Name                 | Type
    ----+----------------------+---------------
    N+0 | CalibratedTimeStamp  | BoolNull
    N+1 | DataValid            | BoolNull
    N+2 | ReferenceLocked      | BoolNull
    N+3 | AGC                  | BoolNull
    N+4 | SignalDetected       | BoolNull
    N+5 | InvertedSpectrum     | BoolNull
    N+6 | OverRange            | BoolNull
    N+7 | Discontinuous        | BoolNull
    N+8 | Bit11                | BoolNull
    N+9 | Bit10                | BoolNull
    N+10| Bit9                 | BoolNull
    N+11| Bit8                 | BoolNull
    N+12| AssocPacketCount     | Int8
    N+13| <a class="el" href="classvrt_1_1PayloadFormat.html" title="Specifies the payload format.">PayloadFormat</a>        | <a class="el" href="classvrt_1_1PayloadFormat.html" title="Specifies the payload format.">PayloadFormat</a>
    ----+----------------------+---------------
    (N = number of fields in <a class="el" href="classvrt_1_1BasicVRTPacket.html" title="A basic but full-featured implementation of BasicVRTPacket.">BasicVRTPacket</a>)
  </pre> <hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a75133f6c839b9a806efdfb7a9d7d87ee"></a><!-- doxytag: member="vrt::BasicDataPacket::~BasicDataPacket" ref="a75133f6c839b9a806efdfb7a9d7d87ee" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicDataPacket::~BasicDataPacket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Basic destructor for the class. </p>

</div>
</div>
<a class="anchor" id="a7e46e2f0697240c5777d826f1774e90d"></a><!-- doxytag: member="vrt::BasicDataPacket::BasicDataPacket" ref="a7e46e2f0697240c5777d826f1774e90d" args="(const BasicVRTPacket &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicDataPacket::BasicDataPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Basic copy constructor for the class. </p>

</div>
</div>
<a class="anchor" id="aad3d70a6cb267860c62c83ceb854d2f4"></a><!-- doxytag: member="vrt::BasicDataPacket::BasicDataPacket" ref="aad3d70a6cb267860c62c83ceb854d2f4" args="(const void *buf, size_t len, bool readOnly=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicDataPacket::BasicDataPacket </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>readOnly</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new instance accessing the given data buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The pointer to the packet buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the packet buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>readOnly</em>&nbsp;</td><td>Should users of this instance be able to modify the underlying data buffer? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c1b6415ebd565ba680c281dbed195c5"></a><!-- doxytag: member="vrt::BasicDataPacket::BasicDataPacket" ref="a3c1b6415ebd565ba680c281dbed195c5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicDataPacket::BasicDataPacket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new instance that can be written to. </p>
<p>Initially this will just be a simple data packet with streamID, classID, TSI=UTC, TSF=Real-Time, no trailer, and a packet length of 7. </p>

</div>
</div>
<a class="anchor" id="a5c69764c68a47846a481b14470085531"></a><!-- doxytag: member="vrt::BasicDataPacket::BasicDataPacket" ref="a5c69764c68a47846a481b14470085531" args="(int32_t bufsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicDataPacket::BasicDataPacket </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bufsize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new instance with a default anticipated length that can be written to. </p>
<p>Initially this will just be a simple data packet with streamID, classID, TSI=UTC, TSF-Real-Time, no trailer, and a packet length of 7. The underlying buffers will be pre-allocated as required. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufsize</em>&nbsp;</td><td>The anticipated buffer size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad6dfec6d06acf005c6b67676d871497a"></a><!-- doxytag: member="vrt::BasicDataPacket::BasicDataPacket" ref="ad6dfec6d06acf005c6b67676d871497a" args="(const vector&lt; char &gt; &amp;buf, bool readOnly=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicDataPacket::BasicDataPacket </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>readOnly</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new instance accessing the given data buffer. </p>
<p>Note that when the buffer lengths are given, only the most minimal of error checking is done. Users should call <code><a class="el" href="classvrt_1_1BasicVRTPacket.html#abada575c980c2e20543d3f0bfbaaad9f" title="Checks to see if the packet is valid.">isPacketValid()</a></code> to verify that the packet is valid. Invalid packets can result unpredictable behavior, but this is explicitly allowed (to the extent possible) so that applications creating packets can use this class even if the packet isn't yet "valid". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The data buffer to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>readOnly</em>&nbsp;</td><td>Should users of this instance be able to modify the underlying data buffer? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada678044c661a9305ac232a7d7028c52"></a><!-- doxytag: member="vrt::BasicDataPacket::BasicDataPacket" ref="ada678044c661a9305ac232a7d7028c52" args="(vector&lt; char &gt; *buf, bool readOnly=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicDataPacket::BasicDataPacket </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>readOnly</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new instance accessing the given data buffer pointer. </p>
<p>Note that when the buffer lengths are given, only the most minimal of error checking is done. Users should call <code><a class="el" href="classvrt_1_1BasicVRTPacket.html#abada575c980c2e20543d3f0bfbaaad9f" title="Checks to see if the packet is valid.">isPacketValid()</a></code> to verify that the packet is valid. Invalid packets can result unpredictable behavior, but this is explicitly allowed (to the extent possible) so that applications creating packets can use this class even if the packet isn't yet "valid". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The data buffer pointer to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>readOnly</em>&nbsp;</td><td>Should users of this instance be able to modify the underlying data buffer? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af837f2eeb24bab2216f9466047d4a0a9"></a><!-- doxytag: member="vrt::BasicDataPacket::BasicDataPacket" ref="af837f2eeb24bab2216f9466047d4a0a9" args="(const BasicVRTPacket &amp;p, PacketType type, int64_t classID, int32_t minPayloadLength, int32_t maxPayloadLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicDataPacket::BasicDataPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PacketType&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>classID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>minPayloadLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>maxPayloadLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal constructor, for use by subclasses. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The packet (already initialized). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The expected packet type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>classID</em>&nbsp;</td><td>The expected classID. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minPayloadLength</em>&nbsp;</td><td>The minimum payload length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxPayloadLength</em>&nbsp;</td><td>The maximum payload length (&lt;0 if not pre-defined). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If packet type or classID of the packet are invalid, or if the payload length is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aee5712615c2115ab35217ab4e35f683f"></a><!-- doxytag: member="vrt::BasicDataPacket::dropTrailerIfEmpty" ref="aee5712615c2115ab35217ab4e35f683f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::dropTrailerIfEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the trailer is empty, delete it. </p>

</div>
</div>
<a class="anchor" id="af77e88c7722a175fd3c6f52b2687abdd"></a><!-- doxytag: member="vrt::BasicDataPacket::getAssocPacketCount" ref="af77e88c7722a175fd3c6f52b2687abdd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t vrt::BasicDataPacket::getAssocPacketCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the associated packet count. </p>
<p>This indicates the number of context packets with context change or event information relevant to this data packet. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The associated packet count (0..127), or null if not specified (null is returned for all context packets). </dd></dl>

</div>
</div>
<a class="anchor" id="a162a35422149ca9b7c1f3fa932b3e385"></a><!-- doxytag: member="vrt::BasicDataPacket::getData" ref="a162a35422149ca9b7c1f3fa932b3e385" args="(void *array, bool convert=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* vrt::BasicDataPacket::getData </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>convert</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it in a native byte buffer. </p>
<p>This is basically a byte-for-byte copy of the payload, except that a conversion is done from <code>BIG_ENDIAN</code> to the native byte ordering. This method is intended for use within existing programming frameworks that already provide type conversions. <b>This method does not convert the values to byte data, only copies the data to what is effectively a <code>void*</code> buffer in the native byte order.</b> <br/>
 <br/>
 For 8-bit, 4-bit and 1-bit types, this is implemented as a fast array copy with no translation being done with regards to byte order. Further, with 4-bit and 1-bit types an assumption is made that the number of entries is an even multiple of one octet (i.e. 4-bit values must be in multiples of 2 and 1-bit values in multiples of 8). <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.getData(p.getPayloadFormat(),array)</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The array to insert the data into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>convert</em>&nbsp;</td><td>Convert byte order to match native representation? Set this to false if it is necessary to keep the data in big-endian format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>array</code> </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null or if the array is null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is anything other than <code>PayloadFormat_INT4</code>, <code>PayloadFormat_INT8</code>, <code>PayloadFormat_INT16</code>, <code>PayloadFormat_INT32</code>, <code>PayloadFormat_INT64</code>, <code>PayloadFormat_FLOAT32</code>, <code>PayloadFormat_DOUBLE64</code> <code>PayloadFormat_UINT1</code>, <code>PayloadFormat_UINT4</code>, <code>PayloadFormat_UINT8</code>, <code>PayloadFormat_UINT16</code>, <code>PayloadFormat_UINT32</code>, <code>PayloadFormat_UINT64</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00678">getData()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>.</p>

</div>
</div>
<a class="anchor" id="a8c8496c1172d68c98e1f9dd0cd19bae5"></a><!-- doxytag: member="vrt::BasicDataPacket::getData" ref="a8c8496c1172d68c98e1f9dd0cd19bae5" args="(vector&lt; char &gt; &amp;array, size_t offset, bool convert=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::getData </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>convert</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it in a native byte buffer. </p>
<p>This is basically a byte-for-byte copy of the payload, except that a conversion is done from <code>BIG_ENDIAN</code> to the native byte ordering. This method is intended for use within existing programming frameworks that already provide type conversions. <b>This method does not convert the values to byte data, only copies the data to what is effectively a <code>void*</code> buffer in the native byte order.</b> <br/>
 <br/>
 For 8-bit, 4-bit and 1-bit types, this is implemented as a fast array copy with no translation being done with regards to byte order. Further, with 4-bit and 1-bit types an assumption is made that the number of entries is an even multiple of one octet (i.e. 4-bit values must be in multiples of 2 and 1-bit values in multiples of 8). <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.getData(p.getPayloadFormat(),array,offset)</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The array to insert the data into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The array offset. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>convert</em>&nbsp;</td><td>Convert byte order to match native representation? Set this to false if it is necessary to keep the data in big-endian format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>array</code> </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null or if the array is null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is anything other than <code>PayloadFormat_INT4</code>, <code>PayloadFormat_INT8</code>, <code>PayloadFormat_INT16</code>, <code>PayloadFormat_INT32</code>, <code>PayloadFormat_INT64</code>, <code>PayloadFormat_FLOAT32</code>, <code>PayloadFormat_DOUBLE64</code> <code>PayloadFormat_UINT1</code>, <code>PayloadFormat_UINT4</code>, <code>PayloadFormat_UINT8</code>, <code>PayloadFormat_UINT16</code>, <code>PayloadFormat_UINT32</code>, <code>PayloadFormat_UINT64</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the array length is shorter than <code>offset+getPayloadLength()</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00678">getData()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>.</p>

</div>
</div>
<a class="anchor" id="a93902944a0d6a0993b3f400210c44154"></a><!-- doxytag: member="vrt::BasicDataPacket::getData" ref="a93902944a0d6a0993b3f400210c44154" args="(const PayloadFormat &amp;pf, void *array, bool convert=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* vrt::BasicDataPacket::getData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>convert</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it in a native byte buffer. </p>
<p>This is basically a byte-for-byte copy of the payload, except that a conversion is done from <code>BIG_ENDIAN</code> to the native byte ordering. This method is intended for use within existing programming frameworks that already provide type conversions. <b>This method does not convert the values to byte data, only copies the data to what is effectively a <code>void*</code> buffer in the native byte order.</b> <br/>
 <br/>
 For 8-bit, 4-bit and 1-bit types, this is implemented as a fast array copy with no translation being done with regards to byte order. Further, with 4-bit and 1-bit types an assumption is made that the number of entries is an even multiple of one octet (i.e. 4-bit values must be in multiples of 2 and 1-bit values in multiples of 8). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The array to insert the data into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>convert</em>&nbsp;</td><td>Convert byte order to match native representation? Set this to false if it is necessary to keep the data in big-endian format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>array</code> </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null or if the array is null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is anything other than <code>PayloadFormat_INT4</code>, <code>PayloadFormat_INT8</code>, <code>PayloadFormat_INT16</code>, <code>PayloadFormat_INT32</code>, <code>PayloadFormat_INT64</code>, <code>PayloadFormat_FLOAT32</code>, <code>PayloadFormat_DOUBLE64</code> <code>PayloadFormat_UINT1</code>, <code>PayloadFormat_UINT4</code>, <code>PayloadFormat_UINT8</code>, <code>PayloadFormat_UINT16</code>, <code>PayloadFormat_UINT32</code>, <code>PayloadFormat_UINT64</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the array length is shorter than <code>offset+getPayloadLength()</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64ce16ae976a184d88017323aab05092"></a><!-- doxytag: member="vrt::BasicDataPacket::getData" ref="a64ce16ae976a184d88017323aab05092" args="(const PayloadFormat &amp;pf, vector&lt; char &gt; &amp;array, size_t offset, bool convert=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::getData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>convert</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it in a native byte buffer. </p>
<p>This is basically a byte-for-byte copy of the payload, except that a conversion is done from <code>BIG_ENDIAN</code> to the native byte ordering. This method is intended for use within existing programming frameworks that already provide type conversions. <b>This method does not convert the values to byte data, only copies the data to what is effectively a <code>void*</code> buffer in the native byte order.</b> <br/>
 <br/>
 For 8-bit, 4-bit and 1-bit types, this is implemented as a fast array copy with no translation being done with regards to byte order. Further, with 4-bit and 1-bit types an assumption is made that the number of entries is an even multiple of one octet (i.e. 4-bit values must be in multiples of 2 and 1-bit values in multiples of 8). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The array to insert the data into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The array offset. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>convert</em>&nbsp;</td><td>Convert byte order to match native representation? Set this to false if it is necessary to keep the data in big-endian format. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null or if the array is null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is anything other than <code>PayloadFormat_INT4</code>, <code>PayloadFormat_INT8</code>, <code>PayloadFormat_INT16</code>, <code>PayloadFormat_INT32</code>, <code>PayloadFormat_INT64</code>, <code>PayloadFormat_FLOAT32</code>, <code>PayloadFormat_DOUBLE64</code> <code>PayloadFormat_UINT1</code>, <code>PayloadFormat_UINT4</code>, <code>PayloadFormat_UINT8</code>, <code>PayloadFormat_UINT16</code>, <code>PayloadFormat_UINT32</code>, <code>PayloadFormat_UINT64</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the array length is shorter than <code>offset+getPayloadLength()</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00619">vrt::BasicVRTPacket::getPayloadLength()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l00935">getData()</a>.</p>

</div>
</div>
<a class="anchor" id="adede111fce7ad83c335701dedecae8c5"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataByte" ref="adede111fce7ad83c335701dedecae8c5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int8_t&gt; vrt::BasicDataPacket::getDataByte </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a byte array. </p>
<p>If the underlying data is not double, it will be converted to byte and any values that fall outside of the range of a byte will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.getDataByte(p.getPayloadFormat())</code> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The data elements. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l01148">getDataByte()</a>.</p>

</div>
</div>
<a class="anchor" id="ac3a994e1cef1e60e61f802f0427e832d"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataByte" ref="ac3a994e1cef1e60e61f802f0427e832d" args="(int8_t *array) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t* vrt::BasicDataPacket::getDataByte </td>
          <td>(</td>
          <td class="paramtype">int8_t *&nbsp;</td>
          <td class="paramname"> <em>array</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a byte array. </p>
<p>If the underlying data is not byte, it will be converted to byte and any values that fall outside of the range of a byte will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.getDataDouble(p.getPayloadFormat())</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The array to insert the data into (not null). The array must be sufficiently long for the number of elements in the packet (see <code>getScalarDataLength(pf)</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to 'buf'. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l01163">getDataByte()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>.</p>

</div>
</div>
<a class="anchor" id="a79e11a2afa970f14f7ed7c8e3ec8e3cd"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataByte" ref="a79e11a2afa970f14f7ed7c8e3ec8e3cd" args="(const PayloadFormat &amp;pf) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int8_t&gt; vrt::BasicDataPacket::getDataByte </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a byte array. </p>
<p>If the underlying data is not byte, it will be converted to byte and any values that fall outside of the range of a byte will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The data elements. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00479">getScalarDataLength()</a>, and <a class="el" href="namespacevrt_1_1PackUnpack.html#a542c1be8754b76b09c4a69cd9160394e">vrt::PackUnpack::unpackAsByte()</a>.</p>

</div>
</div>
<a class="anchor" id="a693d077665fc762c935234d53f84a69e"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataByte" ref="a693d077665fc762c935234d53f84a69e" args="(const PayloadFormat &amp;pf, int8_t *array) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t* vrt::BasicDataPacket::getDataByte </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&nbsp;</td>
          <td class="paramname"> <em>array</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a byte array. </p>
<p>If the underlying data is not byte, it will be converted to byte and any values that fall outside of the range of a byte will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The array to insert the data into (not null). The array must be sufficiently long for the number of elements in the packet (see <code>getScalarDataLength(pf)</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to 'buf'. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00479">getScalarDataLength()</a>, and <a class="el" href="namespacevrt_1_1PackUnpack.html#a542c1be8754b76b09c4a69cd9160394e">vrt::PackUnpack::unpackAsByte()</a>.</p>

</div>
</div>
<a class="anchor" id="a12fbb106428337798aae0614116e2351"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataDouble" ref="a12fbb106428337798aae0614116e2351" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;double&gt; vrt::BasicDataPacket::getDataDouble </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a double array. </p>
<p>If the underlying data is not double, it will be converted to double and any values that fall outside of the range of a double will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.getDataDouble(p.getPayloadFormat())</code> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The data elements. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l00983">getDataDouble()</a>.</p>

</div>
</div>
<a class="anchor" id="a6721b53ffb68afac510df14298c70598"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataDouble" ref="a6721b53ffb68afac510df14298c70598" args="(double *array) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* vrt::BasicDataPacket::getDataDouble </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>array</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a double array. </p>
<p>If the underlying data is not double, it will be converted to double and any values that fall outside of the range of a double will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.getDataDouble(p.getPayloadFormat())</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The array to insert the data into (not null). The array must be sufficiently long for the number of elements in the packet (see <code>getScalarDataLength(pf)</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to 'buf'. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00998">getDataDouble()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>.</p>

</div>
</div>
<a class="anchor" id="afc6144d5a7d91f62a55ba951edec096d"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataDouble" ref="afc6144d5a7d91f62a55ba951edec096d" args="(const PayloadFormat &amp;pf) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;double&gt; vrt::BasicDataPacket::getDataDouble </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a double array. </p>
<p>If the underlying data is not double, it will be converted to double and any values that fall outside of the range of a double will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The data elements. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00479">getScalarDataLength()</a>, and <a class="el" href="namespacevrt_1_1PackUnpack.html#a6ac040109f1d1463339298981aa5b5d7">vrt::PackUnpack::unpackAsDouble()</a>.</p>

</div>
</div>
<a class="anchor" id="afe10f97bbc350829bc85ead9183bff64"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataDouble" ref="afe10f97bbc350829bc85ead9183bff64" args="(const PayloadFormat &amp;pf, double *array) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* vrt::BasicDataPacket::getDataDouble </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>array</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a double array. </p>
<p>If the underlying data is not double, it will be converted to double and any values that fall outside of the range of a double will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The array to insert the data into (not null). The array must be sufficiently long for the number of elements in the packet (see <code>getScalarDataLength(pf)</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to 'buf'. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00479">getScalarDataLength()</a>, and <a class="el" href="namespacevrt_1_1PackUnpack.html#a6ac040109f1d1463339298981aa5b5d7">vrt::PackUnpack::unpackAsDouble()</a>.</p>

</div>
</div>
<a class="anchor" id="ace70db4848697ffb8ccd341255e8bf28"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataFloat" ref="ace70db4848697ffb8ccd341255e8bf28" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;float&gt; vrt::BasicDataPacket::getDataFloat </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a float array. </p>
<p>If the underlying data is not double, it will be converted to float and any values that fall outside of the range of a float will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.getDataFloat(p.getPayloadFormat())</code> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The data elements. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l01016">getDataFloat()</a>.</p>

</div>
</div>
<a class="anchor" id="a3c48d53f3bd665cfb888a622f09a7707"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataFloat" ref="a3c48d53f3bd665cfb888a622f09a7707" args="(float *array) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float* vrt::BasicDataPacket::getDataFloat </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>array</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a float array. </p>
<p>If the underlying data is not float, it will be converted to float and any values that fall outside of the range of a float will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.getDataDouble(p.getPayloadFormat())</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The array to insert the data into (not null). The array must be sufficiently long for the number of elements in the packet (see <code>getScalarDataLength(pf)</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to 'buf'. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l01031">getDataFloat()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>.</p>

</div>
</div>
<a class="anchor" id="a21b72098e924dd8812ff6994d7008249"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataFloat" ref="a21b72098e924dd8812ff6994d7008249" args="(const PayloadFormat &amp;pf) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;float&gt; vrt::BasicDataPacket::getDataFloat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a float array. </p>
<p>If the underlying data is not float, it will be converted to float and any values that fall outside of the range of a float will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The data elements. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00479">getScalarDataLength()</a>, and <a class="el" href="namespacevrt_1_1PackUnpack.html#acba6047381dc98662911a356f68f8393">vrt::PackUnpack::unpackAsFloat()</a>.</p>

</div>
</div>
<a class="anchor" id="a4c3d55faf86a4a5e20e80f227061f365"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataFloat" ref="a4c3d55faf86a4a5e20e80f227061f365" args="(const PayloadFormat &amp;pf, float *array) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float* vrt::BasicDataPacket::getDataFloat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>array</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a float array. </p>
<p>If the underlying data is not float, it will be converted to float and any values that fall outside of the range of a float will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The array to insert the data into (not null). The array must be sufficiently long for the number of elements in the packet (see <code>getScalarDataLength(pf)</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to 'buf'. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00479">getScalarDataLength()</a>, and <a class="el" href="namespacevrt_1_1PackUnpack.html#acba6047381dc98662911a356f68f8393">vrt::PackUnpack::unpackAsFloat()</a>.</p>

</div>
</div>
<a class="anchor" id="a242c9deb2ca0b5f1623458771526d072"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataInt" ref="a242c9deb2ca0b5f1623458771526d072" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int32_t&gt; vrt::BasicDataPacket::getDataInt </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a int array. </p>
<p>If the underlying data is not double, it will be converted to int and any values that fall outside of the range of a int will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.getDataInt(p.getPayloadFormat())</code> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The data elements. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l01082">getDataInt()</a>.</p>

</div>
</div>
<a class="anchor" id="adf9cc141682ad4053b864f215df100ad"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataInt" ref="adf9cc141682ad4053b864f215df100ad" args="(int32_t *array) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t* vrt::BasicDataPacket::getDataInt </td>
          <td>(</td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>array</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a int array. </p>
<p>If the underlying data is not int, it will be converted to int and any values that fall outside of the range of a int will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.getDataDouble(p.getPayloadFormat())</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The array to insert the data into (not null). The array must be sufficiently long for the number of elements in the packet (see <code>getScalarDataLength(pf)</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to 'buf'. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l01097">getDataInt()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>.</p>

</div>
</div>
<a class="anchor" id="aacc4d6b4519ab9fe18782f7607b35103"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataInt" ref="aacc4d6b4519ab9fe18782f7607b35103" args="(const PayloadFormat &amp;pf) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int32_t&gt; vrt::BasicDataPacket::getDataInt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a int array. </p>
<p>If the underlying data is not int, it will be converted to int and any values that fall outside of the range of a int will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The data elements. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00479">getScalarDataLength()</a>, and <a class="el" href="namespacevrt_1_1PackUnpack.html#a196ce781efa46ea4e8068a0ad6fd22a9">vrt::PackUnpack::unpackAsInt()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e24bea830d60ff3ba7268ab72735452"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataInt" ref="a5e24bea830d60ff3ba7268ab72735452" args="(const PayloadFormat &amp;pf, int32_t *array) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t* vrt::BasicDataPacket::getDataInt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>array</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a int array. </p>
<p>If the underlying data is not int, it will be converted to int and any values that fall outside of the range of a int will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The array to insert the data into (not null). The array must be sufficiently long for the number of elements in the packet (see <code>getScalarDataLength(pf)</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to 'buf'. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00479">getScalarDataLength()</a>, and <a class="el" href="namespacevrt_1_1PackUnpack.html#a196ce781efa46ea4e8068a0ad6fd22a9">vrt::PackUnpack::unpackAsInt()</a>.</p>

</div>
</div>
<a class="anchor" id="a9c1eae670dda54f59e5da8179497f15d"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataLength" ref="a9c1eae670dda54f59e5da8179497f15d" args="(const PayloadFormat &amp;pf, bool scalar) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicDataPacket::getDataLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>scalar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the data length with option for scalar-only computation. </p>

</div>
</div>
<a class="anchor" id="a97e6656985695861342887e3f1f4a68e"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataLength" ref="a97e6656985695861342887e3f1f4a68e" args="(const PayloadFormat &amp;pf) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicDataPacket::getDataLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the length of the data in number of elements. </p>
<p>Unlike <code><a class="el" href="classvrt_1_1BasicVRTPacket.html#a408e5bbadcd6099619e264a412223c36" title="Gets the payload length in bytes.">getPayloadLength()</a></code> this returns the number of data elements, not bytes. For complex data the real and imaginary components of a single value count as a single element (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a93844600fe4d42f517b585bed68bdd8e">getScalarDataLength()</a>). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of elements in the payload. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00504">getDataLength()</a>.</p>

</div>
</div>
<a class="anchor" id="ade26b4b982fd93adf72f752cd93bf732"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataLength" ref="ade26b4b982fd93adf72f752cd93bf732" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicDataPacket::getDataLength </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the length of the data in number of elements. </p>
<p>Unlike <code><a class="el" href="classvrt_1_1BasicVRTPacket.html#a408e5bbadcd6099619e264a412223c36" title="Gets the payload length in bytes.">getPayloadLength()</a></code> this returns the number of data elements, not bytes. For complex data the real and imaginary components of a single value count as a single element (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a93844600fe4d42f517b585bed68bdd8e">getScalarDataLength()</a>). <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.getDataLength(p.getPayloadFormat())</code> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of elements in the payload. </dd></dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l00515">getDataLength()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00479">getScalarDataLength()</a>.</p>

</div>
</div>
<a class="anchor" id="a17d0cb447c5569e44b7bbe53fb93f283"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataLong" ref="a17d0cb447c5569e44b7bbe53fb93f283" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int64_t&gt; vrt::BasicDataPacket::getDataLong </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a long array. </p>
<p>If the underlying data is not double, it will be converted to long and any values that fall outside of the range of a long will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.getDataLong(p.getPayloadFormat())</code> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The data elements. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l01049">getDataLong()</a>.</p>

</div>
</div>
<a class="anchor" id="a428e8f3b7e1364e9db8f39695e4a1834"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataLong" ref="a428e8f3b7e1364e9db8f39695e4a1834" args="(int64_t *array) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t* vrt::BasicDataPacket::getDataLong </td>
          <td>(</td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"> <em>array</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a long array. </p>
<p>If the underlying data is not long, it will be converted to long and any values that fall outside of the range of a long will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.getDataDouble(p.getPayloadFormat())</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The array to insert the data into (not null). The array must be sufficiently long for the number of elements in the packet (see <code>getScalarDataLength(pf)</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to 'buf'. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l01064">getDataLong()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>.</p>

</div>
</div>
<a class="anchor" id="ae64f111c47dcf42826cc1d34b1a3e592"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataLong" ref="ae64f111c47dcf42826cc1d34b1a3e592" args="(const PayloadFormat &amp;pf) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int64_t&gt; vrt::BasicDataPacket::getDataLong </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a long array. </p>
<p>If the underlying data is not long, it will be converted to long and any values that fall outside of the range of a long will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The data elements. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00479">getScalarDataLength()</a>, and <a class="el" href="namespacevrt_1_1PackUnpack.html#a805769748c6c48ed0beb88b3eb891d04">vrt::PackUnpack::unpackAsLong()</a>.</p>

</div>
</div>
<a class="anchor" id="a6692b2adf5376befe77b6269a1f53a62"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataLong" ref="a6692b2adf5376befe77b6269a1f53a62" args="(const PayloadFormat &amp;pf, int64_t *array) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t* vrt::BasicDataPacket::getDataLong </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"> <em>array</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a long array. </p>
<p>If the underlying data is not long, it will be converted to long and any values that fall outside of the range of a long will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The array to insert the data into (not null). The array must be sufficiently long for the number of elements in the packet (see <code>getScalarDataLength(pf)</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to 'buf'. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00479">getScalarDataLength()</a>, and <a class="el" href="namespacevrt_1_1PackUnpack.html#a805769748c6c48ed0beb88b3eb891d04">vrt::PackUnpack::unpackAsLong()</a>.</p>

</div>
</div>
<a class="anchor" id="a797ed03a04a35214e37ddf4cb999927c"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataShort" ref="a797ed03a04a35214e37ddf4cb999927c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int16_t&gt; vrt::BasicDataPacket::getDataShort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a byte array. </p>
<p>If the underlying data is not double, it will be converted to byte and any values that fall outside of the range of a byte will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.getDataShort(p.getPayloadFormat())</code> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The data elements. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l01115">getDataShort()</a>.</p>

</div>
</div>
<a class="anchor" id="a02d46c77bb93170a86d32bc82277f165"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataShort" ref="a02d46c77bb93170a86d32bc82277f165" args="(int16_t *array) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t* vrt::BasicDataPacket::getDataShort </td>
          <td>(</td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"> <em>array</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a short array. </p>
<p>If the underlying data is not short, it will be converted to short and any values that fall outside of the range of a short will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.getDataDouble(p.getPayloadFormat())</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The array to insert the data into (not null). The array must be sufficiently long for the number of elements in the packet (see <code>getScalarDataLength(pf)</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to 'buf'. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l01130">getDataShort()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>.</p>

</div>
</div>
<a class="anchor" id="a4fa85ce16ce304df41ad54e5cd567bd3"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataShort" ref="a4fa85ce16ce304df41ad54e5cd567bd3" args="(const PayloadFormat &amp;pf) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int16_t&gt; vrt::BasicDataPacket::getDataShort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a short array. </p>
<p>If the underlying data is not short, it will be converted to short and any values that fall outside of the range of a short will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The data elements. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00479">getScalarDataLength()</a>, and <a class="el" href="namespacevrt_1_1PackUnpack.html#ac7333bd3d00303e033d01c3a6264869a">vrt::PackUnpack::unpackAsShort()</a>.</p>

</div>
</div>
<a class="anchor" id="a3af6e8b5486afc0c644c62ba9da04d7c"></a><!-- doxytag: member="vrt::BasicDataPacket::getDataShort" ref="a3af6e8b5486afc0c644c62ba9da04d7c" args="(const PayloadFormat &amp;pf, int16_t *array) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t* vrt::BasicDataPacket::getDataShort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"> <em>array</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks the data and returns it as a short array. </p>
<p>If the underlying data is not short, it will be converted to short and any values that fall outside of the range of a short will will have unpredictable output. If the payload format is incorrectly specified, the output of this method will be useless. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The array to insert the data into (not null). The array must be sufficiently long for the number of elements in the packet (see <code>getScalarDataLength(pf)</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to 'buf'. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00479">getScalarDataLength()</a>, and <a class="el" href="namespacevrt_1_1PackUnpack.html#ac7333bd3d00303e033d01c3a6264869a">vrt::PackUnpack::unpackAsShort()</a>.</p>

</div>
</div>
<a class="anchor" id="a8be80b0dbd51e2755cb04e37935eb1de"></a><!-- doxytag: member="vrt::BasicDataPacket::getField" ref="a8be80b0dbd51e2755cb04e37935eb1de" args="(int32_t id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classvrt_1_1Value.html">Value</a>* vrt::BasicDataPacket::getField </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the value of a field, based on the field's id. </p>
<p><br/>
 <br/>
 <b>WARNING: The caller is responsible for deleting the memory referenced by the returned pointer.</b> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>The field ID (on range <code>[0,<a class="el" href="classvrt_1_1BasicDataPacket.html#ad0c765c6f4e0807af2b42b92e9bc4526" title="Gets the number of fields.">getFieldCount()</a>)</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the given value. </dd></dl>

<p>Reimplemented from <a class="el" href="classvrt_1_1BasicVRTPacket.html#a444461f6621a2b031f904440ae2a6fc1">vrt::BasicVRTPacket</a>.</p>

<p>Reimplemented in <a class="el" href="classvrt_1_1NoDataPacket.html#a8762fa7d98809cb34232172f40a1209c">vrt::NoDataPacket</a>.</p>

</div>
</div>
<a class="anchor" id="ad0c765c6f4e0807af2b42b92e9bc4526"></a><!-- doxytag: member="vrt::BasicDataPacket::getFieldCount" ref="ad0c765c6f4e0807af2b42b92e9bc4526" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t vrt::BasicDataPacket::getFieldCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the number of fields. </p>

<p>Reimplemented from <a class="el" href="classvrt_1_1BasicVRTPacket.html#aeec8ba3ed0fdc05f4ea766a80608ff24">vrt::BasicVRTPacket</a>.</p>

<p>Reimplemented in <a class="el" href="classvrt_1_1NoDataPacket.html#a35b24910e9d1fcc95080c831d42be5c0">vrt::NoDataPacket</a>.</p>

</div>
</div>
<a class="anchor" id="ad22cc3fcdc17ebcbb2c95106ba448b61"></a><!-- doxytag: member="vrt::BasicDataPacket::getFieldName" ref="ad22cc3fcdc17ebcbb2c95106ba448b61" args="(int32_t id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual string vrt::BasicDataPacket::getFieldName </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the name of the given field. </p>
<p>In 90% of cases the field name will be identical to the name used in the applicable get/set function except without the get/set prefix (e.g. "SourceContext" for "getSourceContext"). It is possible to access the names of all fields via the following: </p>
<pre>
    for (int32_t id = 0; id &lt; <a class="el" href="classvrt_1_1BasicDataPacket.html#ad0c765c6f4e0807af2b42b92e9bc4526" title="Gets the number of fields.">getFieldCount()</a>; id++) {
      // id is the field ID
      getFieldName(id);
    }
  </pre><p> In situations where it is desirable to access all available fields, it is faster to use the field ID as this eliminates any string comparisons. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>The field ID (on range <code>[0,<a class="el" href="classvrt_1_1BasicDataPacket.html#ad0c765c6f4e0807af2b42b92e9bc4526" title="Gets the number of fields.">getFieldCount()</a>)</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The field name. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>if the field id is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classvrt_1_1BasicVRTPacket.html#a65153479839ceaa41b0a41373b02ca95">vrt::BasicVRTPacket</a>.</p>

<p>Reimplemented in <a class="el" href="classvrt_1_1NoDataPacket.html#ae6cc0e5ab24e49e07ada5e913af25c4b">vrt::NoDataPacket</a>.</p>

</div>
</div>
<a class="anchor" id="a8013a7abb16b51db23230578ba7b8d64"></a><!-- doxytag: member="vrt::BasicDataPacket::getFieldType" ref="a8013a7abb16b51db23230578ba7b8d64" args="(int32_t id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ValueType vrt::BasicDataPacket::getFieldType </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the type associated with a given field. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>The field ID (on range <code>[0,<a class="el" href="classvrt_1_1BasicDataPacket.html#ad0c765c6f4e0807af2b42b92e9bc4526" title="Gets the number of fields.">getFieldCount()</a>)</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The field type (n &gt; 0) or -N if the field is a vector of values where N is the component type of the vector. </dd></dl>

<p>Reimplemented from <a class="el" href="classvrt_1_1BasicVRTPacket.html#a4cb1678a3a71c7abda7c621b2f96363a">vrt::BasicVRTPacket</a>.</p>

<p>Reimplemented in <a class="el" href="classvrt_1_1NoDataPacket.html#a1719ffd852ef276e58a8dce7f51bccf9">vrt::NoDataPacket</a>.</p>

</div>
</div>
<a class="anchor" id="ae461791fa9aaeb9b8f54727cc0c6352f"></a><!-- doxytag: member="vrt::BasicDataPacket::getLostBytes" ref="ae461791fa9aaeb9b8f54727cc0c6352f" args="(const TimeStamp &amp;expected, double sampleRate) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicDataPacket::getLostBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>sampleRate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the number of bytes lost between two packets. </p>
<p><br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.getDataLength(p.getPayloadFormat())</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expected</em>&nbsp;</td><td>The expected time stamp (predicted from by calling <code>getNextTimeStamp(..)</code> on the previous packet). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sampleRate</em>&nbsp;</td><td>The applicable sample rate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of lost bytes. This will be 0 if no bytes were lost and -N if there is an N byte overlap (i.e. extra data). The -N case is usually the result of an incorrect sample rate and/or incorrect payload format. </dd></dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00568">getLostBytes()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>.</p>

</div>
</div>
<a class="anchor" id="a3a00dc41b79f3c5a81e4f35ed60f31e9"></a><!-- doxytag: member="vrt::BasicDataPacket::getLostBytes" ref="a3a00dc41b79f3c5a81e4f35ed60f31e9" args="(const TimeStamp &amp;expected, double sampleRate, const PayloadFormat &amp;pf) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicDataPacket::getLostBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the number of bytes lost between two packets. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expected</em>&nbsp;</td><td>The expected time stamp (predicted from by calling <code>getNextTimeStamp(..)</code> on the previous packet). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sampleRate</em>&nbsp;</td><td>The applicable sample rate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of lost bytes. This will be 0 if no bytes were lost and -N if there is an N byte overlap (i.e. extra data). The -N case is usually the result of an incorrect sample rate and/or incorrect payload format. </dd></dl>

<p>References <a class="el" href="PayloadFormat_8h_source.html#l00479">vrt::PayloadFormat::getDataItemSize()</a>, and <a class="el" href="classvrt_1_1BasicDataPacket.html#a2e03bafa6ecccfe96fdb72a1f5d2ac45">getLostSamples()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l00584">getLostBytes()</a>.</p>

</div>
</div>
<a class="anchor" id="a2e03bafa6ecccfe96fdb72a1f5d2ac45"></a><!-- doxytag: member="vrt::BasicDataPacket::getLostSamples" ref="a2e03bafa6ecccfe96fdb72a1f5d2ac45" args="(const TimeStamp &amp;expected, double sampleRate) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicDataPacket::getLostSamples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>sampleRate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the number of samples lost between two packets. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expected</em>&nbsp;</td><td>The expected time stamp (predicted from by calling <code>getNextTimeStamp(..)</code> on the previous packet). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sampleRate</em>&nbsp;</td><td>The applicable sample rate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of lost samples. This will be 0 if no samples were lost and -N if there is an N sample overlap (i.e. extra data). The -N case is usually the result of an incorrect sample rate and/or incorrect payload format. </dd></dl>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l00568">getLostBytes()</a>.</p>

</div>
</div>
<a class="anchor" id="a736fb29c269b38a4cf505c30481c2087"></a><!-- doxytag: member="vrt::BasicDataPacket::getNextTimeStamp" ref="a736fb29c269b38a4cf505c30481c2087" args="(double sampleRate) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> vrt::BasicDataPacket::getNextTimeStamp </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>sampleRate</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the next expected time stamp for a data packet on this stream. </p>
<p>This is computed as the following: </p>
<pre>
    nextTimeStamp = currentTimeStamp + (dataLength * sampleRate)
  </pre><p> This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.getDataLength(p.getPayloadFormat())</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sampleRate</em>&nbsp;</td><td>The applicable sample rate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The time stamp to expect for the next data packet. </dd></dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a93f2b1fa6bbb21ee8470cd36c98fef8b">getNextTimeStamp()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>.</p>

</div>
</div>
<a class="anchor" id="a93f2b1fa6bbb21ee8470cd36c98fef8b"></a><!-- doxytag: member="vrt::BasicDataPacket::getNextTimeStamp" ref="a93f2b1fa6bbb21ee8470cd36c98fef8b" args="(double sampleRate, const PayloadFormat &amp;pf) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> vrt::BasicDataPacket::getNextTimeStamp </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the next expected time stamp for a data packet on this stream. </p>
<p>This is computed as the following: </p>
<pre>
    nextTimeStamp = currentTimeStamp + (dataLength * sampleRate)
  </pre> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sampleRate</em>&nbsp;</td><td>The applicable sample rate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The time stamp to expect for the next data packet. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l00545">getNextTimeStamp()</a>.</p>

</div>
</div>
<a class="anchor" id="aeba2eca140af729e176d8c628f497cf5"></a><!-- doxytag: member="vrt::BasicDataPacket::getPacketValid" ref="aeba2eca140af729e176d8c628f497cf5" args="(bool strict, int32_t length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual string vrt::BasicDataPacket::getPacketValid </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>strict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks to see if the packet is valid. </p>
<p>This is identical to <code>isPacketValid(int32_t)</code> except that a description of the error is returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strict</em>&nbsp;</td><td>Should strict checking be done, or just enough to verify that things are OK for reading. No packet failing strict checking should ever be sent out, but it may be useful to disable strict checking when reading in a packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Verifies that the length of the packet matches this value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty string ("") if it is valid, a description of the error otherwise. </dd></dl>

<p>Reimplemented from <a class="el" href="classvrt_1_1BasicVRTPacket.html#a0f09daf0899cc4d9d069ecdfeaea0a0c">vrt::BasicVRTPacket</a>.</p>

<p>Reimplemented in <a class="el" href="classvrt_1_1StandardDataPacket.html#ad8162920cb8afb64b6dcd5209dd5e953">vrt::StandardDataPacket</a>, and <a class="el" href="classvrt_1_1NoDataPacket.html#a37cd51914b5eda5cfc98cdcdba5f0918">vrt::NoDataPacket</a>.</p>

</div>
</div>
<a class="anchor" id="a218104e7d259c4e852254d65e304e3f8"></a><!-- doxytag: member="vrt::BasicDataPacket::getPayloadFormat" ref="a218104e7d259c4e852254d65e304e3f8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> vrt::BasicDataPacket::getPayloadFormat </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the assumed payload format used when interacting with the data in this packet. </p>
<p>This setting can either be fixed based on the packet class or set via <a class="el" href="classvrt_1_1BasicDataPacket.html#a93c2d36ed6000364254d48b93dcaa771">setPayloadFormat</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The payload format to assume when interacting with this packet. This will return null if the payload format appears unspecified for this packet class and no call to <a class="el" href="classvrt_1_1BasicDataPacket.html#a93c2d36ed6000364254d48b93dcaa771">setPayloadFormat</a> has been made. </dd></dl>

<p>Reimplemented in <a class="el" href="classvrt_1_1StandardDataPacket.html#aafa6149cc97f84bb2af44349caa20d75">vrt::StandardDataPacket</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l00935">getData()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01148">getDataByte()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00983">getDataDouble()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01016">getDataFloat()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01082">getDataInt()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00504">getDataLength()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01049">getDataLong()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01115">getDataShort()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00584">getLostBytes()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00545">getNextTimeStamp()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00479">getScalarDataLength()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01411">setData()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01611">setDataByte()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01456">setDataDouble()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01487">setDataFloat()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01549">setDataInt()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00623">setDataLength()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01518">setDataLong()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01580">setDataShort()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00598">setScalarDataLength()</a>.</p>

</div>
</div>
<a class="anchor" id="a72cb464bdcef67285e87fb208d7d267c"></a><!-- doxytag: member="vrt::BasicDataPacket::getScalarDataLength" ref="a72cb464bdcef67285e87fb208d7d267c" args="(const PayloadFormat &amp;pf) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicDataPacket::getScalarDataLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Utility method:</em> Gets the length of the data in number of scalar elements. </p>
<p>Unlike <code><a class="el" href="classvrt_1_1BasicVRTPacket.html#a408e5bbadcd6099619e264a412223c36" title="Gets the payload length in bytes.">getPayloadLength()</a></code> this returns the number of data elements, not bytes. For complex data the real and imaginary components of a single value count as a two elements (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ade26b4b982fd93adf72f752cd93bf732">getDataLength()</a>). <br/>
 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of elements in the payload. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00504">getDataLength()</a>.</p>

</div>
</div>
<a class="anchor" id="a93844600fe4d42f517b585bed68bdd8e"></a><!-- doxytag: member="vrt::BasicDataPacket::getScalarDataLength" ref="a93844600fe4d42f517b585bed68bdd8e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicDataPacket::getScalarDataLength </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Utility method:</em> Gets the length of the data in number of scalar elements. </p>
<p>Unlike <code><a class="el" href="classvrt_1_1BasicVRTPacket.html#a408e5bbadcd6099619e264a412223c36" title="Gets the payload length in bytes.">getPayloadLength()</a></code> this returns the number of data elements, not bytes. For complex data the real and imaginary components of a single value count as a two elements (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ade26b4b982fd93adf72f752cd93bf732">getDataLength()</a>). <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.getScalarDataLength(p.getPayloadFormat())</code> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of elements in the payload. </dd></dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00504">getDataLength()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l00883">getDataByte()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00723">getDataDouble()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00755">getDataFloat()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00819">getDataInt()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00787">getDataLong()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00851">getDataShort()</a>.</p>

</div>
</div>
<a class="anchor" id="a95ec9b3fc553ea59a173163d9257c432"></a><!-- doxytag: member="vrt::BasicDataPacket::getStartStopIndication" ref="a95ec9b3fc553ea59a173163d9257c432" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StartStopIndication vrt::BasicDataPacket::getStartStopIndication </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the Sample Frame StartStopIndication value. </p>
<p>Bits 11..10 and accompanying enable bits 23..22 are used together as the two-bit StartStopIndication for Data Packets using Sample Frames. The following values are possible: 00 StartStopIndication_NA 01 StartStopIndication_First 10 StartStopIndication_Middle 11 StartStopIndication_Final When either trailer is not present or enable bits are not set, StartStopIndication_NA is returned. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>StartStopIndication value if the enable bits are set, or StartStopIndication_NA if not. </dd></dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00279">isBit10()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00272">isBit11()</a>.</p>

</div>
</div>
<a class="anchor" id="a42f6521ae94c54f511316f7456cdbc8a"></a><!-- doxytag: member="vrt::BasicDataPacket::getTrailer" ref="a42f6521ae94c54f511316f7456cdbc8a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicDataPacket::getTrailer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the trailer as an integer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>null if there is no trailer, an integer representing the trailer if there is. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ab6592343f5322fd56ed2287f09fa02"></a><!-- doxytag: member="vrt::BasicDataPacket::getTrailerBit" ref="a2ab6592343f5322fd56ed2287f09fa02" args="(int32_t enable, int32_t indicator) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolNull vrt::BasicDataPacket::getTrailerBit </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>indicator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the specified bit from the trailer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>Bit position of the enable flag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indicator</em>&nbsp;</td><td>Bit position of the indicator flag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>null if there is no trailer, null if the enable bit is not set, true if the enable bit is set and the indicator bit is set, false if the enable bit is set but the indicator bit is not set. </dd></dl>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l00213">isAutomaticGainControl()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00279">isBit10()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00272">isBit11()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00293">isBit8()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00286">isBit9()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00178">isCalibratedTimeStamp()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00191">isDataValid()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00262">isDiscontinuous()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00238">isInvertedSpectrum()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00250">isOverRange()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00202">isReferenceLocked()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00226">isSignalDetected()</a>.</p>

</div>
</div>
<a class="anchor" id="adb5accb8fe2fe0833000d0baab62fcd9"></a><!-- doxytag: member="vrt::BasicDataPacket::isAutomaticGainControl" ref="adb5accb8fe2fe0833000d0baab62fcd9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolNull vrt::BasicDataPacket::isAutomaticGainControl </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the AGC/MGC indicator flag. </p>
<pre>
    true  = AGC (automatic gain control) is being used
    false = MGC (manual gain control) is being used
    null  = <em>This information is not available</em>
  </pre> <dl class="return"><dt><b>Returns:</b></dt><dd>true if the flag is set, false if it is not set, null if this optional flag isn't specified (null is returned for all context packets). </dd></dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a2ab6592343f5322fd56ed2287f09fa02">getTrailerBit()</a>.</p>

</div>
</div>
<a class="anchor" id="a7f9b875caf23be5c8572b2cd55612821"></a><!-- doxytag: member="vrt::BasicDataPacket::isBit10" ref="a7f9b875caf23be5c8572b2cd55612821" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolNull vrt::BasicDataPacket::isBit10 </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the #10 user-defined indicator flag. </p>
<p><em>The definition of this flag should be included in the documentation for the relevant packet class (this flag should be identified there as "Enable Bit Position 22" and/or "Indicator Bit Position 10").</em> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the flag is set, false if it is not set, null if the flag isn't specified. </dd></dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a2ab6592343f5322fd56ed2287f09fa02">getTrailerBit()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l00314">getStartStopIndication()</a>.</p>

</div>
</div>
<a class="anchor" id="a3369b55e7c3ba19c0b23a727bb7c8d9b"></a><!-- doxytag: member="vrt::BasicDataPacket::isBit11" ref="a3369b55e7c3ba19c0b23a727bb7c8d9b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolNull vrt::BasicDataPacket::isBit11 </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the #11 user-defined indicator flag. </p>
<p><em>The definition of this flag should be included in the documentation for the relevant packet class (this flag should be identified there as "Enable Bit Position 23" and/or "Indicator Bit Position 11").</em> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the flag is set, false if it is not set, null if the flag isn't specified. </dd></dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a2ab6592343f5322fd56ed2287f09fa02">getTrailerBit()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l00314">getStartStopIndication()</a>.</p>

</div>
</div>
<a class="anchor" id="aacc728fe6a81708be3350a2a4f00eee7"></a><!-- doxytag: member="vrt::BasicDataPacket::isBit8" ref="aacc728fe6a81708be3350a2a4f00eee7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolNull vrt::BasicDataPacket::isBit8 </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the #8 user-defined indicator flag. </p>
<p><em>The definition of this flag should be included in the documentation for the relevant packet class (this flag should be identified there as "Enable Bit Position 20" and/or "Indicator Bit Position 8").</em> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the flag is set, false if it is not set, null if the flag isn't specified. </dd></dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a2ab6592343f5322fd56ed2287f09fa02">getTrailerBit()</a>.</p>

</div>
</div>
<a class="anchor" id="a28f29544e95668bbb0b1597d9aa8c6e6"></a><!-- doxytag: member="vrt::BasicDataPacket::isBit9" ref="a28f29544e95668bbb0b1597d9aa8c6e6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolNull vrt::BasicDataPacket::isBit9 </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the #9 user-defined indicator flag. </p>
<p><em>The definition of this flag should be included in the documentation for the relevant packet class (this flag should be identified there as "Enable Bit Position 21" and/or "Indicator Bit Position 9").</em> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the flag is set, false if it is not set, null if the flag isn't specified. </dd></dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a2ab6592343f5322fd56ed2287f09fa02">getTrailerBit()</a>.</p>

</div>
</div>
<a class="anchor" id="ac1bb6a09c023fb271fdf9079f1b6498e"></a><!-- doxytag: member="vrt::BasicDataPacket::isCalibratedTimeStamp" ref="ac1bb6a09c023fb271fdf9079f1b6498e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolNull vrt::BasicDataPacket::isCalibratedTimeStamp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the calibrated time indicator flag. </p>
<pre>
    true  = The time stamp in this packet is calibrated to an external reference (e.g. atomic clock)
    false = The time stamp in this packet is *not* calibrated to an external reference
            and may be inaccurate
    null  = <em>This information is not available</em>
  </pre> <dl class="return"><dt><b>Returns:</b></dt><dd>true if the flag is set, false if it is not set, null if this optional flag isn't specified (null is returned for all context packets). </dd></dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a2ab6592343f5322fd56ed2287f09fa02">getTrailerBit()</a>.</p>

</div>
</div>
<a class="anchor" id="ada6fc402de5a89ed904d54547669043f"></a><!-- doxytag: member="vrt::BasicDataPacket::isDataValid" ref="ada6fc402de5a89ed904d54547669043f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolNull vrt::BasicDataPacket::isDataValid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the valid data indicator flag. </p>
<pre>
    true  = The data in the packet is valid
    false = A condition exists that *may* invalidate some or all of the data in the packet
    null  = <em>This information is not available</em>
  </pre><p> <em>Note that the definition of "valid" and "invalid" data is application specific, so it is important to consult the documentation for the relevant packet class before using this field.</em> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the flag is set, false if it is not set, null if this optional flag isn't specified (null is returned for all context packets). </dd></dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a2ab6592343f5322fd56ed2287f09fa02">getTrailerBit()</a>.</p>

</div>
</div>
<a class="anchor" id="a06600940399ba8b27417dea57be45f88"></a><!-- doxytag: member="vrt::BasicDataPacket::isDiscontinuious" ref="a06600940399ba8b27417dea57be45f88" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolNull vrt::BasicDataPacket::isDiscontinuious </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Deprecated:</b> Please change to using <code>isDiscontinuous</code>. </p>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00262">isDiscontinuous()</a>.</p>

</div>
</div>
<a class="anchor" id="a1682d935b0b11f52a6e05531d89ad1d0"></a><!-- doxytag: member="vrt::BasicDataPacket::isDiscontinuous" ref="a1682d935b0b11f52a6e05531d89ad1d0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolNull vrt::BasicDataPacket::isDiscontinuous </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the sample loss indicator flag. </p>
<pre>
    true  = One or more sample discontinuities present in the data due to processing errors
            and/or data overflow
    false = No discontinuities present
    null  = <em>This information is not available</em>
  </pre> <dl class="return"><dt><b>Returns:</b></dt><dd>true if the flag is set, false if it is not set, null if this optional flag isn't specified (null is returned for all context packets). </dd></dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a2ab6592343f5322fd56ed2287f09fa02">getTrailerBit()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l00265">isDiscontinuious()</a>.</p>

</div>
</div>
<a class="anchor" id="aa79a316018f1588d99834886429c546e"></a><!-- doxytag: member="vrt::BasicDataPacket::isInvertedSpectrum" ref="aa79a316018f1588d99834886429c546e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolNull vrt::BasicDataPacket::isInvertedSpectrum </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the spectral inversion indicator flag. </p>
<pre>
    true  = Signal conveyed in the payload has an inverted spectrum w.r.t. an up-stream
            reference point
    false = Spectrum is not inverted
    null  = <em>This information is not available</em>
  </pre> <dl class="return"><dt><b>Returns:</b></dt><dd>true if the flag is set, false if it is not set, null if this optional flag isn't specified (null is returned for all context packets). </dd></dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a2ab6592343f5322fd56ed2287f09fa02">getTrailerBit()</a>.</p>

</div>
</div>
<a class="anchor" id="a83779d142c204e0a6d3ca50b7a4949ee"></a><!-- doxytag: member="vrt::BasicDataPacket::isOverRange" ref="a83779d142c204e0a6d3ca50b7a4949ee" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolNull vrt::BasicDataPacket::isOverRange </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the over-range indicator flag. </p>
<pre>
    true  = The data in the payload is invalid since one or more data samples exceeded the
            range of the data item
    false = No samples over range
    null  = <em>This information is not available</em>
  </pre> <dl class="return"><dt><b>Returns:</b></dt><dd>true if the flag is set, false if it is not set, null if this optional flag isn't specified (null is returned for all context packets). </dd></dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a2ab6592343f5322fd56ed2287f09fa02">getTrailerBit()</a>.</p>

</div>
</div>
<a class="anchor" id="a6f66c6170e11e007cad9315861159dd0"></a><!-- doxytag: member="vrt::BasicDataPacket::isReferenceLocked" ref="a6f66c6170e11e007cad9315861159dd0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolNull vrt::BasicDataPacket::isReferenceLocked </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the reference lock indicator flag. </p>
<pre>
    true  = All of the phase-locked loops affecting the data are locked and stable
    false = At least one of the phase-locked loops affecting the data is not locked and stable
    null  = <em>This information is not available</em>
  </pre> <dl class="return"><dt><b>Returns:</b></dt><dd>true if the flag is set, false if it is not set, null if this optional flag isn't specified (null is returned for all context packets). </dd></dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a2ab6592343f5322fd56ed2287f09fa02">getTrailerBit()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c60bc192353abee3ece1b938a773400"></a><!-- doxytag: member="vrt::BasicDataPacket::isSignalDetected" ref="a7c60bc192353abee3ece1b938a773400" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolNull vrt::BasicDataPacket::isSignalDetected </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the signal detected indicator flag. </p>
<pre>
    true  = Some signal detected in this packet
    false = No signal detected in this packet
    null  = <em>This information is not available</em>
  </pre><p> <em>Note that the definition of what constitutes a detected signal application specific, so it is important to conslut the documentation for the relevant packet class before using this field.</em> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the flag is set, false if it is not set, null if this optional flag isn't specified (null is returned for all context packets). </dd></dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a2ab6592343f5322fd56ed2287f09fa02">getTrailerBit()</a>.</p>

</div>
</div>
<a class="anchor" id="ae4ff7e66dc722b764586b76f20e1d06e"></a><!-- doxytag: member="vrt::BasicDataPacket::setAssocPacketCount" ref="ae4ff7e66dc722b764586b76f20e1d06e" args="(int8_t v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setAssocPacketCount </td>
          <td>(</td>
          <td class="paramtype">int8_t&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Gets the associated packet count. </p>
<p>This indicates the number of context packets with context change or event information relevant to this data packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The associated packet count (0..127), or null if not specified. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9eebebcbc89f8fb82409fb5ac5b55e84"></a><!-- doxytag: member="vrt::BasicDataPacket::setAutomaticGainControl" ref="a9eebebcbc89f8fb82409fb5ac5b55e84" args="(boolNull v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setAutomaticGainControl </td>
          <td>(</td>
          <td class="paramtype">boolNull&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Gets the AGC/MGC indicator flag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>true if the flag is set, false if not set, null if this optional flag isn't specified. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a610c04accba684228dd36a363285fbfe">setTrailerBit()</a>.</p>

</div>
</div>
<a class="anchor" id="ab4e2ffbc35e531b5fbf4731552043e6f"></a><!-- doxytag: member="vrt::BasicDataPacket::setBit10" ref="ab4e2ffbc35e531b5fbf4731552043e6f" args="(boolNull v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setBit10 </td>
          <td>(</td>
          <td class="paramtype">boolNull&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Gets the #10 user-defined indicator flag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>true if the flag is set, false if not set, null if the flag isn't specified. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a610c04accba684228dd36a363285fbfe">setTrailerBit()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l00427">setStartStopIndication()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00441">unsetStartStopIndication()</a>.</p>

</div>
</div>
<a class="anchor" id="a847c7b5466bf637ba2f6cf4399926c5e"></a><!-- doxytag: member="vrt::BasicDataPacket::setBit11" ref="a847c7b5466bf637ba2f6cf4399926c5e" args="(boolNull v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setBit11 </td>
          <td>(</td>
          <td class="paramtype">boolNull&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Gets the #11 user-defined indicator flag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>true if the flag is set, false if not set, null if the flag isn't specified. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a610c04accba684228dd36a363285fbfe">setTrailerBit()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l00427">setStartStopIndication()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00441">unsetStartStopIndication()</a>.</p>

</div>
</div>
<a class="anchor" id="a6ac3348bafc67fcdd9e35de478a4f398"></a><!-- doxytag: member="vrt::BasicDataPacket::setBit8" ref="a6ac3348bafc67fcdd9e35de478a4f398" args="(boolNull v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setBit8 </td>
          <td>(</td>
          <td class="paramtype">boolNull&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Gets the #8 user-defined indicator flag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>true if the flag is set, false if not set, null if the flag isn't specified. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a610c04accba684228dd36a363285fbfe">setTrailerBit()</a>.</p>

</div>
</div>
<a class="anchor" id="a4b04b626d662243a1570155cfd6960e1"></a><!-- doxytag: member="vrt::BasicDataPacket::setBit9" ref="a4b04b626d662243a1570155cfd6960e1" args="(boolNull v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setBit9 </td>
          <td>(</td>
          <td class="paramtype">boolNull&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Gets the #9 user-defined indicator flag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>true if the flag is set, false if not set, null if the flag isn't specified. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a610c04accba684228dd36a363285fbfe">setTrailerBit()</a>.</p>

</div>
</div>
<a class="anchor" id="a41cdda58aaeb597bb43251d271becbf3"></a><!-- doxytag: member="vrt::BasicDataPacket::setCalibratedTimeStamp" ref="a41cdda58aaeb597bb43251d271becbf3" args="(boolNull v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setCalibratedTimeStamp </td>
          <td>(</td>
          <td class="paramtype">boolNull&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets the calibrated time indicator flag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>true if the flag is set, false if not set, null if this optional flag isn't specified. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a610c04accba684228dd36a363285fbfe">setTrailerBit()</a>.</p>

</div>
</div>
<a class="anchor" id="aaa81b254acedf691984a7aa007a2cf8f"></a><!-- doxytag: member="vrt::BasicDataPacket::setData" ref="aaa81b254acedf691984a7aa007a2cf8f" args="(const void *array, int32_t length, bool convert=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setData </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>convert</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data from a native byte buffer. </p>
<p>This is basically a byte-for-byte copy of the payload, except that a conversion is done from the native to <code>BIG_ENDIAN</code> byte ordering. This method is intended for use within existing programming frameworks that already provide type conversions. <b>This method does not convert the values from byte data, only copies the data from what is effectively a <code>void*</code> buffer in the native byte order.</b> <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.setData(p.getPayloadFormat(),array,offset,length)</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The array to insert the data into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of bytes to pack (must be a multiple of 8 for <code>PayloadFormat_INT64</code> or <code>PayloadFormat_DOUBLE64</code> or a multiple of 4 for all others). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>convert</em>&nbsp;</td><td>Convert byte order to match native representation? Set this to false if it is necessary to keep the data in big-endian format. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null or if the array is null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is anything other than </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is anything other than <code>PayloadFormat_INT4</code>, <code>PayloadFormat_INT8</code>, <code>PayloadFormat_INT16</code>, <code>PayloadFormat_INT32</code>, <code>PayloadFormat_INT64</code>, <code>PayloadFormat_FLOAT32</code>, <code>PayloadFormat_DOUBLE64</code> <code>PayloadFormat_UINT1</code>, <code>PayloadFormat_UINT4</code>, <code>PayloadFormat_UINT8</code>, <code>PayloadFormat_UINT16</code>, <code>PayloadFormat_UINT32</code>, <code>PayloadFormat_UINT64</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the array length is shorter than <code>offset+getPayloadLength()</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the length is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l01192">setData()</a>.</p>

</div>
</div>
<a class="anchor" id="a00ee035dea1ec9bdb3bccddf1be6ebf7"></a><!-- doxytag: member="vrt::BasicDataPacket::setData" ref="a00ee035dea1ec9bdb3bccddf1be6ebf7" args="(const vector&lt; char &gt; &amp;array, size_t offset, int32_t length, bool convert=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setData </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>convert</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data from a native byte buffer. </p>
<p>This is basically a byte-for-byte copy of the payload, except that a conversion is done from the native to <code>BIG_ENDIAN</code> byte ordering. This method is intended for use within existing programming frameworks that already provide type conversions. <b>This method does not convert the values from byte data, only copies the data from what is effectively a <code>void*</code> buffer in the native byte order.</b> <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.setData(p.getPayloadFormat(),array,offset,length)</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The array to insert the data into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The array offset. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of bytes to pack (must be a multiple of 8 for <code>PayloadFormat_INT64</code> or <code>PayloadFormat_DOUBLE64</code> or a multiple of 4 for all others). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>convert</em>&nbsp;</td><td>Convert byte order to match native representation? Set this to false if it is necessary to keep the data in big-endian format. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null or if the array is null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is anything other than <code>PayloadFormat_INT4</code>, <code>PayloadFormat_INT8</code>, <code>PayloadFormat_INT16</code>, <code>PayloadFormat_INT32</code>, <code>PayloadFormat_INT64</code>, <code>PayloadFormat_FLOAT32</code>, <code>PayloadFormat_DOUBLE64</code> <code>PayloadFormat_UINT1</code>, <code>PayloadFormat_UINT4</code>, <code>PayloadFormat_UINT8</code>, <code>PayloadFormat_UINT16</code>, <code>PayloadFormat_UINT32</code>, <code>PayloadFormat_UINT64</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the array length is shorter than <code>offset+getPayloadLength()</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the length is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l01192">setData()</a>.</p>

</div>
</div>
<a class="anchor" id="ab7ee9ff782f0248207e18d7af47fa4ae"></a><!-- doxytag: member="vrt::BasicDataPacket::setData" ref="ab7ee9ff782f0248207e18d7af47fa4ae" args="(const PayloadFormat &amp;pf, const void *array, int32_t length, bool convert=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>convert</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data from a native byte buffer. </p>
<p>This is basically a byte-for-byte copy of the payload, except that a conversion is done from the native to <code>BIG_ENDIAN</code> byte ordering. This method is intended for use within existing programming frameworks that already provide type conversions. <b>This method does not convert the values from byte data, only copies the data from what is effectively a <code>void*</code> buffer in the native byte order.</b> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The array to insert the data into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of bytes to pack (must be a multiple of 8 for <code>PayloadFormat_INT64</code> or <code>PayloadFormat_DOUBLE64</code> or a multiple of 4 for all others). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>convert</em>&nbsp;</td><td>Convert byte order to match native representation? Set this to false if it is necessary to keep the data in big-endian format. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null or if the array is null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is anything other than <code>PayloadFormat_INT4</code>, <code>PayloadFormat_INT8</code>, <code>PayloadFormat_INT16</code>, <code>PayloadFormat_INT32</code>, <code>PayloadFormat_INT64</code>, <code>PayloadFormat_FLOAT32</code>, <code>PayloadFormat_DOUBLE64</code> <code>PayloadFormat_UINT1</code>, <code>PayloadFormat_UINT4</code>, <code>PayloadFormat_UINT8</code>, <code>PayloadFormat_UINT16</code>, <code>PayloadFormat_UINT32</code>, <code>PayloadFormat_UINT64</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the length is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50b76b2105b9cf525f04bb21873f67d2"></a><!-- doxytag: member="vrt::BasicDataPacket::setData" ref="a50b76b2105b9cf525f04bb21873f67d2" args="(const PayloadFormat &amp;pf, const vector&lt; char &gt; &amp;array, size_t offset, int32_t length, bool convert=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>convert</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data from a native byte buffer. </p>
<p>This is basically a byte-for-byte copy of the payload, except that a conversion is done from the native to <code>BIG_ENDIAN</code> byte ordering. This method is intended for use within existing programming frameworks that already provide type conversions. <b>This method does not convert the values from byte data, only copies the data from what is effectively a <code>void*</code> buffer in the native byte order.</b> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The array to insert the data into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The array offset. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of bytes to pack (must be a multiple of 8 for <code>PayloadFormat_INT64</code> or <code>PayloadFormat_DOUBLE64</code> or a multiple of 4 for all others). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>convert</em>&nbsp;</td><td>Convert byte order to match native representation? Set this to false if it is necessary to keep the data in big-endian format. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null or if the array is null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is anything other than <code>PayloadFormat_INT4</code>, <code>PayloadFormat_INT8</code>, <code>PayloadFormat_INT16</code>, <code>PayloadFormat_INT32</code>, <code>PayloadFormat_INT64</code>, <code>PayloadFormat_FLOAT32</code>, <code>PayloadFormat_DOUBLE64</code> <code>PayloadFormat_UINT1</code>, <code>PayloadFormat_UINT4</code>, <code>PayloadFormat_UINT8</code>, <code>PayloadFormat_UINT16</code>, <code>PayloadFormat_UINT32</code>, <code>PayloadFormat_UINT64</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the array length is shorter than <code>offset+getPayloadLength()</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the length is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00619">vrt::BasicVRTPacket::getPayloadLength()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l01411">setData()</a>.</p>

</div>
</div>
<a class="anchor" id="ae8648406e9de7584268ed4cbb4e418c5"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataByte" ref="ae8648406e9de7584268ed4cbb4e418c5" args="(const vector&lt; int8_t &gt; &amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataByte </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int8_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a byte array. </p>
<p>If the underlying data is not byte, it will be converted from byte and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.setDataByte(p.getPayloadFormat(),array)</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l01365">setDataByte()</a>.</p>

</div>
</div>
<a class="anchor" id="a34e1e6c3b2c9449f449bc14e8eeb7a3c"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataByte" ref="a34e1e6c3b2c9449f449bc14e8eeb7a3c" args="(const int8_t *array, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataByte </td>
          <td>(</td>
          <td class="paramtype">const int8_t *&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a byte array. </p>
<p>If the underlying data is not byte, it will be converted from byte and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.setDataByte(p.getPayloadFormat(),array)</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the array (in number of scalar values). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l01365">setDataByte()</a>.</p>

</div>
</div>
<a class="anchor" id="ab1576f73cf98cf705003250a756e76d5"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataByte" ref="ab1576f73cf98cf705003250a756e76d5" args="(const PayloadFormat &amp;pf, const vector&lt; int8_t &gt; &amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataByte </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int8_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a byte array. </p>
<p>If the underlying data is not byte, it will be converted from byte and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="namespacevrt_1_1PackUnpack.html#a3fb439c6c695d3e76e6597690b3b29de">vrt::PackUnpack::packAsByte()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00598">setScalarDataLength()</a>.</p>

</div>
</div>
<a class="anchor" id="a41106ff8e3e3503ccbbe4881bcac2b7f"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataByte" ref="a41106ff8e3e3503ccbbe4881bcac2b7f" args="(const PayloadFormat &amp;pf, const int8_t *array, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataByte </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a byte array. </p>
<p>If the underlying data is not byte, it will be converted from byte and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the array (in number of scalar values). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="namespacevrt_1_1PackUnpack.html#a3fb439c6c695d3e76e6597690b3b29de">vrt::PackUnpack::packAsByte()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00598">setScalarDataLength()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l01611">setDataByte()</a>.</p>

</div>
</div>
<a class="anchor" id="a27001cc502eae809f9945721cb84c3c5"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataDouble" ref="a27001cc502eae809f9945721cb84c3c5" args="(const vector&lt; double &gt; &amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataDouble </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a double array. </p>
<p>If the underlying data is not double, it will be converted from double and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.setDataDouble(p.getPayloadFormat(),array)</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l01230">setDataDouble()</a>.</p>

</div>
</div>
<a class="anchor" id="a265b1f06283c8f327b99394cb9cff470"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataDouble" ref="a265b1f06283c8f327b99394cb9cff470" args="(const double *array, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataDouble </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a double array. </p>
<p>If the underlying data is not double, it will be converted from double and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.setDataByte(p.getPayloadFormat(),array)</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the array (in number of scalar values). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l01230">setDataDouble()</a>.</p>

</div>
</div>
<a class="anchor" id="a46f23a25acca5a486aef41c49b035ed8"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataDouble" ref="a46f23a25acca5a486aef41c49b035ed8" args="(const PayloadFormat &amp;pf, const vector&lt; double &gt; &amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataDouble </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a double array. </p>
<p>If the underlying data is not double, it will be converted from double and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="namespacevrt_1_1PackUnpack.html#a0f714568028ae4acb8dd8f79995dc533">vrt::PackUnpack::packAsDouble()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00598">setScalarDataLength()</a>.</p>

</div>
</div>
<a class="anchor" id="a37597b467a770f011f2e57715773b080"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataDouble" ref="a37597b467a770f011f2e57715773b080" args="(const PayloadFormat &amp;pf, const double *array, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataDouble </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a double array. </p>
<p>If the underlying data is not double, it will be converted from double and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the array (in number of scalar values). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="namespacevrt_1_1PackUnpack.html#a0f714568028ae4acb8dd8f79995dc533">vrt::PackUnpack::packAsDouble()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00598">setScalarDataLength()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l01456">setDataDouble()</a>.</p>

</div>
</div>
<a class="anchor" id="a9b8c714eb8400c9885218ff9707fdf77"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataFloat" ref="a9b8c714eb8400c9885218ff9707fdf77" args="(const vector&lt; float &gt; &amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataFloat </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a float array. </p>
<p>If the underlying data is not float, it will be converted from float and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.setDataFloat(p.getPayloadFormat(),array)</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l01257">setDataFloat()</a>.</p>

</div>
</div>
<a class="anchor" id="a79a7c251b4685fbc2edb66c6835b78b2"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataFloat" ref="a79a7c251b4685fbc2edb66c6835b78b2" args="(const float *array, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataFloat </td>
          <td>(</td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a float array. </p>
<p>If the underlying data is not float, it will be converted from float and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.setDataByte(p.getPayloadFormat(),array)</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the array (in number of scalar values). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l01257">setDataFloat()</a>.</p>

</div>
</div>
<a class="anchor" id="ab92a5bd661b92d8a125dad6dc9aee00a"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataFloat" ref="ab92a5bd661b92d8a125dad6dc9aee00a" args="(const PayloadFormat &amp;pf, const vector&lt; float &gt; &amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataFloat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a float array. </p>
<p>If the underlying data is not float, it will be converted from float and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="namespacevrt_1_1PackUnpack.html#a8beba71648d285daea2168ba6fba4105">vrt::PackUnpack::packAsFloat()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00598">setScalarDataLength()</a>.</p>

</div>
</div>
<a class="anchor" id="a9340ee881305f9749844f8ca4a9fe1e3"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataFloat" ref="a9340ee881305f9749844f8ca4a9fe1e3" args="(const PayloadFormat &amp;pf, const float *array, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataFloat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a float array. </p>
<p>If the underlying data is not float, it will be converted from float and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the array (in number of scalar values). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="namespacevrt_1_1PackUnpack.html#a8beba71648d285daea2168ba6fba4105">vrt::PackUnpack::packAsFloat()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00598">setScalarDataLength()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l01487">setDataFloat()</a>.</p>

</div>
</div>
<a class="anchor" id="a5f18c458ece9fcbf22dcd6ad0105976a"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataInt" ref="a5f18c458ece9fcbf22dcd6ad0105976a" args="(const vector&lt; int32_t &gt; &amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataInt </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int32_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a int array. </p>
<p>If the underlying data is not int, it will be converted from int and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.setDataInt(p.getPayloadFormat(),array)</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l01311">setDataInt()</a>.</p>

</div>
</div>
<a class="anchor" id="a0fd50b1fdd6fdb5b056e9f1a89fd06c5"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataInt" ref="a0fd50b1fdd6fdb5b056e9f1a89fd06c5" args="(const int32_t *array, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataInt </td>
          <td>(</td>
          <td class="paramtype">const int32_t *&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a int array. </p>
<p>If the underlying data is not int, it will be converted from int and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.setDataByte(p.getPayloadFormat(),array)</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the array (in number of scalar values). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l01311">setDataInt()</a>.</p>

</div>
</div>
<a class="anchor" id="aef5530ea23fdac9e4d1b55b5a920654d"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataInt" ref="aef5530ea23fdac9e4d1b55b5a920654d" args="(const PayloadFormat &amp;pf, const vector&lt; int32_t &gt; &amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataInt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int32_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a int array. </p>
<p>If the underlying data is not int, it will be converted from int and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="namespacevrt_1_1PackUnpack.html#ac903e424a52302acbb9dac33eadf7805">vrt::PackUnpack::packAsInt()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00598">setScalarDataLength()</a>.</p>

</div>
</div>
<a class="anchor" id="a797aa9d37a91fdf251bc8452608a1adc"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataInt" ref="a797aa9d37a91fdf251bc8452608a1adc" args="(const PayloadFormat &amp;pf, const int32_t *array, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataInt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a int array. </p>
<p>If the underlying data is not int, it will be converted from int and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the array (in number of scalar values). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="namespacevrt_1_1PackUnpack.html#ac903e424a52302acbb9dac33eadf7805">vrt::PackUnpack::packAsInt()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00598">setScalarDataLength()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l01549">setDataInt()</a>.</p>

</div>
</div>
<a class="anchor" id="a9e6b623e1f1400d6a4896907399e5cd8"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataLength" ref="a9e6b623e1f1400d6a4896907399e5cd8" args="(const PayloadFormat &amp;pf, int32_t length, bool scalar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>scalar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the data length with option for scalar-only computation. </p>

</div>
</div>
<a class="anchor" id="af3c95c93878fbad899545e03c7d3539f"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataLength" ref="af3c95c93878fbad899545e03c7d3539f" args="(const PayloadFormat &amp;pf, int32_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the length of the data in number of elements. </p>
<p>Unlike <code>setPayloadLength(..)</code> this sets the number of data elements, not bytes. For complex data the real and imaginary components of a single value count as a single element (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a93844600fe4d42f517b585bed68bdd8e">getScalarDataLength()</a>). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of elements in the payload. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00623">setDataLength()</a>.</p>

</div>
</div>
<a class="anchor" id="ae80174a71d1d015e44a57e194e72fa84"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataLength" ref="ae80174a71d1d015e44a57e194e72fa84" args="(int32_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataLength </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the length of the data in number of elements. </p>
<p>Unlike <code>setPayloadLength(..)</code> this sets the number of data elements, not bytes. For complex data the real and imaginary components of a single value count as a single element (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a93844600fe4d42f517b585bed68bdd8e">getScalarDataLength()</a>). <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.getDataLength(p.getPayloadFormat())</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of elements in the payload. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l00634">setDataLength()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00598">setScalarDataLength()</a>.</p>

</div>
</div>
<a class="anchor" id="afaaa2c807ec5e5dfe48434efe3b61721"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataLong" ref="afaaa2c807ec5e5dfe48434efe3b61721" args="(const vector&lt; int64_t &gt; &amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataLong </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int64_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a long array. </p>
<p>If the underlying data is not long, it will be converted from long and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.setDataLong(p.getPayloadFormat(),array)</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l01284">setDataLong()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d279916d2d3cc17090cd88c826ec1ab"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataLong" ref="a2d279916d2d3cc17090cd88c826ec1ab" args="(const int64_t *array, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataLong </td>
          <td>(</td>
          <td class="paramtype">const int64_t *&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a long array. </p>
<p>If the underlying data is not long, it will be converted from long and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.setDataByte(p.getPayloadFormat(),array)</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the array (in number of scalar values). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l01284">setDataLong()</a>.</p>

</div>
</div>
<a class="anchor" id="a67bc24f2ccd64fc0d6938585f337e668"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataLong" ref="a67bc24f2ccd64fc0d6938585f337e668" args="(const PayloadFormat &amp;pf, const vector&lt; int64_t &gt; &amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataLong </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int64_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a long array. </p>
<p>If the underlying data is not long, it will be converted from long and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="namespacevrt_1_1PackUnpack.html#afa1e35b8810c0b46383a03fa3dd24a71">vrt::PackUnpack::packAsLong()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00598">setScalarDataLength()</a>.</p>

</div>
</div>
<a class="anchor" id="ab678888fde37ecd54db2f4f5d140322d"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataLong" ref="ab678888fde37ecd54db2f4f5d140322d" args="(const PayloadFormat &amp;pf, const int64_t *array, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataLong </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a long array. </p>
<p>If the underlying data is not long, it will be converted from long and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the array (in number of scalar values). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="namespacevrt_1_1PackUnpack.html#afa1e35b8810c0b46383a03fa3dd24a71">vrt::PackUnpack::packAsLong()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00598">setScalarDataLength()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l01518">setDataLong()</a>.</p>

</div>
</div>
<a class="anchor" id="aee0c386446f907b2da4abe8a5b443771"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataShort" ref="aee0c386446f907b2da4abe8a5b443771" args="(const vector&lt; int16_t &gt; &amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataShort </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int16_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a short array. </p>
<p>If the underlying data is not short, it will be converted from short and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.setDataShort(p.getPayloadFormat(),array)</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l01338">setDataShort()</a>.</p>

</div>
</div>
<a class="anchor" id="a62ebebcf6f267bee3cdd63eb71a2b35d"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataShort" ref="a62ebebcf6f267bee3cdd63eb71a2b35d" args="(const int16_t *array, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataShort </td>
          <td>(</td>
          <td class="paramtype">const int16_t *&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a short array. </p>
<p>If the underlying data is not short, it will be converted from short and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.setDataByte(p.getPayloadFormat(),array)</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the array (in number of scalar values). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l01338">setDataShort()</a>.</p>

</div>
</div>
<a class="anchor" id="a387f44eb2c048de551caf178298e7408"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataShort" ref="a387f44eb2c048de551caf178298e7408" args="(const PayloadFormat &amp;pf, const vector&lt; int16_t &gt; &amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataShort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int16_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a short array. </p>
<p>If the underlying data is not short, it will be converted from short and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="namespacevrt_1_1PackUnpack.html#a59cdc14c78c6259cf9e40208413aebfe">vrt::PackUnpack::packAsShort()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00598">setScalarDataLength()</a>.</p>

</div>
</div>
<a class="anchor" id="ada92f3f98c76e10c9c928e449196bc8b"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataShort" ref="ada92f3f98c76e10c9c928e449196bc8b" args="(const PayloadFormat &amp;pf, const int16_t *array, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataShort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t *&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs the data using the values from a short array. </p>
<p>If the underlying data is not short, it will be converted from short and any values that fall outside of the range of a of the payload format will have unpredictable output. This method also has the effect of setting the size of the data (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">setDataLength</a>) and indirectly the payload and packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>The values to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the array (in number of scalar values). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">vrt::BasicVRTPacket::bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">vrt::BasicVRTPacket::getPrologueLength()</a>, <a class="el" href="namespacevrt_1_1PackUnpack.html#a59cdc14c78c6259cf9e40208413aebfe">vrt::PackUnpack::packAsShort()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00598">setScalarDataLength()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l01580">setDataShort()</a>.</p>

</div>
</div>
<a class="anchor" id="a93d6e17bb22fd281f8cc37dc18c6bece"></a><!-- doxytag: member="vrt::BasicDataPacket::setDataValid" ref="a93d6e17bb22fd281f8cc37dc18c6bece" args="(boolNull v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDataValid </td>
          <td>(</td>
          <td class="paramtype">boolNull&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Gets the valid data indicator flag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>true if the flag is set, false if not set, null if this optional flag isn't specified. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a610c04accba684228dd36a363285fbfe">setTrailerBit()</a>.</p>

</div>
</div>
<a class="anchor" id="a6f10d443f5dd551422c918b0032d69a7"></a><!-- doxytag: member="vrt::BasicDataPacket::setDiscontinuious" ref="a6f10d443f5dd551422c918b0032d69a7" args="(boolNull v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDiscontinuious </td>
          <td>(</td>
          <td class="paramtype">boolNull&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Deprecated:</b> Please change to using <code>setDiscontinuous</code>. </p>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00379">setDiscontinuous()</a>.</p>

</div>
</div>
<a class="anchor" id="af58c6ae90f42bfa58abf856295623516"></a><!-- doxytag: member="vrt::BasicDataPacket::setDiscontinuous" ref="af58c6ae90f42bfa58abf856295623516" args="(boolNull v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setDiscontinuous </td>
          <td>(</td>
          <td class="paramtype">boolNull&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Gets the sample loss indicator flag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>true if the flag is set, false if not set, null if this optional flag isn't specified. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a610c04accba684228dd36a363285fbfe">setTrailerBit()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l00382">setDiscontinuious()</a>.</p>

</div>
</div>
<a class="anchor" id="a26d23feba544bbcf35f14a38a5765d86"></a><!-- doxytag: member="vrt::BasicDataPacket::setField" ref="a26d23feba544bbcf35f14a38a5765d86" args="(int32_t id, const Value *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::BasicDataPacket::setField </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1Value.html">Value</a> *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the value of a field, based on the field's id. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>The field ID (on range <code>[0,<a class="el" href="classvrt_1_1BasicDataPacket.html#ad0c765c6f4e0807af2b42b92e9bc4526" title="Gets the number of fields.">getFieldCount()</a>)</code>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Pointer to the given value (must be of the applicable type). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classvrt_1_1BasicVRTPacket.html#a832f112f8f1b4f4b6bbb117af7a7239e">vrt::BasicVRTPacket</a>.</p>

<p>Reimplemented in <a class="el" href="classvrt_1_1NoDataPacket.html#a5d3ae8b1dbd5eb2708a62190e5fdd032">vrt::NoDataPacket</a>.</p>

</div>
</div>
<a class="anchor" id="aeed461ab329054bbeedd18af2a6cb7f9"></a><!-- doxytag: member="vrt::BasicDataPacket::setInvertedSpectrum" ref="aeed461ab329054bbeedd18af2a6cb7f9" args="(boolNull v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setInvertedSpectrum </td>
          <td>(</td>
          <td class="paramtype">boolNull&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Gets the spectral inversion indicator flag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>true if the flag is set, false if not set, null if this optional flag isn't specified. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a610c04accba684228dd36a363285fbfe">setTrailerBit()</a>.</p>

</div>
</div>
<a class="anchor" id="ad2f482071e0b529f027e2d3265f251eb"></a><!-- doxytag: member="vrt::BasicDataPacket::setOverRange" ref="ad2f482071e0b529f027e2d3265f251eb" args="(boolNull v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setOverRange </td>
          <td>(</td>
          <td class="paramtype">boolNull&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Gets the over-range indicator flag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>true if the flag is set, false if not set, null if this optional flag isn't specified. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a610c04accba684228dd36a363285fbfe">setTrailerBit()</a>.</p>

</div>
</div>
<a class="anchor" id="af947fca253c101a6a97709c970e10a37"></a><!-- doxytag: member="vrt::BasicDataPacket::setPacketType" ref="af947fca253c101a6a97709c970e10a37" args="(PacketType t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setPacketType </td>
          <td>(</td>
          <td class="paramtype">PacketType&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets the packet type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The packet type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classvrt_1_1BasicVRTPacket.html#ae215e242805855769eb7b1f840cc0da9">vrt::BasicVRTPacket</a>.</p>

</div>
</div>
<a class="anchor" id="a93c2d36ed6000364254d48b93dcaa771"></a><!-- doxytag: member="vrt::BasicDataPacket::setPayloadFormat" ref="a93c2d36ed6000364254d48b93dcaa771" args="(const PayloadFormat &amp;pf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::BasicDataPacket::setPayloadFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional Functionality:</em> Sets the payload format to be assumed when interacting with the data in this packet. </p>
<p>Note that this setting exists only for the lifetime of this object and is not directly stored within the data packet. <br/>
 <br/>
 Many data packet classes use a fixed payload format (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>) and will throw an exception if this method is called. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If setting the payload format is unsupported. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classvrt_1_1StandardDataPacket.html#a05652fd4f48c1662b3a21fcd824ae4e4">vrt::StandardDataPacket</a>.</p>

</div>
</div>
<a class="anchor" id="acf42e6491de3037fc3ac7de0f0389c1d"></a><!-- doxytag: member="vrt::BasicDataPacket::setReferenceLocked" ref="acf42e6491de3037fc3ac7de0f0389c1d" args="(boolNull v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setReferenceLocked </td>
          <td>(</td>
          <td class="paramtype">boolNull&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Gets the reference lock indicator flag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>true if the flag is set, false if not set, null if this optional flag isn't specified. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a610c04accba684228dd36a363285fbfe">setTrailerBit()</a>.</p>

</div>
</div>
<a class="anchor" id="a117b4ff2d379bc467bb3cd2720a39392"></a><!-- doxytag: member="vrt::BasicDataPacket::setScalarDataLength" ref="a117b4ff2d379bc467bb3cd2720a39392" args="(PayloadFormat pf, int32_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setScalarDataLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrt_1_1PayloadFormat.html">PayloadFormat</a>&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Utility method:</em> Sets the length of the data in number of scalar elements. </p>
<p>Unlike <code>setPayloadLength(..)</code> this sets the number of data elements, not bytes. For complex data the real and imaginary components of a single value count as a two elements (see <code>setDataLength(..)</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The payload format to assume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of elements in the payload. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>If the payload format is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00623">setDataLength()</a>.</p>

</div>
</div>
<a class="anchor" id="aa63c4dd3853e3c4b65fee663c8c1d3ee"></a><!-- doxytag: member="vrt::BasicDataPacket::setScalarDataLength" ref="aa63c4dd3853e3c4b65fee663c8c1d3ee" args="(int32_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setScalarDataLength </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Utility method:</em> Sets the length of the data in number of scalar elements. </p>
<p>Unlike <code>setPayloadLength(..)</code> this sets the number of data elements, not bytes. For complex data the real and imaginary components of a single value count as a two elements (see <code>setDataLength(..)</code>. <br/>
 <br/>
 This method can only be used AFTER a payload format for the packet has been specified (see <a class="el" href="classvrt_1_1BasicDataPacket.html#a218104e7d259c4e852254d65e304e3f8">getPayloadFormat()</a>. This method is identical to calling <code>p.getScalarDataLength(p.getPayloadFormat())</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of elements in the payload. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00452">getPayloadFormat()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00623">setDataLength()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l01365">setDataByte()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01230">setDataDouble()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01257">setDataFloat()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01311">setDataInt()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01284">setDataLong()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l01338">setDataShort()</a>.</p>

</div>
</div>
<a class="anchor" id="a8ed6baafc210158ff92c7f8edde8b526"></a><!-- doxytag: member="vrt::BasicDataPacket::setSignalDetected" ref="a8ed6baafc210158ff92c7f8edde8b526" args="(boolNull v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setSignalDetected </td>
          <td>(</td>
          <td class="paramtype">boolNull&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Gets the signal detected indicator flag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>true if the flag is set, false if not set, null if this optional flag isn't specified. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classvrt_1_1BasicDataPacket.html#a610c04accba684228dd36a363285fbfe">setTrailerBit()</a>.</p>

</div>
</div>
<a class="anchor" id="ad803d26ff68207f064f2df1b8dba572b"></a><!-- doxytag: member="vrt::BasicDataPacket::setStartStopIndication" ref="ad803d26ff68207f064f2df1b8dba572b" args="(StartStopIndication v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::setStartStopIndication </td>
          <td>(</td>
          <td class="paramtype">StartStopIndication&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets the Sample Frame Start Stop Indication value. </p>
<p>Bits 11..10 and accompanying enable bits 23..22 are used together as the two-bit StartStopIndication for Data Packets using Sample Frames. The following values are possible: 00 StartStopIndication_NA 01 StartStopIndication_First 10 StartStopIndication_Middle 11 StartStopIndication_Final </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>StartStopIndication value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00394">setBit10()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00388">setBit11()</a>.</p>

</div>
</div>
<a class="anchor" id="a610c04accba684228dd36a363285fbfe"></a><!-- doxytag: member="vrt::BasicDataPacket::setTrailerBit" ref="a610c04accba684228dd36a363285fbfe" args="(int32_t enable, int32_t indicator, boolNull value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::BasicDataPacket::setTrailerBit </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>indicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolNull&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets the specified bit from the trailer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>Bit position of the enable flag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indicator</em>&nbsp;</td><td>Bit position of the indicator flag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of the bits: null if the enable bit should not be set, true if the enable bit and the indicator bit should be set, false if the enable bit should be set but the indicator bit should not be set. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l00355">setAutomaticGainControl()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00394">setBit10()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00388">setBit11()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00406">setBit8()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00400">setBit9()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00337">setCalibratedTimeStamp()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00343">setDataValid()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00379">setDiscontinuous()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00367">setInvertedSpectrum()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00373">setOverRange()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00349">setReferenceLocked()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00361">setSignalDetected()</a>.</p>

</div>
</div>
<a class="anchor" id="aec33b2c7031772f446ec0a9703f2b457"></a><!-- doxytag: member="vrt::BasicDataPacket::toStringStream" ref="aec33b2c7031772f446ec0a9703f2b457" args="(ostringstream &amp;str) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::BasicDataPacket::toStringStream </td>
          <td>(</td>
          <td class="paramtype">ostringstream &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes the packet content to a string stream in a user-friendly format. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string stream to write to. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classvrt_1_1BasicVRTPacket.html#a1cdf8b4c9288d38516b8325a8a95b268">vrt::BasicVRTPacket</a>.</p>

<p>Reimplemented in <a class="el" href="classvrt_1_1StandardDataPacket.html#aaae5248c395f8bcbd84c2b360a243041">vrt::StandardDataPacket</a>, and <a class="el" href="classvrt_1_1NoDataPacket.html#a95396645ea4a27b12a2b9dc5d5abe428">vrt::NoDataPacket</a>.</p>

</div>
</div>
<a class="anchor" id="ac528ad3318660d948f10847c36095cc1"></a><!-- doxytag: member="vrt::BasicDataPacket::unsetStartStopIndication" ref="ac528ad3318660d948f10847c36095cc1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicDataPacket::unsetStartStopIndication </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Unsets the Sample Frame Start Stop Indication enable bits. </p>
<p>See <a class="el" href="classvrt_1_1BasicDataPacket.html#ad803d26ff68207f064f2df1b8dba572b">setStartStopIndication</a>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BasicDataPacket_8h_source.html#l00394">setBit10()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l00388">setBit11()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cpp_src/vrt/lib/<a class="el" href="BasicDataPacket_8h_source.html">BasicDataPacket.h</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 29 Jun 2018 for VRT by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>

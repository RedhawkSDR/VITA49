<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VRT: vrt::NetUtilities Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>vrt</b>::<a class="el" href="namespacevrt_1_1NetUtilities.html">NetUtilities</a>
  </div>
</div>
<div class="contents">
<h1>vrt::NetUtilities Namespace Reference</h1>
<p>Various utilities methods.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1NetUtilities.html#a6b2fc775155fcbac9b5bac6d191aa81d">doHttpGet</a> (const string &amp;url, map&lt; string, string &gt; &amp;header, string &amp;data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Gets the response from an HTTP GET call.  <a href="#a6b2fc775155fcbac9b5bac6d191aa81d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">map&lt; string, string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1NetUtilities.html#aea1867aba70c09841e4f27b298a43c98">getDefaultSocketOptions</a> (bool optimize, TransportProtocol transport)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a set of default socket options that can be added to.  <a href="#aea1867aba70c09841e4f27b298a43c98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1NetUtilities.html#ae3566c8f4b9a892193d1907a1bfa90b1">getHost</a> (const string &amp;hostPort)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the host name from a host:port.  <a href="#ae3566c8f4b9a892193d1907a1bfa90b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrt_1_1InetAddress.html">InetAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1NetUtilities.html#a8962e0f258c2d030c8872f675d59b610">getHostAddress</a> (const string &amp;hostPort)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the host name from a host:port.  <a href="#a8962e0f258c2d030c8872f675d59b610"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1NetUtilities.html#aee735c2dcb1c2fae00ef45fe2f38cc8c">getNetworkDeviceName</a> (const string &amp;nic, int32_t vlan)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the device name applicable when given a NIC and VLAN.  <a href="#aee735c2dcb1c2fae00ef45fe2f38cc8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1NetUtilities.html#a946723c4bb7ae640ebdc6fe42f2a32f3">getPort</a> (const string &amp;hostPort)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the port number from a host:port.  <a href="#a946723c4bb7ae640ebdc6fe42f2a32f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1NetUtilities.html#a67c633085549904b0aa85ef86a05895b">getSocketOptionBool</a> (map&lt; string, string &gt; &amp;opts, const string &amp;key, bool def=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Gets a socket option as a boolean (0/1).  <a href="#a67c633085549904b0aa85ef86a05895b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1NetUtilities.html#a2f14ac171e8e4860e659361dce26c53b">getSocketOptionInt</a> (map&lt; string, string &gt; &amp;opts, const string &amp;key, int32_t def=INT32_NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Gets a socket option as an int.  <a href="#a2f14ac171e8e4860e659361dce26c53b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1NetUtilities.html#a5cb422e6b3819c8e975b252d13e1b6ba">hasOpt</a> (map&lt; string, string &gt; &amp;opts, const string &amp;key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Is a socket option present?  <a href="#a5cb422e6b3819c8e975b252d13e1b6ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ifreq&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1NetUtilities.html#a2886ed17417b7c072a49134dc8a63941">toInterface</a> (int sockfd, const string &amp;device, bool isMCast=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Converts device name to a device object.  <a href="#a2886ed17417b7c072a49134dc8a63941"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1NetUtilities.html#ad2c83f065304478b10822fae180ad72d">EXTRA_BUFFER_SIZE</a> = 80</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Fudge factor to use when sizing buffers that work with UDP datagrams to account for size of datagram header, plus the IP header, etc.  <a href="#ad2c83f065304478b10822fae180ad72d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1NetUtilities.html#a8dbf95b65bd420ead4d2e84fbacaf4c2">MAX_IPv4_UDP_LEN</a> = 65475</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum length of a UDP packet (including the UDP header) in octets when transmitted over IPv4 (65,471).  <a href="#a8dbf95b65bd420ead4d2e84fbacaf4c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1NetUtilities.html#a00689064d813f06023b8074b228e87dc">MAX_UDP_LEN</a> = 65535</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum length of a UDP packet (including the UDP header) in octets (65,535).  <a href="#a00689064d813f06023b8074b228e87dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1NetUtilities.html#a3584affb5af11793f9502de5ad94ed81">UDP_HEADER_LENGTH</a> = 8</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The length of a UPD packet header in octets (8).  <a href="#a3584affb5af11793f9502de5ad94ed81"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Various utilities methods. </p>
<h3><a class="el" href="classvrt_1_1Socket.html" title="Internal Use Only: Class to hold a BSD-style socket with accompanying information...">Socket</a> Creation Options</h3>
<p>The socket creation methods take in a map of options used for initializing a socket. If the map is null, or if a given entry is null, the default value will be used. The map may include any of the basic SO_* socket options for example: </p>
<pre>
    string bufSize = ...;
    options["SO_SNDBUF"] = bufSize;
  </pre><p> It may also include the following options: </p>
<pre>
    CONNECT_TIMEOUT - The connection timeout for a TCP <a class="el" href="classvrt_1_1Socket.html" title="Internal Use Only: Class to hold a BSD-style socket with accompanying information...">Socket</a> in ms.
    LOCAL_PORT      - The local port to use for a TCP client connection (this
                      overrides the default which is to use any available
                      ephemeral port).
    RCVBUF_EAGER    - Override the normal o/s behavior and force the receive
                      buffer to be eagerly initialized when a UDP socket
                      (unicast/multicast) is opened. The default o/s behavior
                      on some systems (particularly Linux) is to do a lazy
                      initialization of the receive buffer for a UDP socket.
                      When an lazy initialization is done, the receive buffer
                      might not be initialized until (or possibly after) the
                      first receive call is made, resulting in packet loss
                      during the period between the open and the actual buffer
                      initialization. Setting this to true attempts to force
                      the o/s to initialize the receive buffer as part of the
                      open (or at least the open within this class); however,
                      there is no guarantee that the o/s will allocate it at
                      that time. Setting this to false will use the default
                      o/s behavior, which is generally faster. <em>(Note that
                      there is no SNDBUF_EAGER since there is no reason to
                      buffer output packets until the first one is sent.)</em>
    SERVER_BACKLOG  - The backlog value for a TCP server socket.
  </pre><p> Any options not applicable for the given socket type will be ignored. Note that <code>IP_MULTICAST_IF</code> is also ignored since this is explicitly set via the "device" input parameter. Additionally <code>SO_SNDBUF</code>, <code>SO_RCVBUF</code>, <code>SO_REUSEADDR</code>, and <code>SO_TIMEOUT</code> may be given defaults that differ from the O/S defaults where applicable (however these defaults can be overridden via the socket options provided). </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a6b2fc775155fcbac9b5bac6d191aa81d"></a><!-- doxytag: member="vrt::NetUtilities::doHttpGet" ref="a6b2fc775155fcbac9b5bac6d191aa81d" args="(const string &amp;url, map&lt; string, string &gt; &amp;header, string &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::NetUtilities::doHttpGet </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Gets the response from an HTTP GET call. </p>

</div>
</div>
<a class="anchor" id="aea1867aba70c09841e4f27b298a43c98"></a><!-- doxytag: member="vrt::NetUtilities::getDefaultSocketOptions" ref="aea1867aba70c09841e4f27b298a43c98" args="(bool optimize, TransportProtocol transport)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;string,string&gt; vrt::NetUtilities::getDefaultSocketOptions </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>optimize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TransportProtocol&nbsp;</td>
          <td class="paramname"> <em>transport</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a set of default socket options that can be added to. </p>
<p>This allows a easy way of getting "default" options that may be slightly more optimal than the ones provided by the o/s. <br/>
 <br/>
 <b>WARNING: The "default" options provided by this function may change between releases and may vary from platform to platform within the same release.</b> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>optimize</em>&nbsp;</td><td>Select more aggressive optimizations that assume high-rate VITA-49 traffic (true) or defer to o/s defaults where the benefit to "general" traffic is unclear (false). Setting this to true may enable options that optimize performance for streaming-data at the expense of slower connect/open times and/or may be inappropriate for non-packetized data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transport</em>&nbsp;</td><td>Specific transport to use for any transport-specific optimizations (can be null). <em>(This value is only considered with respect to optimizations that require differentiation between transport options.)</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The set of options to use (never null). </dd></dl>

</div>
</div>
<a class="anchor" id="ae3566c8f4b9a892193d1907a1bfa90b1"></a><!-- doxytag: member="vrt::NetUtilities::getHost" ref="ae3566c8f4b9a892193d1907a1bfa90b1" args="(const string &amp;hostPort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vrt::NetUtilities::getHost </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>hostPort</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the host name from a host:port. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hostPort</em>&nbsp;</td><td>The host:port in "host:port", "host" or ":port" syntax. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The applicable host name or null if not specified. </dd></dl>

</div>
</div>
<a class="anchor" id="a8962e0f258c2d030c8872f675d59b610"></a><!-- doxytag: member="vrt::NetUtilities::getHostAddress" ref="a8962e0f258c2d030c8872f675d59b610" args="(const string &amp;hostPort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrt_1_1InetAddress.html">InetAddress</a> vrt::NetUtilities::getHostAddress </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>hostPort</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the host name from a host:port. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hostPort</em>&nbsp;</td><td>The host:port in "host:port", "host" or ":port" syntax. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The applicable host name or null if not specified. </dd></dl>

</div>
</div>
<a class="anchor" id="aee735c2dcb1c2fae00ef45fe2f38cc8c"></a><!-- doxytag: member="vrt::NetUtilities::getNetworkDeviceName" ref="aee735c2dcb1c2fae00ef45fe2f38cc8c" args="(const string &amp;nic, int32_t vlan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vrt::NetUtilities::getNetworkDeviceName </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>nic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>vlan</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the device name applicable when given a NIC and VLAN. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nic</em>&nbsp;</td><td>The NIC to use ("" if n/a). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vlan</em>&nbsp;</td><td>The VLAN to use (-1 if n/a). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The applicable device identifier (e.g. "eth1", "eth0.123"). </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>if a VLAN is specified without a NIC </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a946723c4bb7ae640ebdc6fe42f2a32f3"></a><!-- doxytag: member="vrt::NetUtilities::getPort" ref="a946723c4bb7ae640ebdc6fe42f2a32f3" args="(const string &amp;hostPort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t vrt::NetUtilities::getPort </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>hostPort</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the port number from a host:port. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hostPort</em>&nbsp;</td><td>The host:port in "host:port", "host" or ":port" syntax. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The applicable port number or null if not specified. </dd></dl>

</div>
</div>
<a class="anchor" id="a67c633085549904b0aa85ef86a05895b"></a><!-- doxytag: member="vrt::NetUtilities::getSocketOptionBool" ref="a67c633085549904b0aa85ef86a05895b" args="(map&lt; string, string &gt; &amp;opts, const string &amp;key, bool def=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrt::NetUtilities::getSocketOptionBool </td>
          <td>(</td>
          <td class="paramtype">map&lt; string, string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>def</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Gets a socket option as a boolean (0/1). </p>

<p>References <a class="el" href="NetUtilities_8h_source.html#l00185">hasOpt()</a>, and <a class="el" href="Utilities_8h_source.html#l00169">vrt::Utilities::toBooleanValue()</a>.</p>

</div>
</div>
<a class="anchor" id="a2f14ac171e8e4860e659361dce26c53b"></a><!-- doxytag: member="vrt::NetUtilities::getSocketOptionInt" ref="a2f14ac171e8e4860e659361dce26c53b" args="(map&lt; string, string &gt; &amp;opts, const string &amp;key, int32_t def=INT32_NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrt::NetUtilities::getSocketOptionInt </td>
          <td>(</td>
          <td class="paramtype">map&lt; string, string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>def</em> = <code>INT32_NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Gets a socket option as an int. </p>

<p>References <a class="el" href="NetUtilities_8h_source.html#l00185">hasOpt()</a>.</p>

</div>
</div>
<a class="anchor" id="a5cb422e6b3819c8e975b252d13e1b6ba"></a><!-- doxytag: member="vrt::NetUtilities::hasOpt" ref="a5cb422e6b3819c8e975b252d13e1b6ba" args="(map&lt; string, string &gt; &amp;opts, const string &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::NetUtilities::hasOpt </td>
          <td>(</td>
          <td class="paramtype">map&lt; string, string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Is a socket option present? </p>

<p>Referenced by <a class="el" href="NetUtilities_8h_source.html#l00196">getSocketOptionBool()</a>, and <a class="el" href="NetUtilities_8h_source.html#l00190">getSocketOptionInt()</a>.</p>

</div>
</div>
<a class="anchor" id="a2886ed17417b7c072a49134dc8a63941"></a><!-- doxytag: member="vrt::NetUtilities::toInterface" ref="a2886ed17417b7c072a49134dc8a63941" args="(int sockfd, const string &amp;device, bool isMCast=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ifreq vrt::NetUtilities::toInterface </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sockfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isMCast</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Converts device name to a device object. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ad2c83f065304478b10822fae180ad72d"></a><!-- doxytag: member="vrt::NetUtilities::EXTRA_BUFFER_SIZE" ref="ad2c83f065304478b10822fae180ad72d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="namespacevrt_1_1NetUtilities.html#ad2c83f065304478b10822fae180ad72d">vrt::NetUtilities::EXTRA_BUFFER_SIZE</a> = 80</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Fudge factor to use when sizing buffers that work with UDP datagrams to account for size of datagram header, plus the IP header, etc. </p>

</div>
</div>
<a class="anchor" id="a8dbf95b65bd420ead4d2e84fbacaf4c2"></a><!-- doxytag: member="vrt::NetUtilities::MAX_IPv4_UDP_LEN" ref="a8dbf95b65bd420ead4d2e84fbacaf4c2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="namespacevrt_1_1NetUtilities.html#a8dbf95b65bd420ead4d2e84fbacaf4c2">vrt::NetUtilities::MAX_IPv4_UDP_LEN</a> = 65475</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum length of a UDP packet (including the UDP header) in octets when transmitted over IPv4 (65,471). </p>
<p>Although the max packet length for UDP is 65,635 bytes, IPv4 imposes a lower limit: </p>
<pre>
    Maximum IPv4 Length:        65,535 octets
    Maximum IPv4 Header:      -     60 octets  (20 octets is minimum)
    -----------------------------------------
    Maximim UDP in IPv4:        65,475 octets
  </pre><p> Accordingly this value should be thought of as the maximum for transmission size and <a class="el" href="namespacevrt_1_1NetUtilities.html#a00689064d813f06023b8074b228e87dc">MAX_UDP_LEN</a> should be used as the maximum receive size. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespacevrt_1_1NetUtilities.html#a00689064d813f06023b8074b228e87dc" title="Maximum length of a UDP packet (including the UDP header) in octets (65,535).">MAX_UDP_LEN</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a00689064d813f06023b8074b228e87dc"></a><!-- doxytag: member="vrt::NetUtilities::MAX_UDP_LEN" ref="a00689064d813f06023b8074b228e87dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="namespacevrt_1_1NetUtilities.html#a00689064d813f06023b8074b228e87dc">vrt::NetUtilities::MAX_UDP_LEN</a> = 65535</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum length of a UDP packet (including the UDP header) in octets (65,535). </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespacevrt_1_1NetUtilities.html#a8dbf95b65bd420ead4d2e84fbacaf4c2" title="Maximum length of a UDP packet (including the UDP header) in octets when transmitted...">MAX_IPv4_UDP_LEN</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3584affb5af11793f9502de5ad94ed81"></a><!-- doxytag: member="vrt::NetUtilities::UDP_HEADER_LENGTH" ref="a3584affb5af11793f9502de5ad94ed81" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="namespacevrt_1_1NetUtilities.html#a3584affb5af11793f9502de5ad94ed81">vrt::NetUtilities::UDP_HEADER_LENGTH</a> = 8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The length of a UPD packet header in octets (8). </p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 29 Jun 2018 for VRT by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>

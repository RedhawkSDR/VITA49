<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VRT: vrt::NetIO Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>vrt</b>::<a class="el" href="classvrt_1_1NetIO.html">NetIO</a>
  </div>
</div>
<div class="contents">
<h1>vrt::NetIO Class Reference</h1><!-- doxytag: class="vrt::NetIO" --><!-- doxytag: inherits="vrt::Threadable" -->
<p><b>Internal Use Only:</b> Provides the basic network I/O functions used by both <a class="el" href="classvrt_1_1VRTReader.html">VRTReader</a> and <a class="el" href="classvrt_1_1VRTWriter.html">VRTWriter</a>.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="NetIO_8h_source.html">NetIO.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vrt::NetIO:</div>
<div class="dynsection">
 <div class="center">
  <img src="classvrt_1_1NetIO.gif" usemap="#vrt::NetIO_map" alt=""/>
  <map id="vrt::NetIO_map" name="vrt::NetIO_map">
<area href="classvrt_1_1Threadable.html" alt="vrt::Threadable" shape="rect" coords="54,56,152,80"/>
<area href="classvrt_1_1VRTObject.html" alt="vrt::VRTObject" shape="rect" coords="54,0,152,24"/>
<area href="classvrt_1_1VRTReader.html" alt="vrt::VRTReader" shape="rect" coords="0,168,98,192"/>
<area href="classvrt_1_1VRTWriter.html" alt="vrt::VRTWriter" shape="rect" coords="108,168,206,192"/>
</map>
 </div>
</div>

<p><a href="classvrt_1_1NetIO-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>QueuedPacketHandler</b></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Handles any packets on the queue. <br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#af37b36116b7d3c08a09258563e95cafa">NetIO</a> (bool isOutput, TransportProtocol transport, const string &amp;host, int32_t port, const string &amp;device, <a class="el" href="classvrt_1_1VRTEventListener.html">VRTEventListener</a> *listener, const map&lt; string, string &gt; &amp;options, int32_t bufLength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new instance.  <a href="#af37b36116b7d3c08a09258563e95cafa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#ac66344152297f7832d63409c673fdcac">~NetIO</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#ac66344152297f7832d63409c673fdcac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#a9c420b521ff47db33ca308ad4cbbac82">getActiveConnectionCount</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Gets the number of active connections.  <a href="#a9c420b521ff47db33ca308ad4cbbac82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#ac1eb2071e7382c2f8379418347eed45b">start</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts the object running in a new thread.  <a href="#ac1eb2071e7382c2f8379418347eed45b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#a2830e8273c1dbaa9d46e5a7120d2725a">stop</a> (bool wait=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells the object to stop running.  <a href="#a2830e8273c1dbaa9d46e5a7120d2725a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#a1e4bf123c34691e84885ee5b83ab5ff4">toString</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides a description of the instance useful for debugging.  <a href="#a1e4bf123c34691e84885ee5b83ab5ff4"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#ad45a69033e49f98250a4d37c45888be6">_tcpSocketRead</a> (void *buf, int32_t off, int32_t len, bool required)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read from TCP socket with special handling for socket errors.  <a href="#ad45a69033e49f98250a4d37c45888be6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#ad3cce989e7d03733e1eb2a4aedd47df6">checkSockets</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks the current sockets, reconnecting as needed.  <a href="#ad3cce989e7d03733e1eb2a4aedd47df6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#aa40f23a1dbbeeaa49020b204f0ced119">clearQueue</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pops a packet off of the queue.  <a href="#aa40f23a1dbbeeaa49020b204f0ced119"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#ab1fedfc2a7a0552b70fe75bf298a257e">closeClientSockets</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes only the client sockets.  <a href="#ab1fedfc2a7a0552b70fe75bf298a257e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#a586e0ed1215bb3506964729b77d243dc">closeSockets</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes the sockets.  <a href="#a586e0ed1215bb3506964729b77d243dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#a3fde1e634f6b6d9955fe72542777aa34">handle</a> (vector&lt; char &gt; *buffer, int32_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handles the packet read in.  <a href="#a3fde1e634f6b6d9955fe72542777aa34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#a2cd1d407a0df2acf391895a40f42799c">openSockets</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes the sockets.  <a href="#a2cd1d407a0df2acf391895a40f42799c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; char &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#a620213fe52adf0ffba6ff73ca3f51d32">popPacket</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pops a packet off of the queue.  <a href="#a620213fe52adf0ffba6ff73ca3f51d32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#a866137d4d0352078bc87696a09e326bb">pushPacket</a> (vector&lt; char &gt; *p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a packet to the processing queue.  <a href="#a866137d4d0352078bc87696a09e326bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#a17ad0930971f17412d5135eab12628bf">pushPackets</a> (vector&lt; char &gt; *first, vector&lt; vector&lt; char &gt; * &gt; *rest)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a set of packets to the processing queue.  <a href="#a17ad0930971f17412d5135eab12628bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; char &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#ad5dd9e183fbdc2981c26cd6113a9dc8c">receiveBuffer</a> (bool autoPush)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a single buffer from the input stream.  <a href="#ad5dd9e183fbdc2981c26cd6113a9dc8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual vector&lt; char &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#ae2ef7300feee7c63213b6c63a9a529b0">receiveBufferTCP</a> (bool autoPush)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a packet via UDP.  <a href="#ae2ef7300feee7c63213b6c63a9a529b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual vector&lt; char &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#a551265c20fb443561b70763fac29bbb7">receiveBufferUDP</a> (bool autoPush)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a packet via UDP.  <a href="#a551265c20fb443561b70763fac29bbb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#a31bb39c68ae659470be2edc0637f35d0">reconnect</a> (const <a class="el" href="classvrt_1_1VRTEventListener.html">VRTEventListener</a> &amp;warnings)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Requests a reconnect and waits for it to be done.  <a href="#a31bb39c68ae659470be2edc0637f35d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#a0b2f212a94b9d92cbb48205072b5a3a7">runInputThread</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version of <a class="el" href="classvrt_1_1NetIO.html#a1a74c4e2e582d3b3819b18ae0e79881a">runThread()</a> for an input connection.  <a href="#a0b2f212a94b9d92cbb48205072b5a3a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#affb1bbf3e96f099c14e211a26be53def">runOutputThread</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version of <a class="el" href="classvrt_1_1NetIO.html#a1a74c4e2e582d3b3819b18ae0e79881a">runThread()</a> for an output connection.  <a href="#affb1bbf3e96f099c14e211a26be53def"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#a1a74c4e2e582d3b3819b18ae0e79881a">runThread</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Runs the thread.  <a href="#a1a74c4e2e582d3b3819b18ae0e79881a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#a288079a9f97b0e886181f8cf188141eb">sendBuffer</a> (const void *buf, int32_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends the UDP datagram *or* TCP buffer of data.  <a href="#a288079a9f97b0e886181f8cf188141eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#a4462cb54dff6a42a08386d0e4d9bb7f3">sendBuffer</a> (int32_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends the UDP datagram *or* TCP buffer of data.  <a href="#a4462cb54dff6a42a08386d0e4d9bb7f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#a43310a84a1e2d5c219aa1ccc31d789cd">shutdown</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes any connections, This will always be called at the end of a call to <a class="el" href="classvrt_1_1Threadable.html#a1f4df829530dcd6a2748d79014aa6215">run()</a>.  <a href="#a43310a84a1e2d5c219aa1ccc31d789cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#ad1883b9f2039c7394caf34211bf74e47">shutdownClientSockets</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shutdown only the client sockets.  <a href="#ad1883b9f2039c7394caf34211bf74e47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#a2659351c35f5a907e3bf84d97c2b8d3d">shutdownSockets</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stops any future read/write on the sockets, but does not close them.  <a href="#a2659351c35f5a907e3bf84d97c2b8d3d"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1b1924540d822a4849ed95a7c103f13"></a><!-- doxytag: member="vrt::NetIO::buffer" ref="ac1b1924540d822a4849ed95a7c103f13" args="" -->
vector&lt; char &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>buffer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab999100ed10b21c769b6218a791782b"></a><!-- doxytag: member="vrt::NetIO::ctxListener" ref="aab999100ed10b21c769b6218a791782b" args="" -->
<a class="el" href="classvrt_1_1VRTContextListener.html">VRTContextListener</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>ctxListener</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d77221dde3b221ddf3ab36fc6a6922c"></a><!-- doxytag: member="vrt::NetIO::datagramSocket" ref="a9d77221dde3b221ddf3ab36fc6a6922c" args="" -->
<a class="el" href="classvrt_1_1Socket.html">Socket</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>datagramSocket</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54b2daec69d339c00e778248d0c61e81"></a><!-- doxytag: member="vrt::NetIO::device" ref="a54b2daec69d339c00e778248d0c61e81" args="" -->
string&nbsp;</td><td class="memItemRight" valign="bottom"><b>device</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2f6b48ad2423edee6961c2b9fa8779c"></a><!-- doxytag: member="vrt::NetIO::doShutdown" ref="aa2f6b48ad2423edee6961c2b9fa8779c" args="" -->
int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>doShutdown</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf25d2ce116c125df6e4cce45225896b"></a><!-- doxytag: member="vrt::NetIO::event" ref="acf25d2ce116c125df6e4cce45225896b" args="" -->
<a class="el" href="classvrt_1_1VRTEvent.html">VRTEvent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>event</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bcb5e9064ad48b1df94b259dec1524b"></a><!-- doxytag: member="vrt::NetIO::evtListener" ref="a9bcb5e9064ad48b1df94b259dec1524b" args="" -->
<a class="el" href="classvrt_1_1VRTEventListener.html">VRTEventListener</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>evtListener</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35396d59fb4ba94284736f3c2c898807"></a><!-- doxytag: member="vrt::NetIO::frameCounter" ref="a35396d59fb4ba94284736f3c2c898807" args="" -->
int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>frameCounter</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecbc7999a6e829c9fdd1f845664868b1"></a><!-- doxytag: member="vrt::NetIO::host" ref="aecbc7999a6e829c9fdd1f845664868b1" args="" -->
string&nbsp;</td><td class="memItemRight" valign="bottom"><b>host</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f0966746c13f4f4a54d8485d4cc3039"></a><!-- doxytag: member="vrt::NetIO::hostAddr" ref="a8f0966746c13f4f4a54d8485d4cc3039" args="" -->
<a class="el" href="classvrt_1_1InetAddress.html">InetAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>hostAddr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25c3536a11a4d2fb7be4b3350b6184a3"></a><!-- doxytag: member="vrt::NetIO::isOutput" ref="a25c3536a11a4d2fb7be4b3350b6184a3" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isOutput</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26dc907185ae4e44969db4a99431e24c"></a><!-- doxytag: member="vrt::NetIO::lengthReadIn" ref="a26dc907185ae4e44969db4a99431e24c" args="" -->
int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>lengthReadIn</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad56c17aca1b0960f5d7cbfe1ddca158c"></a><!-- doxytag: member="vrt::NetIO::packetCounters" ref="ad56c17aca1b0960f5d7cbfe1ddca158c" args="" -->
map&lt; int64_t, int32_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>packetCounters</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1554358e6d319bbf9993d7135643b96"></a><!-- doxytag: member="vrt::NetIO::packetsReadIn" ref="aa1554358e6d319bbf9993d7135643b96" args="" -->
queue&lt; vector&lt; char &gt; * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>packetsReadIn</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9907dbf4280e0ca204835ef96d07e2eb"></a><!-- doxytag: member="vrt::NetIO::packetsReadInLock" ref="a9907dbf4280e0ca204835ef96d07e2eb" args="" -->
<a class="el" href="classvrt_1_1VRTObject.html">VRTObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>packetsReadInLock</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16dece57df0e75a63fafd541c9783e3a"></a><!-- doxytag: member="vrt::NetIO::port" ref="a16dece57df0e75a63fafd541c9783e3a" args="" -->
int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>port</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae68d2236a56b3d1b3b78213d1b2b2452"></a><!-- doxytag: member="vrt::NetIO::queuedPacketHandler" ref="ae68d2236a56b3d1b3b78213d1b2b2452" args="" -->
QueuedPacketHandler *&nbsp;</td><td class="memItemRight" valign="bottom"><b>queuedPacketHandler</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada395c80eb0127a3ce1763476df3e129"></a><!-- doxytag: member="vrt::NetIO::queueLimitOctets" ref="ada395c80eb0127a3ce1763476df3e129" args="" -->
int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>queueLimitOctets</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23467bb24cffc91c47c582d61877636d"></a><!-- doxytag: member="vrt::NetIO::queueLimitPackets" ref="a23467bb24cffc91c47c582d61877636d" args="" -->
int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>queueLimitPackets</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a312f8fc7cc0e1fc375d8c9b60e082a83"></a><!-- doxytag: member="vrt::NetIO::reconnectDone" ref="a312f8fc7cc0e1fc375d8c9b60e082a83" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>reconnectDone</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27aceb37b5eb1faa0c2cceb07a30b156"></a><!-- doxytag: member="vrt::NetIO::reconnectError" ref="a27aceb37b5eb1faa0c2cceb07a30b156" args="" -->
<a class="el" href="classvrt_1_1VRTException.html">VRTException</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>reconnectError</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a259717b5be9e11f33330e5e410a3e465"></a><!-- doxytag: member="vrt::NetIO::reconnectNow" ref="a259717b5be9e11f33330e5e410a3e465" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>reconnectNow</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad99f42e4504ad1be8c36190c0693b453"></a><!-- doxytag: member="vrt::NetIO::socketOptions" ref="ad99f42e4504ad1be8c36190c0693b453" args="" -->
map&lt; string, string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>socketOptions</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5b3bf7dd672220fd2d51094acd829db"></a><!-- doxytag: member="vrt::NetIO::tcpServerCheck" ref="ad5b3bf7dd672220fd2d51094acd829db" args="" -->
int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>tcpServerCheck</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7ebdddd5482785eacfeae324a4bceb3"></a><!-- doxytag: member="vrt::NetIO::tcpServerSocket" ref="ac7ebdddd5482785eacfeae324a4bceb3" args="" -->
<a class="el" href="classvrt_1_1Socket.html">Socket</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>tcpServerSocket</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ffa1209d4bac514d1e6d70cb7277fdd"></a><!-- doxytag: member="vrt::NetIO::tcpSockets" ref="a4ffa1209d4bac514d1e6d70cb7277fdd" args="" -->
vector&lt; <a class="el" href="classvrt_1_1Socket.html">Socket</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><b>tcpSockets</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e918d819ad03cc1f9464d7d6b762b9a"></a><!-- doxytag: member="vrt::NetIO::transport" ref="a2e918d819ad03cc1f9464d7d6b762b9a" args="" -->
TransportProtocol&nbsp;</td><td class="memItemRight" valign="bottom"><b>transport</b></td></tr>
<tr><td colspan="2"><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static vector&lt; char &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1NetIO.html#af91dfdf3e52f2537988b6c4fc17280f1">BUFFER_PUSHED</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates that a buffer was already handled.  <a href="#af91dfdf3e52f2537988b6c4fc17280f1"></a><br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac772d299fca2a7c768d11941ad921f96"></a><!-- doxytag: member="vrt::NetIO::QueuedPacketHandler" ref="ac772d299fca2a7c768d11941ad921f96" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>QueuedPacketHandler</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><b>Internal Use Only:</b> Provides the basic network I/O functions used by both <a class="el" href="classvrt_1_1VRTReader.html">VRTReader</a> and <a class="el" href="classvrt_1_1VRTWriter.html">VRTWriter</a>. </p>
<p><br/>
 <br/>
 <b>Warning:</b> This class is public to support documentation and testing. Users should never access this class directly (even when trying to give a generic "parent" class) as it is subject to change without notice as is the fact that any sub-class extends this class. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af37b36116b7d3c08a09258563e95cafa"></a><!-- doxytag: member="vrt::NetIO::NetIO" ref="af37b36116b7d3c08a09258563e95cafa" args="(bool isOutput, TransportProtocol transport, const string &amp;host, int32_t port, const string &amp;device, VRTEventListener *listener, const map&lt; string, string &gt; &amp;options, int32_t bufLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::NetIO::NetIO </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TransportProtocol&nbsp;</td>
          <td class="paramname"> <em>transport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrt_1_1VRTEventListener.html">VRTEventListener</a> *&nbsp;</td>
          <td class="paramname"> <em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; string, string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bufLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new instance. </p>
<p>The options provided to control the socket and connection may include any of the "Socket Creation Options" listed at the top of <code><a class="el" href="namespacevrt_1_1NetUtilities.html" title="Various utilities methods.">NetUtilities</a></code> plus the following: </p>
<pre>
    INITIAL_TIMEOUT     - The approximate timeout (in seconds) applied when
                          checking for the initial packets. If the complete
                          initial context is not received before the first
                          packet received after this time has elapsed, it
                          will be reported as an error if appropriate). This
                          can also take one of the following special values:
                            -1 = Unlimited wait time.
                            -2 = Use "legacy mode" (pre 2011 version of library)
    QUEUE_LIMIT_PACKETS - Maximum receive queue size in number of packets
                          [Default = 1024]
    QUEUE_LIMIT_OCTETS  - Maximum receive queue size in octets (total of all
                          packets in queue) [Default = 8 MiB]
  </pre><p> It is suggested that users start with the default set of options provided by <a class="el" href="namespacevrt_1_1NetUtilities.html#aea1867aba70c09841e4f27b298a43c98">NetUtilities#getDefaultSocketOptions</a>. Starting with an empty map (or simply passing in null) will use the o/s defaults, which may not be ideal for use with VITA-49 streams. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>isOutput</em>&nbsp;</td><td>Is this connection for output (true) or input (false)? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transport</em>&nbsp;</td><td>The transport being used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>host</em>&nbsp;</td><td>The host to connect to (null = wildcard address). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>The port number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>device</em>&nbsp;</td><td>The device to connect to (e.g. "eth0", "eth1.101") (null = use default). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>listener</em>&nbsp;</td><td>The primary listener to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>Map of options to set (can be null). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufLength</em>&nbsp;</td><td>The buffer length to use. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If an I/O execution occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac66344152297f7832d63409c673fdcac"></a><!-- doxytag: member="vrt::NetIO::~NetIO" ref="ac66344152297f7832d63409c673fdcac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual vrt::NetIO::~NetIO </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad45a69033e49f98250a4d37c45888be6"></a><!-- doxytag: member="vrt::NetIO::_tcpSocketRead" ref="ad45a69033e49f98250a4d37c45888be6" args="(void *buf, int32_t off, int32_t len, bool required)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::NetIO::_tcpSocketRead </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>required</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read from TCP socket with special handling for socket errors. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer to read data into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>The offset into the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The number of octets to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>required</em>&nbsp;</td><td>Is this a mandatory read? </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Output value from the socket read (number of octets read or EOF flag) *or* -999 if the read failed and/or the read had a required length and EOF was reached first. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3cce989e7d03733e1eb2a4aedd47df6"></a><!-- doxytag: member="vrt::NetIO::checkSockets" ref="ad3cce989e7d03733e1eb2a4aedd47df6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::NetIO::checkSockets </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks the current sockets, reconnecting as needed. </p>
<p>Also connects to any TCP clients. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if processing can continue, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa40f23a1dbbeeaa49020b204f0ced119"></a><!-- doxytag: member="vrt::NetIO::clearQueue" ref="aa40f23a1dbbeeaa49020b204f0ced119" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::NetIO::clearQueue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pops a packet off of the queue. </p>

</div>
</div>
<a class="anchor" id="ab1fedfc2a7a0552b70fe75bf298a257e"></a><!-- doxytag: member="vrt::NetIO::closeClientSockets" ref="ab1fedfc2a7a0552b70fe75bf298a257e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::NetIO::closeClientSockets </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes only the client sockets. </p>

</div>
</div>
<a class="anchor" id="a586e0ed1215bb3506964729b77d243dc"></a><!-- doxytag: member="vrt::NetIO::closeSockets" ref="a586e0ed1215bb3506964729b77d243dc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::NetIO::closeSockets </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes the sockets. </p>

</div>
</div>
<a class="anchor" id="a9c420b521ff47db33ca308ad4cbbac82"></a><!-- doxytag: member="vrt::NetIO::getActiveConnectionCount" ref="a9c420b521ff47db33ca308ad4cbbac82" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::NetIO::getActiveConnectionCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Gets the number of active connections. </p>
<p>This will be: </p>
<pre>
    -1  = UDP        (UDP is connectionless)
     0  = TCP Server (no active clients)
     N  = TCP Server (N  active clients)
     1  = TCP Client
  </pre> <dl class="return"><dt><b>Returns:</b></dt><dd>The number of active connections. </dd></dl>

</div>
</div>
<a class="anchor" id="a3fde1e634f6b6d9955fe72542777aa34"></a><!-- doxytag: member="vrt::NetIO::handle" ref="a3fde1e634f6b6d9955fe72542777aa34" args="(vector&lt; char &gt; *buffer, int32_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::NetIO::handle </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handles the packet read in. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>The data read in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of bytes read in. <em>[This is here for backwards-compatibility, it is always called with a value equal to <code>buffer.length</code>.]</em> </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classvrt_1_1VRTReader.html#a3c0ea2a279c000a1e42e88c63259f9a5">vrt::VRTReader</a>.</p>

</div>
</div>
<a class="anchor" id="a2cd1d407a0df2acf391895a40f42799c"></a><!-- doxytag: member="vrt::NetIO::openSockets" ref="a2cd1d407a0df2acf391895a40f42799c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::NetIO::openSockets </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes the sockets. </p>

</div>
</div>
<a class="anchor" id="a620213fe52adf0ffba6ff73ca3f51d32"></a><!-- doxytag: member="vrt::NetIO::popPacket" ref="a620213fe52adf0ffba6ff73ca3f51d32" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;char&gt;* vrt::NetIO::popPacket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pops a packet off of the queue. </p>

</div>
</div>
<a class="anchor" id="a866137d4d0352078bc87696a09e326bb"></a><!-- doxytag: member="vrt::NetIO::pushPacket" ref="a866137d4d0352078bc87696a09e326bb" args="(vector&lt; char &gt; *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::NetIO::pushPacket </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; *&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a packet to the processing queue. </p>

<p>References <a class="el" href="classvrt_1_1NetIO.html#a17ad0930971f17412d5135eab12628bf">pushPackets()</a>.</p>

</div>
</div>
<a class="anchor" id="a17ad0930971f17412d5135eab12628bf"></a><!-- doxytag: member="vrt::NetIO::pushPackets" ref="a17ad0930971f17412d5135eab12628bf" args="(vector&lt; char &gt; *first, vector&lt; vector&lt; char &gt; * &gt; *rest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::NetIO::pushPackets </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; *&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; char &gt; * &gt; *&nbsp;</td>
          <td class="paramname"> <em>rest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a set of packets to the processing queue. </p>
<p>This makes sure that all are pushed together at the same time. </p>

<p>Referenced by <a class="el" href="NetIO_8h_source.html#l00255">pushPacket()</a>.</p>

</div>
</div>
<a class="anchor" id="ad5dd9e183fbdc2981c26cd6113a9dc8c"></a><!-- doxytag: member="vrt::NetIO::receiveBuffer" ref="ad5dd9e183fbdc2981c26cd6113a9dc8c" args="(bool autoPush)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;char&gt;* vrt::NetIO::receiveBuffer </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autoPush</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads a single buffer from the input stream. </p>
<p>This method can not be used directly when the reader is running as a thread. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>autoPush</em>&nbsp;</td><td>Automatically push received packet onto queue if doing so would be more optimal than just returning it. (This is a "suggestion" in that the function is free to disregard the value of this and return the received buffer.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The buffer received or null if none read in. If <code>autoPush=true</code> and a buffer is added to the queue this must return <a class="el" href="classvrt_1_1NetIO.html#af91dfdf3e52f2537988b6c4fc17280f1">BUFFER_PUSHED</a>. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If an exception occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2ef7300feee7c63213b6c63a9a529b0"></a><!-- doxytag: member="vrt::NetIO::receiveBufferTCP" ref="ae2ef7300feee7c63213b6c63a9a529b0" args="(bool autoPush)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual vector&lt;char&gt;* vrt::NetIO::receiveBufferTCP </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autoPush</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive a packet via UDP. </p>

<p>Reimplemented in <a class="el" href="classvrt_1_1VRTReader.html#a30169776547ead63521d7976f78244fe">vrt::VRTReader</a>.</p>

</div>
</div>
<a class="anchor" id="a551265c20fb443561b70763fac29bbb7"></a><!-- doxytag: member="vrt::NetIO::receiveBufferUDP" ref="a551265c20fb443561b70763fac29bbb7" args="(bool autoPush)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual vector&lt;char&gt;* vrt::NetIO::receiveBufferUDP </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autoPush</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive a packet via UDP. </p>

<p>Reimplemented in <a class="el" href="classvrt_1_1VRTReader.html#a3fcc28f1e76c4514cbb464d9797b441e">vrt::VRTReader</a>.</p>

</div>
</div>
<a class="anchor" id="a31bb39c68ae659470be2edc0637f35d0"></a><!-- doxytag: member="vrt::NetIO::reconnect" ref="a31bb39c68ae659470be2edc0637f35d0" args="(const VRTEventListener &amp;warnings)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::NetIO::reconnect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1VRTEventListener.html">VRTEventListener</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>warnings</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Requests a reconnect and waits for it to be done. </p>

<p>Reimplemented in <a class="el" href="classvrt_1_1VRTReader.html#a2b9835475f60612c546804a2149450a3">vrt::VRTReader</a>.</p>

</div>
</div>
<a class="anchor" id="a0b2f212a94b9d92cbb48205072b5a3a7"></a><!-- doxytag: member="vrt::NetIO::runInputThread" ref="a0b2f212a94b9d92cbb48205072b5a3a7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::NetIO::runInputThread </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Version of <a class="el" href="classvrt_1_1NetIO.html#a1a74c4e2e582d3b3819b18ae0e79881a">runThread()</a> for an input connection. </p>

<p>Referenced by <a class="el" href="NetIO_8h_source.html#l00204">runThread()</a>.</p>

</div>
</div>
<a class="anchor" id="affb1bbf3e96f099c14e211a26be53def"></a><!-- doxytag: member="vrt::NetIO::runOutputThread" ref="affb1bbf3e96f099c14e211a26be53def" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::NetIO::runOutputThread </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Version of <a class="el" href="classvrt_1_1NetIO.html#a1a74c4e2e582d3b3819b18ae0e79881a">runThread()</a> for an output connection. </p>

<p>Referenced by <a class="el" href="NetIO_8h_source.html#l00204">runThread()</a>.</p>

</div>
</div>
<a class="anchor" id="a1a74c4e2e582d3b3819b18ae0e79881a"></a><!-- doxytag: member="vrt::NetIO::runThread" ref="a1a74c4e2e582d3b3819b18ae0e79881a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::NetIO::runThread </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Runs the thread. </p>

<p>Implements <a class="el" href="classvrt_1_1Threadable.html#a8241fcab1d40e24ddd99e7e317d1e0a3">vrt::Threadable</a>.</p>

<p>References <a class="el" href="classvrt_1_1NetIO.html#a0b2f212a94b9d92cbb48205072b5a3a7">runInputThread()</a>, and <a class="el" href="classvrt_1_1NetIO.html#affb1bbf3e96f099c14e211a26be53def">runOutputThread()</a>.</p>

</div>
</div>
<a class="anchor" id="a288079a9f97b0e886181f8cf188141eb"></a><!-- doxytag: member="vrt::NetIO::sendBuffer" ref="a288079a9f97b0e886181f8cf188141eb" args="(const void *buf, int32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::NetIO::sendBuffer </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends the UDP datagram *or* TCP buffer of data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The pointer to the data to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The number of octets in the buffer to send. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4462cb54dff6a42a08386d0e4d9bb7f3"></a><!-- doxytag: member="vrt::NetIO::sendBuffer" ref="a4462cb54dff6a42a08386d0e4d9bb7f3" args="(int32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::NetIO::sendBuffer </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends the UDP datagram *or* TCP buffer of data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The number of octets in the buffer to send. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43310a84a1e2d5c219aa1ccc31d789cd"></a><!-- doxytag: member="vrt::NetIO::shutdown" ref="a43310a84a1e2d5c219aa1ccc31d789cd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::NetIO::shutdown </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes any connections, This will always be called at the end of a call to <a class="el" href="classvrt_1_1Threadable.html#a1f4df829530dcd6a2748d79014aa6215">run()</a>. </p>

<p>Reimplemented from <a class="el" href="classvrt_1_1Threadable.html#a59fe63719971d2683c9a758dd8f8f05b">vrt::Threadable</a>.</p>

</div>
</div>
<a class="anchor" id="ad1883b9f2039c7394caf34211bf74e47"></a><!-- doxytag: member="vrt::NetIO::shutdownClientSockets" ref="ad1883b9f2039c7394caf34211bf74e47" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::NetIO::shutdownClientSockets </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shutdown only the client sockets. </p>

</div>
</div>
<a class="anchor" id="a2659351c35f5a907e3bf84d97c2b8d3d"></a><!-- doxytag: member="vrt::NetIO::shutdownSockets" ref="a2659351c35f5a907e3bf84d97c2b8d3d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::NetIO::shutdownSockets </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stops any future read/write on the sockets, but does not close them. </p>
<p>This permits i/o to continue until the underlying buffers are empty. </p>

</div>
</div>
<a class="anchor" id="ac1eb2071e7382c2f8379418347eed45b"></a><!-- doxytag: member="vrt::NetIO::start" ref="ac1eb2071e7382c2f8379418347eed45b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::NetIO::start </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts the object running in a new thread. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If already running. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classvrt_1_1Threadable.html#ab287487406c1bcf72985dae6fdd11663">vrt::Threadable</a>.</p>

</div>
</div>
<a class="anchor" id="a2830e8273c1dbaa9d46e5a7120d2725a"></a><!-- doxytag: member="vrt::NetIO::stop" ref="a2830e8273c1dbaa9d46e5a7120d2725a" args="(bool wait=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::NetIO::stop </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wait</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells the object to stop running. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wait</em>&nbsp;</td><td>Wait for the thread to complete (true)? </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classvrt_1_1Threadable.html#a766fdab10b4ef450f568fb4d1d6f2abb">vrt::Threadable</a>.</p>

</div>
</div>
<a class="anchor" id="a1e4bf123c34691e84885ee5b83ab5ff4"></a><!-- doxytag: member="vrt::NetIO::toString" ref="a1e4bf123c34691e84885ee5b83ab5ff4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual string vrt::NetIO::toString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides a description of the instance useful for debugging. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A debugging string. </dd></dl>

<p>Reimplemented from <a class="el" href="classvrt_1_1VRTObject.html#a8a8ca4be5d2b9075b6478685c2e121a1">vrt::VRTObject</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="af91dfdf3e52f2537988b6c4fc17280f1"></a><!-- doxytag: member="vrt::NetIO::BUFFER_PUSHED" ref="af91dfdf3e52f2537988b6c4fc17280f1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;char&gt;* <a class="el" href="classvrt_1_1NetIO.html#af91dfdf3e52f2537988b6c4fc17280f1">vrt::NetIO::BUFFER_PUSHED</a><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates that a buffer was already handled. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cpp_src/vrt/net/<a class="el" href="NetIO_8h_source.html">NetIO.h</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 29 Jun 2018 for VRT by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>

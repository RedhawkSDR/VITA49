<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VRT: vrt::BasicVRTPacket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>vrt</b>::<a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a>
  </div>
</div>
<div class="contents">
<h1>vrt::BasicVRTPacket Class Reference</h1><!-- doxytag: class="vrt::BasicVRTPacket" --><!-- doxytag: inherits="vrt::VRTObject,vrt::HasFields" -->
<p>A basic but full-featured implementation of <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a>.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BasicVRTPacket_8h_source.html">BasicVRTPacket.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vrt::BasicVRTPacket:</div>
<div class="dynsection">
 <div class="center">
  <img src="classvrt_1_1BasicVRTPacket.gif" usemap="#vrt::BasicVRTPacket_map" alt=""/>
  <map id="vrt::BasicVRTPacket_map" name="vrt::BasicVRTPacket_map">
<area href="classvrt_1_1VRTObject.html" alt="vrt::VRTObject" shape="rect" coords="1120,0,1334,24"/>
<area href="classvrt_1_1HasFields.html" alt="vrt::HasFields" shape="rect" coords="1344,0,1558,24"/>
<area href="classvrt_1_1BasicCommandPacket.html" alt="vrt::BasicCommandPacket" shape="rect" coords="112,112,326,136"/>
<area href="classvrt_1_1BasicContextPacket.html" alt="vrt::BasicContextPacket" shape="rect" coords="560,112,774,136"/>
<area href="classvrt_1_1BasicDataPacket.html" alt="vrt::BasicDataPacket" shape="rect" coords="1008,112,1222,136"/>
<area href="classvrt_1_1EphemerisPacket.html" alt="vrt::EphemerisPacket" shape="rect" coords="1232,112,1446,136"/>
<area href="classvrt_1_1ReferencePointPacket.html" alt="vrt::ReferencePointPacket" shape="rect" coords="1456,112,1670,136"/>
<area href="classvrt_1_1StreamStatePacket.html" alt="vrt::StreamStatePacket" shape="rect" coords="1680,112,1894,136"/>
<area href="classvrt_1_1TimestampAccuracyPacket.html" alt="vrt::TimestampAccuracyPacket" shape="rect" coords="1904,112,2118,136"/>
<area href="classvrt_1_1BasicAcknowledgePacket.html" alt="vrt::BasicAcknowledgePacket" shape="rect" coords="0,168,214,192"/>
<area href="classvrt_1_1BasicControlPacket.html" alt="vrt::BasicControlPacket" shape="rect" coords="224,168,438,192"/>
<area href="classvrt_1_1BasicControlPacket.html" alt="vrt::BasicControlPacket" shape="rect" coords="448,168,662,192"/>
<area href="classvrt_1_1StandardContextPacket.html" alt="vrt::StandardContextPacket" shape="rect" coords="672,168,886,192"/>
<area href="classvrt_1_1NoDataPacket.html" alt="vrt::NoDataPacket" shape="rect" coords="896,168,1110,192"/>
<area href="classvrt_1_1StandardDataPacket.html" alt="vrt::StandardDataPacket" shape="rect" coords="1120,168,1334,192"/>
<area href="classvrt_1_1BasicQueryAcknowledgePacket.html" alt="vrt::BasicQueryAcknowledgePacket" shape="rect" coords="224,224,438,248"/>
<area href="classvrt_1_1BasicQueryAcknowledgePacket.html" alt="vrt::BasicQueryAcknowledgePacket" shape="rect" coords="448,224,662,248"/>
</map>
 </div>
</div>

<p><a href="classvrt_1_1BasicVRTPacket-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a0ba906f50190f8988304705a0c5175aa">BasicVRTPacket</a> (const vector&lt; char &gt; &amp;buf, ssize_t start, ssize_t end, bool <a class="el" href="classvrt_1_1BasicVRTPacket.html#a40626801621f637d0be9da791c68e788">readOnly</a>=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new instance accessing the given data buffer.  <a href="#a0ba906f50190f8988304705a0c5175aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#abe71e0eb7a62f2c9268566629cdb03d3">BasicVRTPacket</a> (const vector&lt; char &gt; &amp;buf, bool <a class="el" href="classvrt_1_1BasicVRTPacket.html#a40626801621f637d0be9da791c68e788">readOnly</a>=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new instance accessing the given data buffer.  <a href="#abe71e0eb7a62f2c9268566629cdb03d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#aee7ade53d222cd8bac6a5b4f945b839d">BasicVRTPacket</a> (vector&lt; char &gt; *buf_ptr, bool <a class="el" href="classvrt_1_1BasicVRTPacket.html#a40626801621f637d0be9da791c68e788">readOnly</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new instance accessing the given data buffer.  <a href="#aee7ade53d222cd8bac6a5b4f945b839d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#ab3a6d1cd0682937ca114d1aebce05587">BasicVRTPacket</a> (const void *buf, size_t len, bool <a class="el" href="classvrt_1_1BasicVRTPacket.html#a40626801621f637d0be9da791c68e788">readOnly</a>=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new instance accessing the given data buffer.  <a href="#ab3a6d1cd0682937ca114d1aebce05587"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#abd4cf6edf68697727b575601c761dfd0">BasicVRTPacket</a> (int32_t bufsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new instance with a default anticipated length that can be written to.  <a href="#abd4cf6edf68697727b575601c761dfd0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#ae7646043432fbf0cdd1f83d3d29bf98e">BasicVRTPacket</a> (const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic copy constructor for the class.  <a href="#ae7646043432fbf0cdd1f83d3d29bf98e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#ad759b737aa0d0072951a7a29e4147c77">BasicVRTPacket</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic no-argument constructor for the class.  <a href="#ad759b737aa0d0072951a7a29e4147c77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a970926a235e07ecde86845b81ad011fb">~BasicVRTPacket</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic destructor for the class.  <a href="#a970926a235e07ecde86845b81ad011fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f539f32b5c502e9d6fae56b0266a81e"></a><!-- doxytag: member="vrt::BasicVRTPacket::equals" ref="a7f539f32b5c502e9d6fae56b0266a81e" args="(const VRTObject &amp;o) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>equals</b> (const <a class="el" href="classvrt_1_1VRTObject.html">VRTObject</a> &amp;o) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a9c8c4690d8cc6368963ccfc63fdb0ea5">equals</a> (const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;o) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for equality with an unknown object.  <a href="#a9c8c4690d8cc6368963ccfc63fdb0ea5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#abcb436b88206f309b6ac5e8fa5536e18">getClassID</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the class identifier as a string.  <a href="#abcb436b88206f309b6ac5e8fa5536e18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#aaf45b61252939459bc2096ec3df68be2">getClassIdentifier</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the packet class identifier.  <a href="#aaf45b61252939459bc2096ec3df68be2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a4f3ceb894e0d44437542e9213877a099">getClassIdentifierICC</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the Information Class Code (ICC) from the packet class identifier.  <a href="#a4f3ceb894e0d44437542e9213877a099"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a0e9edcc765d2548c46522bd953a51e88">getClassIdentifierOUI</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the Organizational Unique Identifier (OUI) from the packet class identifier.  <a href="#a0e9edcc765d2548c46522bd953a51e88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#acce1909af31212f76749574cfb810d8c">getClassIdentifierPCC</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the Packet Class Code (PCC) from the packet class identifier.  <a href="#acce1909af31212f76749574cfb810d8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvrt_1_1Value.html">Value</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a444461f6621a2b031f904440ae2a6fc1">getField</a> (int32_t id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value of a field, based on the field's id.  <a href="#a444461f6621a2b031f904440ae2a6fc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#aeec8ba3ed0fdc05f4ea766a80608ff24">getFieldCount</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of fields.  <a href="#aeec8ba3ed0fdc05f4ea766a80608ff24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a65153479839ceaa41b0a41373b02ca95">getFieldName</a> (int32_t id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the name of the given field.  <a href="#a65153479839ceaa41b0a41373b02ca95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ValueType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a4cb1678a3a71c7abda7c621b2f96363a">getFieldType</a> (int32_t id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the type associated with a given field.  <a href="#a4cb1678a3a71c7abda7c621b2f96363a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a0da41f9a95a036c7591f264fb992fb36">getHeaderLength</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the header length in bytes (does not include packet specific prologue or trailer).  <a href="#a0da41f9a95a036c7591f264fb992fb36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; char &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#abf7adc6d4d6f2cdd9fdfeebcef590ae7">getPacket</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the packet content as a vector.  <a href="#abf7adc6d4d6f2cdd9fdfeebcef590ae7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#aeaa5ba8e48855c2e27505a1f25875c96">getPacketCount</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the packet count.  <a href="#aeaa5ba8e48855c2e27505a1f25875c96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a40001fcd6ad5a5cc2532124048af3518">getPacketLength</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the packet length in bytes.  <a href="#a40001fcd6ad5a5cc2532124048af3518"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a4ce213365cd5f7f3e93e0af251dcc737">getPacketPointer</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Experimental, use with care:</b> Gets a pointer to the packet content.  <a href="#a4ce213365cd5f7f3e93e0af251dcc737"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a0bfd0a4e42ec4316bcb5f5af0a1f08eb">getPacketPointer_type</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Experimental, use with care:</b> Gets a pointer to the packet content.  <a href="#a0bfd0a4e42ec4316bcb5f5af0a1f08eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PacketType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a3e6eeeb361350724ee2e7c75c6c41c15">getPacketType</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the packet type.  <a href="#a3e6eeeb361350724ee2e7c75c6c41c15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a0f09daf0899cc4d9d069ecdfeaea0a0c">getPacketValid</a> (bool strict, int32_t length) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks to see if the packet is valid.  <a href="#a0f09daf0899cc4d9d069ecdfeaea0a0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a75a0cfaedb0818423b932ebaf633468e">getPacketValid</a> (bool strict) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks to see if the packet is valid.  <a href="#a75a0cfaedb0818423b932ebaf633468e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; char &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a7363dea90200c32c000dc6879d45e18b">getPacketVector</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the packet content as a vector.  <a href="#a7363dea90200c32c000dc6879d45e18b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#aaea92ae8c2ad2f925b3502536351dd45">getPadBitCount</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of pad bits inserted following the data in the payload such that the payload section is always a multiple of 4-bytes in length.  <a href="#aaea92ae8c2ad2f925b3502536351dd45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; char &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#ac1aba013c1743a58d53e6a55025285a3">getPayload</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the packet payload as a vector.  <a href="#ac1aba013c1743a58d53e6a55025285a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a408e5bbadcd6099619e264a412223c36">getPayloadLength</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the payload length in bytes.  <a href="#a408e5bbadcd6099619e264a412223c36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#af8678bf2163279e50610faa2b8abce9d">getPayloadPointer</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Experimental, use with care:</b> Gets a pointer to the packet payload.  <a href="#af8678bf2163279e50610faa2b8abce9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a4a6710bd7de5d1416c8377dc5a92d9a6">getPktSpecificPrologueLength</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the packet specific prologue (PSP) length in bytes.  <a href="#a4a6710bd7de5d1416c8377dc5a92d9a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the prologue length in bytes (includes header and packet specific prologue, but does not include trailer).  <a href="#a200f38adde97a2778b330fd75a5cbc8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#ae7173b3eb60dd514781a886f003b2b9b">getStreamCode</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal use only:</b> Swaps packet buffer contents.  <a href="#ae7173b3eb60dd514781a886f003b2b9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a96eb7bf885c6a47ec745623dc8e81d42">getStreamID</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the 32-bit packet stream identifier as a string.  <a href="#a96eb7bf885c6a47ec745623dc8e81d42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a0d88f3cd41dfa0cfc287d30c0d285bd4">getStreamIdentifier</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the 32-bit packet stream identifier.  <a href="#a0d88f3cd41dfa0cfc287d30c0d285bd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#ab380dc8f0635a24acd0f82e9eb2c36cb">getTimeStamp</a> (double sr) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the time stamp of the packet for the given sampling rate.  <a href="#ab380dc8f0635a24acd0f82e9eb2c36cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#aa3addceef948a38f998e049d7e7cc678">getTimeStamp</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the time stamp of the packet.  <a href="#aa3addceef948a38f998e049d7e7cc678"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#ae0b07bf5ad5721cbc4f4d769de18376b">getTrailerLength</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the trailer length in bytes.  <a href="#ae0b07bf5ad5721cbc4f4d769de18376b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a153b124b4aaa60133c196d2738c8a0c3">hasPacketSpecificPrologue</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does this packet have a packet specific prologue?  <a href="#a153b124b4aaa60133c196d2738c8a0c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a4fc0ecb41084a1d92f48b903e5172f1d">hasTrailer</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does this packet have a trailer?  <a href="#a4fc0ecb41084a1d92f48b903e5172f1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a494e79a853503875310d23fd8f57265d">headerEquals</a> (const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;p) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for header equality with another <a class="el" href="classvrt_1_1BasicVRTPacket.html" title="A basic but full-featured implementation of BasicVRTPacket.">BasicVRTPacket</a>.  <a href="#a494e79a853503875310d23fd8f57265d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a82261fee92bccb499235af9b827ba44b">isCancelMode</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Command packets only: Gets the Cancel Mode (L).  <a href="#a82261fee92bccb499235af9b827ba44b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#afa9520fde9f8c9501116cb7fc0536da4">isChangePacket</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates if any fields have changes since the last packet in this stream.  <a href="#afa9520fde9f8c9501116cb7fc0536da4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a5a04d5fdcbe16ad478078a475fdbf79f">isCommand</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is the packet type a command packet?  <a href="#a5a04d5fdcbe16ad478078a475fdbf79f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#ac7c1c59ed02580aaa841d46833527f24">isContext</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is the packet type a context packet?  <a href="#ac7c1c59ed02580aaa841d46833527f24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a283d2bbfc6b9d0c7726359105c900fb0">isControlAckMode</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Command packets only: Gets the Control/Ack Mode (ACK).  <a href="#a283d2bbfc6b9d0c7726359105c900fb0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a14275e1f04deb4d188c53a8ffb762e22">isData</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is the packet type a data packet?  <a href="#a14275e1f04deb4d188c53a8ffb762e22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a0676d7327afcd889e3873782c8f63235">isNullValue</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this object equal to null.  <a href="#a0676d7327afcd889e3873782c8f63235"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a90d6690a4cccdecc901625839af3e5d4">isPacketValid</a> (int32_t length) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks to see if the packet is valid.  <a href="#a90d6690a4cccdecc901625839af3e5d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#abada575c980c2e20543d3f0bfbaaad9f">isPacketValid</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks to see if the packet is valid.  <a href="#abada575c980c2e20543d3f0bfbaaad9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#ac49c072692ebf58852246960501e84b6">isSpectrumMode</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data packets only: Gets the Signal Spectrum Data Mode (S).  <a href="#ac49c072692ebf58852246960501e84b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a7a1ca133afc41ae297b5dfca4e539617">isTimeStampMode</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Context packets only: Gets the Time Stamp Mode (TSM).  <a href="#a7a1ca133afc41ae297b5dfca4e539617"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a5e4e169b34625be2d378b9de73a6bfd4">payloadEquals</a> (const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;p) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for payload equality with another <a class="el" href="classvrt_1_1BasicVRTPacket.html" title="A basic but full-featured implementation of BasicVRTPacket.">BasicVRTPacket</a>.  <a href="#a5e4e169b34625be2d378b9de73a6bfd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a17f4e865550c8484e46624a1ed84277e">pktSpecificPrologueEquals</a> (const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;p) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for packet specific prologue (PSP) equality with another <a class="el" href="classvrt_1_1BasicVRTPacket.html" title="A basic but full-featured implementation of BasicVRTPacket.">BasicVRTPacket</a>.  <a href="#a17f4e865550c8484e46624a1ed84277e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a208052c0b7c835c330ee11c38e5ac832">prologueEquals</a> (const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;p) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for prologue equality with another <a class="el" href="classvrt_1_1BasicVRTPacket.html" title="A basic but full-featured implementation of BasicVRTPacket.">BasicVRTPacket</a>.  <a href="#a208052c0b7c835c330ee11c38e5ac832"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a5eb34f257552e3908bd046dc85aeffdd">readPacket</a> (void *buffer, int32_t poff, int32_t len) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the packet payload into the provided buffer.  <a href="#a5eb34f257552e3908bd046dc85aeffdd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a7b6cd3b3102e227a8819650503e62ee4">readPayload</a> (void *buffer, int32_t poff, int32_t len) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the packet payload into the provided buffer.  <a href="#a7b6cd3b3102e227a8819650503e62ee4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#ab2302481a1c9dea1ca3f86571b27ec79">resetForResend</a> (const <a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> &amp;t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepares a packet for resend resetting any non-persistent values and clearing the context change flags.  <a href="#ab2302481a1c9dea1ca3f86571b27ec79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a75d0c290d5f89061027884192643816c">setCancelMode</a> (bool v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Command packets only: Gets the Cancel Mode (L).  <a href="#a75d0c290d5f89061027884192643816c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a173201b351780482420cfddc1218c45b">setClassID</a> (string v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets the packet class identifier.  <a href="#a173201b351780482420cfddc1218c45b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a6bbd162709c8442d2e169adb07cddf05">setClassIdentifier</a> (int32_t oui, int16_t icc, int16_t pcc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets the packet class identifier.  <a href="#a6bbd162709c8442d2e169adb07cddf05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a59a0d4a44c700f346c04ae930c0846ff">setClassIdentifier</a> (int64_t v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets the packet class identifier.  <a href="#a59a0d4a44c700f346c04ae930c0846ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a6be05da88012d420c0c321b227866666">setControlAckMode</a> (bool v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Command packets only: Sets the Control/Ack Mode (ACK).  <a href="#a6be05da88012d420c0c321b227866666"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a832f112f8f1b4f4b6bbb117af7a7239e">setField</a> (int32_t id, const <a class="el" href="classvrt_1_1Value.html">Value</a> *val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the value of a field, based on the field's id.  <a href="#a832f112f8f1b4f4b6bbb117af7a7239e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a433e63307c5a881eb4ecf8f43922475d">setPacketCount</a> (int32_t v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets the packet count.  <a href="#a433e63307c5a881eb4ecf8f43922475d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#ae215e242805855769eb7b1f840cc0da9">setPacketType</a> (PacketType t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets the packet type.  <a href="#ae215e242805855769eb7b1f840cc0da9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a974c8c2393fc1b4c7f75111010e250b0">setPadBitCount</a> (int32_t bits, int32_t bitsPerSample)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets the number of pad bits inserted following the data in the payload such that the payload section is always a multiple of 4-bytes in length (see <a class="el" href="classvrt_1_1BasicVRTPacket.html#aaea92ae8c2ad2f925b3502536351dd45">getPadBitCount()</a> for a detailed discussion about the reporting of pad bits).  <a href="#a974c8c2393fc1b4c7f75111010e250b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a86569211e1a389937bcaf3e852879eb1">setPayload</a> (void *buffer, int32_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets the content of the packet payload and updates the length of the payload.  <a href="#a86569211e1a389937bcaf3e852879eb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a8e87bf5dcbc5b4bfe0d2cdea4bca20a4">setPayload</a> (vector&lt; char &gt; buffer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets the content of the packet payload and updates the length of the payload.  <a href="#a8e87bf5dcbc5b4bfe0d2cdea4bca20a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#aa624a0ad7411af7dc8fdd173f0f80ffc">setPayloadLength</a> (int32_t v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets the payload length in bytes.  <a href="#aa624a0ad7411af7dc8fdd173f0f80ffc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#ac5f1e603d5f0d1366c54228fc9595705">setSpectrumMode</a> (bool v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Data packets only: Sets the Signal Spectrum Data Mode (S).  <a href="#ac5f1e603d5f0d1366c54228fc9595705"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a1572bd49ff24ace9e986bc3e0937f377">setStreamID</a> (string v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets the 32-bit packet stream identifier.  <a href="#a1572bd49ff24ace9e986bc3e0937f377"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#aa02ec067a110ac93582143c44a9cd956">setStreamIdentifier</a> (int32_t v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets the 32-bit packet stream identifier.  <a href="#aa02ec067a110ac93582143c44a9cd956"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#aea367e62bfcf7eca8047e9c05373c04e">setTimeStamp</a> (const <a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets the time stamp for the packet.  <a href="#aea367e62bfcf7eca8047e9c05373c04e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#aaa40fc36ff16b000a74bfc637a093078">setTimeStampMode</a> (bool v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Context packets only: Sets the Time Stamp Mode (TSM).  <a href="#aaa40fc36ff16b000a74bfc637a093078"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#aa676a350d0107aeb8edab093fe3767e3">swap</a> (<a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> *pkt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Does a buffer swap.  <a href="#aa676a350d0107aeb8edab093fe3767e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a4cc0f78031a5a367834227be7a4337d6">swap</a> (vector&lt; char &gt; *buffer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Does a buffer swap.  <a href="#a4cc0f78031a5a367834227be7a4337d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a13b21e225e6ead2ef13f3553a8ef96f8">toString</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts this class its string form.  <a href="#a13b21e225e6ead2ef13f3553a8ef96f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#ad36365da9033cfaba2823bf297a95dd7">trailerEquals</a> (const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;p, bool exact) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for trailer equality with another <a class="el" href="classvrt_1_1BasicVRTPacket.html" title="A basic but full-featured implementation of BasicVRTPacket.">BasicVRTPacket</a>.  <a href="#ad36365da9033cfaba2823bf297a95dd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a26c1f6d9e5f9a022d937a1a0455df6c6">trailerEquals</a> (const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;p) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for trailer equality with another <a class="el" href="classvrt_1_1BasicVRTPacket.html" title="A basic but full-featured implementation of BasicVRTPacket.">BasicVRTPacket</a>.  <a href="#a26c1f6d9e5f9a022d937a1a0455df6c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a74d62dc0c3372e6fdff366e9dc518589">writePayload</a> (void *buffer, int32_t poff, int32_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Writes to the packet payload, but does NOT update the length of the payload.  <a href="#a74d62dc0c3372e6fdff366e9dc518589"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#ad84c42c68baa0da7f9b4d2273227c57d">getPacketLength</a> (const vector&lt; char &gt; &amp;buf, int32_t off)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Get VRT packet length using a buffer input.  <a href="#ad84c42c68baa0da7f9b4d2273227c57d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a117c0c5f6a0d603acb3538b768d35103">getStreamCode</a> (const void *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal use only:</b> Gets the packet stream code.  <a href="#a117c0c5f6a0d603acb3538b768d35103"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a04ba853230821ea2e90f379785fc69d6">setPacketCount</a> (void *ptr, int32_t v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Sets the packet count.  <a href="#a04ba853230821ea2e90f379785fc69d6"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; char &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a11bdcad0429c5f6899f5a37848d4ffb2">bbuf</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packet buffer (always includes the header).  <a href="#a11bdcad0429c5f6899f5a37848d4ffb2"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#aa10f55e3e65fdbb63a621a8d278f9a2b">MAX_HEADER_LENGTH</a> = 7*4</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum length of the header in bytes (all optional fields included).  <a href="#aa10f55e3e65fdbb63a621a8d278f9a2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#ace1fce903f77599d549f3ae7943a1b9e">MAX_PACKET_LENGTH</a> = 65536*4</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum length of the packet in bytes (header + payload + trailer).  <a href="#ace1fce903f77599d549f3ae7943a1b9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a02ab6f6b7075f9e481abeecbfe095c45">MAX_PAYLOAD_LENGTH</a> = <a class="el" href="classvrt_1_1BasicVRTPacket.html#ace1fce903f77599d549f3ae7943a1b9e">MAX_PACKET_LENGTH</a> - <a class="el" href="classvrt_1_1BasicVRTPacket.html#aa747a5913faf7dcce6f79a3ced6a4007">MAX_PROLOGUE_LENGTH</a> - <a class="el" href="classvrt_1_1BasicVRTPacket.html#a74f683b39777f1e9289d6e3d7fe55dde">MAX_TRAILER_LENGTH</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <b>de-facto</b> maximum length of the payload in bytes.  <a href="#a02ab6f6b7075f9e481abeecbfe095c45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#aa2d11cdbf080d8fef18da55596bbe85e">MAX_PKT_SPECIFIC_PROLOGUE_LENGTH</a> = 10*4</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum length of the packet specific prologue (PSP) in bytes (all optional fields included).  <a href="#aa2d11cdbf080d8fef18da55596bbe85e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#aa747a5913faf7dcce6f79a3ced6a4007">MAX_PROLOGUE_LENGTH</a> = <a class="el" href="classvrt_1_1BasicVRTPacket.html#aa10f55e3e65fdbb63a621a8d278f9a2b">MAX_HEADER_LENGTH</a> + <a class="el" href="classvrt_1_1BasicVRTPacket.html#aa2d11cdbf080d8fef18da55596bbe85e">MAX_PKT_SPECIFIC_PROLOGUE_LENGTH</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum length of the prologue in bytes (all optional fields included).  <a href="#aa747a5913faf7dcce6f79a3ced6a4007"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a74f683b39777f1e9289d6e3d7fe55dde">MAX_TRAILER_LENGTH</a> = 1*4</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum length of the trailer in bytes.  <a href="#a74f683b39777f1e9289d6e3d7fe55dde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#aa2d0565c557146d39cc817a7f7b2241d">NULL_PACKET</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a null VRT packet.  <a href="#aa2d0565c557146d39cc817a7f7b2241d"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a28700e4954b393500b3c5b70334857a5">BasicVRTPacket</a> (const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;p, PacketType type, int64_t classID, int32_t minPayloadLength, int32_t maxPayloadLength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal constructor, for use by subclasses.  <a href="#a28700e4954b393500b3c5b70334857a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#aedce90e5f33fd34c5c5968626e1c53ad">hasStreamIdentifier</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal use only:</b> Does the packet type have a stream identifier.  <a href="#aedce90e5f33fd34c5c5968626e1c53ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a680d026fc3b81d0d6c1e9fb7bc27b949">packPayloadAscii</a> (int32_t off, string val, int32_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs an ASCII string into the payload of the packet.  <a href="#a680d026fc3b81d0d6c1e9fb7bc27b949"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a7ac23c01f1dce1287f3c9ee76cf87553">packPayloadBoolean</a> (int32_t off, bool val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs a boolean value into the payload of the packet.  <a href="#a7ac23c01f1dce1287f3c9ee76cf87553"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a49ef62862d40493e4cd694269f525b08">packPayloadBoolNull</a> (int32_t off, boolNull val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs a <code>boolNull</code> value into the payload of the packet.  <a href="#a49ef62862d40493e4cd694269f525b08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#afbeb2663a36a0e7c5db41b70aebaef9e">packPayloadByte</a> (int32_t off, char val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs an 8-bit integer into the payload of the packet.  <a href="#afbeb2663a36a0e7c5db41b70aebaef9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a70c5432fa52fee585d6c178243616285">packPayloadBytes</a> (int32_t off, const void *val, int32_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs a block of bytes into the payload of the packet.  <a href="#a70c5432fa52fee585d6c178243616285"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#afad208489c43f384919fee5b9de27c67">packPayloadBytes</a> (int32_t off, const vector&lt; char &gt; &amp;val, int32_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs a block of bytes into the payload of the packet.  <a href="#afad208489c43f384919fee5b9de27c67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a97df14586888c9174608b61bce661cdc">packPayloadDouble</a> (int32_t off, double val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs a 64-bit floating-point value into the payload of the packet.  <a href="#a97df14586888c9174608b61bce661cdc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#aea27b9bcf68173cefa512366e67577e4">packPayloadFloat</a> (int32_t off, float val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs a 32-bit floating-point value into the payload of the packet.  <a href="#aea27b9bcf68173cefa512366e67577e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#afc9d38e9a6bb4a4c8de35ae811bccf2e">packPayloadInetAddr</a> (int32_t off, <a class="el" href="classvrt_1_1InetAddress.html">InetAddress</a> val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs a <a class="el" href="classvrt_1_1InetAddress.html">InetAddress</a> into the payload of the packet.  <a href="#afc9d38e9a6bb4a4c8de35ae811bccf2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a1a9f8ac2649d3299cc5e7c3d598a4390">packPayloadInt</a> (int32_t off, int32_t val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs a 32-bit integer into the payload of the packet.  <a href="#a1a9f8ac2649d3299cc5e7c3d598a4390"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#af687b8f4a50cb1cc0ce6d523d0885a01">packPayloadLong</a> (int32_t off, int64_t val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs a 64-bit integer into the payload of the packet.  <a href="#af687b8f4a50cb1cc0ce6d523d0885a01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#acb2907ab39b0db8acdb0b33feeac5de3">packPayloadMetadata</a> (int32_t off, <a class="el" href="classvrt_1_1MetadataBlock.html">MetadataBlock</a> val, int32_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs a metadata block into the payload of the packet.  <a href="#acb2907ab39b0db8acdb0b33feeac5de3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#ae42a70513e6ee01891995d8eab44a7c5">packPayloadRecord</a> (int32_t off, <a class="el" href="classvrt_1_1Record.html">Record</a> val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs a record value into the payload of the packet.  <a href="#ae42a70513e6ee01891995d8eab44a7c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a67288365a88ec115a587bd0bc6058bb0">packPayloadShort</a> (int32_t off, int16_t val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs a 16-bit integer into the payload of the packet.  <a href="#a67288365a88ec115a587bd0bc6058bb0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#afe798f55a6a9292082e7d62c649beaff">packPayloadTimeStamp</a> (int32_t off, <a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> val, IntegerMode epoch)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs a <a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> into the payload of the packet.  <a href="#afe798f55a6a9292082e7d62c649beaff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a7bbe4a057be215992e01a69606c7bc16">packPayloadUTF8</a> (int32_t off, string val, int32_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs a UTF-8 string into the payload of the packet.  <a href="#a7bbe4a057be215992e01a69606c7bc16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a9fbd27e881c5a4a3e4f2a536fce9c65d">packPayloadUTF8</a> (int32_t off, wstring val, int32_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs a UTF-8 string into the payload of the packet.  <a href="#a9fbd27e881c5a4a3e4f2a536fce9c65d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#af06ceeeb371f915351df4b31b115f4ec">packPayloadUUID</a> (int32_t off, <a class="el" href="classvrt_1_1UUID.html">UUID</a> val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs a <a class="el" href="classvrt_1_1UUID.html">UUID</a> into the payload of the packet.  <a href="#af06ceeeb371f915351df4b31b115f4ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a40a7e24752e1aca33b56c309870e0d0d">setPacketLength</a> (int32_t v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal use only:</b> Sets the packet length.  <a href="#a40a7e24752e1aca33b56c309870e0d0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#ade1909da7e741c4cce1d9cc80038c439">shiftHeader</a> (int32_t field, int32_t bytes, bool present)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal use only:</b> Shifts the header.  <a href="#ade1909da7e741c4cce1d9cc80038c439"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a28fd26d966e7c84abdc07df670bf2f81">shiftPacketSpecificPrologue</a> (int32_t off, int32_t bytes, bool add)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal use only:</b> Shifts the packet specific prologue (PSP).  <a href="#a28fd26d966e7c84abdc07df670bf2f81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a93d23c45790e2d5078d93849e905abab">shiftPayload</a> (int32_t off, int32_t bytes, bool add)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal use only:</b> Shifts the payload.  <a href="#a93d23c45790e2d5078d93849e905abab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a7a14aa0880827fc29132b5f3c0b15fed">shiftTrailer</a> (bool add)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal use only:</b> Shifts the trailer.  <a href="#a7a14aa0880827fc29132b5f3c0b15fed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a1cdf8b4c9288d38516b8325a8a95b268">toStringStream</a> (ostringstream &amp;str) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the packet content to a string stream in a user-friendly format.  <a href="#a1cdf8b4c9288d38516b8325a8a95b268"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a6b844a70aaeaa39092f5ed6df11d9782">unpackPayloadAscii</a> (int32_t off, int32_t len) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks an ASCII string from the payload of the packet.  <a href="#a6b844a70aaeaa39092f5ed6df11d9782"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a99c2c7450c162dab673985f57b3e6a66">unpackPayloadBoolean</a> (int32_t off) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks a boolean value from the payload of the packet.  <a href="#a99c2c7450c162dab673985f57b3e6a66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#abfdcffe82511e71c9dea29e12ef5e62f">unpackPayloadBoolNull</a> (int32_t off) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks a <code>boolNull</code> value from the payload of the packet.  <a href="#abfdcffe82511e71c9dea29e12ef5e62f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a8bd046cedab9244740ffee5b28c670cd">unpackPayloadByte</a> (int32_t off) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks an 8-bit integer from the payload of the packet.  <a href="#a8bd046cedab9244740ffee5b28c670cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#ade26a3d5157f3a7efbbb5a3470778ceb">unpackPayloadBytes</a> (int32_t off, void *val, int32_t len) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks a block of bytes from the payload of the packet.  <a href="#ade26a3d5157f3a7efbbb5a3470778ceb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; char &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a09e534ac7e70c34091f83da9882b9b0b">unpackPayloadBytes</a> (int32_t off, int32_t len) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks a block of bytes from the payload of the packet.  <a href="#a09e534ac7e70c34091f83da9882b9b0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a69f3c039115623ab4298b60585daa33c">unpackPayloadDouble</a> (int32_t off) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks a 64-bit floating-point value from the payload of the packet.  <a href="#a69f3c039115623ab4298b60585daa33c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#af432ee5a3e8a97349e96ed78523bbebc">unpackPayloadFloat</a> (int32_t off) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks a 32-bit floating-point value from the payload of the packet.  <a href="#af432ee5a3e8a97349e96ed78523bbebc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrt_1_1InetAddress.html">InetAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a45f3a58b6a06ec785080e9d0c986fedf">unpackPayloadInetAddr</a> (int32_t off) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks a <a class="el" href="classvrt_1_1InetAddress.html">InetAddress</a> from the payload of the packet.  <a href="#a45f3a58b6a06ec785080e9d0c986fedf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a8780af80abf334ac4b1984ab003586a6">unpackPayloadInt</a> (int32_t off) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks a 32-bit integer from the payload of the packet.  <a href="#a8780af80abf334ac4b1984ab003586a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#af32b45b09d2d1c80dfc1797874ea0638">unpackPayloadLong</a> (int32_t off) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks a 64-bit integer from the payload of the packet.  <a href="#af32b45b09d2d1c80dfc1797874ea0638"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrt_1_1MetadataBlock.html">MetadataBlock</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a25c8ae1cfb4ecc1f14c7ac3870fcc769">unpackPayloadMetadata</a> (int32_t off, int32_t len) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks a metadata block from the payload of the packet.  <a href="#a25c8ae1cfb4ecc1f14c7ac3870fcc769"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a72b46b8fab765919e60f2c710d5fd832">unpackPayloadRecord</a> (int32_t off, <a class="el" href="classvrt_1_1Record.html">Record</a> &amp;rec) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks a record from the payload of the packet.  <a href="#a72b46b8fab765919e60f2c710d5fd832"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a331f8f0dc0e3a6f6dc681f02ce6fa41a">unpackPayloadShort</a> (int32_t off) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks a 16-bit integer from the payload of the packet.  <a href="#a331f8f0dc0e3a6f6dc681f02ce6fa41a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a4baf23471e2c07a8ecfdd80e2513bf96">unpackPayloadTimeStamp</a> (int32_t off, IntegerMode epoch) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks a <a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> from the payload of the packet.  <a href="#a4baf23471e2c07a8ecfdd80e2513bf96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a72d6603b1ccf650daab309a4c64132ed">unpackPayloadUTF8</a> (int32_t off, int32_t len) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks a UTF-8 string from the payload of the packet.  <a href="#a72d6603b1ccf650daab309a4c64132ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrt_1_1UUID.html">UUID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a39f048ff416d2a0824317ba62820c97f">unpackPayloadUUID</a> (int32_t off) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks a <a class="el" href="classvrt_1_1UUID.html">UUID</a> from the payload of the packet.  <a href="#a39f048ff416d2a0824317ba62820c97f"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#aece0316a5d3a949e27f87e7d0e390045">getStateEventBit</a> (const vector&lt; char &gt; &amp;buf, int32_t off, int32_t enable, int32_t indicator)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the specified bit from the trailer.  <a href="#aece0316a5d3a949e27f87e7d0e390045"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a5fd725908b81bcab95d7954d406dc437">setStateEventBit</a> (vector&lt; char &gt; &amp;buf, int32_t off, int32_t enable, int32_t indicator, boolNull value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>Optional functionality:</em> Sets the specified bit from the trailer.  <a href="#a5fd725908b81bcab95d7954d406dc437"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrt_1_1BasicVRTPacket.html#a40626801621f637d0be9da791c68e788">readOnly</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this instance read-only?  <a href="#a40626801621f637d0be9da791c68e788"></a><br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad828945a6479609a10d2d5019bc1e3e5"></a><!-- doxytag: member="vrt::BasicVRTPacket::VRTReader" ref="ad828945a6479609a10d2d5019bc1e3e5" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>VRTReader</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A basic but full-featured implementation of <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a>. </p>
<p><br/>
 <br/>
 The following implementation is used for the <a class="el" href="classvrt_1_1HasFields.html">HasFields</a> methods: </p>
<pre>
     ID | Name      | Type
    ----+-----------+-----------
     0  | StreamID  | String
     1  | ClassID   | String
     2  | <a class="el" href="classvrt_1_1TimeStamp.html" title="An immutable time stamp.">TimeStamp</a> | <a class="el" href="classvrt_1_1TimeStamp.html" title="An immutable time stamp.">TimeStamp</a>
    ----+-----------+-----------
  </pre> <hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a970926a235e07ecde86845b81ad011fb"></a><!-- doxytag: member="vrt::BasicVRTPacket::~BasicVRTPacket" ref="a970926a235e07ecde86845b81ad011fb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicVRTPacket::~BasicVRTPacket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Basic destructor for the class. </p>

</div>
</div>
<a class="anchor" id="ad759b737aa0d0072951a7a29e4147c77"></a><!-- doxytag: member="vrt::BasicVRTPacket::BasicVRTPacket" ref="ad759b737aa0d0072951a7a29e4147c77" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicVRTPacket::BasicVRTPacket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Basic no-argument constructor for the class. </p>

</div>
</div>
<a class="anchor" id="ae7646043432fbf0cdd1f83d3d29bf98e"></a><!-- doxytag: member="vrt::BasicVRTPacket::BasicVRTPacket" ref="ae7646043432fbf0cdd1f83d3d29bf98e" args="(const BasicVRTPacket &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicVRTPacket::BasicVRTPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Basic copy constructor for the class. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The packet to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd4cf6edf68697727b575601c761dfd0"></a><!-- doxytag: member="vrt::BasicVRTPacket::BasicVRTPacket" ref="abd4cf6edf68697727b575601c761dfd0" args="(int32_t bufsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicVRTPacket::BasicVRTPacket </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bufsize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new instance with a default anticipated length that can be written to. </p>
<p>Initially this will just be a simple data packet with streamID, classID, no trailer, TSI=UTC, TSF=Real-Time, and a packet length of 7. The underlying buffers will be pre-allocated as required. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufsize</em>&nbsp;</td><td>The anticipated buffer size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3a6d1cd0682937ca114d1aebce05587"></a><!-- doxytag: member="vrt::BasicVRTPacket::BasicVRTPacket" ref="ab3a6d1cd0682937ca114d1aebce05587" args="(const void *buf, size_t len, bool readOnly=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicVRTPacket::BasicVRTPacket </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>readOnly</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new instance accessing the given data buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The pointer to the packet buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the packet buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>readOnly</em>&nbsp;</td><td>Should users of this instance be able to modify the underlying data buffer? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee7ade53d222cd8bac6a5b4f945b839d"></a><!-- doxytag: member="vrt::BasicVRTPacket::BasicVRTPacket" ref="aee7ade53d222cd8bac6a5b4f945b839d" args="(vector&lt; char &gt; *buf_ptr, bool readOnly)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicVRTPacket::BasicVRTPacket </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; *&nbsp;</td>
          <td class="paramname"> <em>buf_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>readOnly</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new instance accessing the given data buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf_ptr</em>&nbsp;</td><td>The pointer to the packet buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>readOnly</em>&nbsp;</td><td>Should users of this instance be able to modify the underlying data buffer? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abe71e0eb7a62f2c9268566629cdb03d3"></a><!-- doxytag: member="vrt::BasicVRTPacket::BasicVRTPacket" ref="abe71e0eb7a62f2c9268566629cdb03d3" args="(const vector&lt; char &gt; &amp;buf, bool readOnly=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicVRTPacket::BasicVRTPacket </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>readOnly</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new instance accessing the given data buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The pointer to the packet buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>readOnly</em>&nbsp;</td><td>Should users of this instance be able to modify the underlying data buffer? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ba906f50190f8988304705a0c5175aa"></a><!-- doxytag: member="vrt::BasicVRTPacket::BasicVRTPacket" ref="a0ba906f50190f8988304705a0c5175aa" args="(const vector&lt; char &gt; &amp;buf, ssize_t start, ssize_t end, bool readOnly=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicVRTPacket::BasicVRTPacket </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>readOnly</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new instance accessing the given data buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The pointer to the packet buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>The start point in buffer to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The end point in buffer to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>readOnly</em>&nbsp;</td><td>Should users of this instance be able to modify the underlying data buffer? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28700e4954b393500b3c5b70334857a5"></a><!-- doxytag: member="vrt::BasicVRTPacket::BasicVRTPacket" ref="a28700e4954b393500b3c5b70334857a5" args="(const BasicVRTPacket &amp;p, PacketType type, int64_t classID, int32_t minPayloadLength, int32_t maxPayloadLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vrt::BasicVRTPacket::BasicVRTPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PacketType&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>classID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>minPayloadLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>maxPayloadLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal constructor, for use by subclasses. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The packet (already initialized). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The expected packet type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>classID</em>&nbsp;</td><td>The expected classID. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minPayloadLength</em>&nbsp;</td><td>The minimum payload length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxPayloadLength</em>&nbsp;</td><td>The maximum payload length (&lt;0 if not pre-defined). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If packet type or classID of the packet are invalid, or if the payload length is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9c8c4690d8cc6368963ccfc63fdb0ea5"></a><!-- doxytag: member="vrt::BasicVRTPacket::equals" ref="a9c8c4690d8cc6368963ccfc63fdb0ea5" args="(const BasicVRTPacket &amp;o) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool vrt::BasicVRTPacket::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>o</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for equality with an unknown object. </p>
<p>Two VRT packets are considered equal if the content of the packets is bit-for-bit identical. The actual implementation classes are not considered relevant for checking equality. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>The unknown object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if they are identical, false otherwise. (This will always returns false if the object is null.) </dd></dl>

<p>Reimplemented from <a class="el" href="classvrt_1_1VRTObject.html#a2f18f4efc73c423629510033039536fc">vrt::VRTObject</a>.</p>

</div>
</div>
<a class="anchor" id="abcb436b88206f309b6ac5e8fa5536e18"></a><!-- doxytag: member="vrt::BasicVRTPacket::getClassID" ref="abcb436b88206f309b6ac5e8fa5536e18" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual string vrt::BasicVRTPacket::getClassID </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the class identifier as a string. </p>
<p>This will return the class identifier in the form <code>CC-CC-CC:IIII.PPPP</code> where <code>CC-CC-CC</code> is the standard hexadecimal representation of the OUI (see IEEE standard 802-2001), IIII is the hexadecimal representation of the ICC and PPPP is the hexadecimal representation of the PCC. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The packet class identifier as a string or null if not specified. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf45b61252939459bc2096ec3df68be2"></a><!-- doxytag: member="vrt::BasicVRTPacket::getClassIdentifier" ref="aaf45b61252939459bc2096ec3df68be2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t vrt::BasicVRTPacket::getClassIdentifier </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the packet class identifier. </p>
<p>Note that the the packet class identifier is the union of the three distinct parts of the class identifier: OUI, ICC, and PCC. This method allows for easy comparison of the class identifier as a whole. <em>Note that if this is null, the OUI, ICC, and PCC will all be null; if this is non-null, the OUI, ICC, and PCC will all be non-null.</em> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The packet class identifier or INT8_NULL if not specified. </dd></dl>

<p>Referenced by <a class="el" href="StandardDataPacket_8h_source.html#l00203">vrt::StandardDataPacket::getPayloadFormat()</a>.</p>

</div>
</div>
<a class="anchor" id="a4f3ceb894e0d44437542e9213877a099"></a><!-- doxytag: member="vrt::BasicVRTPacket::getClassIdentifierICC" ref="a4f3ceb894e0d44437542e9213877a099" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int16_t vrt::BasicVRTPacket::getClassIdentifierICC </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the Information Class Code (ICC) from the packet class identifier. </p>
<p>This is a user-defined value specified by the OUI (see <a class="el" href="classvrt_1_1BasicVRTPacket.html#a0e9edcc765d2548c46522bd953a51e88">getClassIdentifierOUI()</a>) that defined this packet class. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The ICC or null if not specified. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e9edcc765d2548c46522bd953a51e88"></a><!-- doxytag: member="vrt::BasicVRTPacket::getClassIdentifierOUI" ref="a0e9edcc765d2548c46522bd953a51e88" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t vrt::BasicVRTPacket::getClassIdentifierOUI </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the Organizational Unique Identifier (OUI) from the packet class identifier. </p>
<p>The OUI is a 24-bit IEEE-assigned identifier for the organization that defined the packet class. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The OUI or null if not specified. </dd></dl>

</div>
</div>
<a class="anchor" id="acce1909af31212f76749574cfb810d8c"></a><!-- doxytag: member="vrt::BasicVRTPacket::getClassIdentifierPCC" ref="acce1909af31212f76749574cfb810d8c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int16_t vrt::BasicVRTPacket::getClassIdentifierPCC </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the Packet Class Code (PCC) from the packet class identifier. </p>
<p>This is a user-defined value specified by the OUI (see <a class="el" href="classvrt_1_1BasicVRTPacket.html#a0e9edcc765d2548c46522bd953a51e88">getClassIdentifierOUI()</a>) that defined this packet class. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The ICC or null if not specified. </dd></dl>

</div>
</div>
<a class="anchor" id="a444461f6621a2b031f904440ae2a6fc1"></a><!-- doxytag: member="vrt::BasicVRTPacket::getField" ref="a444461f6621a2b031f904440ae2a6fc1" args="(int32_t id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classvrt_1_1Value.html">Value</a>* vrt::BasicVRTPacket::getField </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the value of a field, based on the field's id. </p>
<p><br/>
 <br/>
 <b>WARNING: The caller is responsible for deleting the memory referenced by the returned pointer.</b> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>The field ID (on range <code>[0,<a class="el" href="classvrt_1_1BasicVRTPacket.html#aeec8ba3ed0fdc05f4ea766a80608ff24" title="Gets the number of fields.">getFieldCount()</a>)</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the given value. </dd></dl>

<p>Reimplemented from <a class="el" href="classvrt_1_1HasFields.html#ac653a6e68dad8fd22489704944bf408e">vrt::HasFields</a>.</p>

<p>Reimplemented in <a class="el" href="classvrt_1_1BasicContextPacket.html#aa7712267a45b15ffa36794664cf0fec8">vrt::BasicContextPacket</a>, <a class="el" href="classvrt_1_1BasicDataPacket.html#a8be80b0dbd51e2755cb04e37935eb1de">vrt::BasicDataPacket</a>, <a class="el" href="classvrt_1_1EphemerisPacket.html#aed03bdb1e6b6d4d704a9dc3b71c4d9cf">vrt::EphemerisPacket</a>, <a class="el" href="classvrt_1_1NoDataPacket.html#a8762fa7d98809cb34232172f40a1209c">vrt::NoDataPacket</a>, <a class="el" href="classvrt_1_1ReferencePointPacket.html#aeda658ca6c2c032166fe3423eda38560">vrt::ReferencePointPacket</a>, <a class="el" href="classvrt_1_1StandardContextPacket.html#ac0831abbeb8e89b43b3a29b1619ee602">vrt::StandardContextPacket</a>, <a class="el" href="classvrt_1_1StreamStatePacket.html#a7a258642f33a3b5d3c4c551225eab627">vrt::StreamStatePacket</a>, and <a class="el" href="classvrt_1_1TimestampAccuracyPacket.html#aa44bea7e13b60d07f4a98e0fd9ddda55">vrt::TimestampAccuracyPacket</a>.</p>

</div>
</div>
<a class="anchor" id="aeec8ba3ed0fdc05f4ea766a80608ff24"></a><!-- doxytag: member="vrt::BasicVRTPacket::getFieldCount" ref="aeec8ba3ed0fdc05f4ea766a80608ff24" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t vrt::BasicVRTPacket::getFieldCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the number of fields. </p>

<p>Reimplemented from <a class="el" href="classvrt_1_1HasFields.html#aa120887068872c3d6d44505fa9dd61d7">vrt::HasFields</a>.</p>

<p>Reimplemented in <a class="el" href="classvrt_1_1BasicContextPacket.html#aeffe5c14da711834f45fa86ae530ff74">vrt::BasicContextPacket</a>, <a class="el" href="classvrt_1_1BasicDataPacket.html#ad0c765c6f4e0807af2b42b92e9bc4526">vrt::BasicDataPacket</a>, <a class="el" href="classvrt_1_1EphemerisPacket.html#ae70672650ca0a5dd4343fc66f0bd4c54">vrt::EphemerisPacket</a>, <a class="el" href="classvrt_1_1NoDataPacket.html#a35b24910e9d1fcc95080c831d42be5c0">vrt::NoDataPacket</a>, <a class="el" href="classvrt_1_1ReferencePointPacket.html#aa441218fa887f9c7491658d18cde2440">vrt::ReferencePointPacket</a>, <a class="el" href="classvrt_1_1StandardContextPacket.html#a2a773b05ea23fb5cda8a638f5c61775c">vrt::StandardContextPacket</a>, <a class="el" href="classvrt_1_1StreamStatePacket.html#a09fbc6e9f18f376cb46c7530a35bba47">vrt::StreamStatePacket</a>, and <a class="el" href="classvrt_1_1TimestampAccuracyPacket.html#afbd529162670d93da692df6cf4db2b68">vrt::TimestampAccuracyPacket</a>.</p>

</div>
</div>
<a class="anchor" id="a65153479839ceaa41b0a41373b02ca95"></a><!-- doxytag: member="vrt::BasicVRTPacket::getFieldName" ref="a65153479839ceaa41b0a41373b02ca95" args="(int32_t id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual string vrt::BasicVRTPacket::getFieldName </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the name of the given field. </p>
<p>In 90% of cases the field name will be identical to the name used in the applicable get/set function except without the get/set prefix (e.g. "SourceContext" for "getSourceContext"). It is possible to access the names of all fields via the following: </p>
<pre>
    for (int32_t id = 0; id &lt; <a class="el" href="classvrt_1_1BasicVRTPacket.html#aeec8ba3ed0fdc05f4ea766a80608ff24" title="Gets the number of fields.">getFieldCount()</a>; id++) {
      // id is the field ID
      getFieldName(id);
    }
  </pre><p> In situations where it is desirable to access all available fields, it is faster to use the field ID as this eliminates any string comparisons. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>The field ID (on range <code>[0,<a class="el" href="classvrt_1_1BasicVRTPacket.html#aeec8ba3ed0fdc05f4ea766a80608ff24" title="Gets the number of fields.">getFieldCount()</a>)</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The field name. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>if the field id is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classvrt_1_1HasFields.html#ac07274097de2f35f74710d0cf74cddaf">vrt::HasFields</a>.</p>

<p>Reimplemented in <a class="el" href="classvrt_1_1BasicContextPacket.html#ac576b99c63755ca37cdc397a5f7fc604">vrt::BasicContextPacket</a>, <a class="el" href="classvrt_1_1BasicDataPacket.html#ad22cc3fcdc17ebcbb2c95106ba448b61">vrt::BasicDataPacket</a>, <a class="el" href="classvrt_1_1EphemerisPacket.html#a43d3ddb68e2fd96a9b143ca70189550a">vrt::EphemerisPacket</a>, <a class="el" href="classvrt_1_1NoDataPacket.html#ae6cc0e5ab24e49e07ada5e913af25c4b">vrt::NoDataPacket</a>, <a class="el" href="classvrt_1_1ReferencePointPacket.html#aac7627794f0c1408a64a4b6745527aa0">vrt::ReferencePointPacket</a>, <a class="el" href="classvrt_1_1StandardContextPacket.html#ada6c4f29edc2eabbf6f4bb916e3c90cb">vrt::StandardContextPacket</a>, <a class="el" href="classvrt_1_1StreamStatePacket.html#acabc921b9360ce63da6a21de7856ad1f">vrt::StreamStatePacket</a>, and <a class="el" href="classvrt_1_1TimestampAccuracyPacket.html#afc1430c5bb78fe563c0c676c04709a62">vrt::TimestampAccuracyPacket</a>.</p>

</div>
</div>
<a class="anchor" id="a4cb1678a3a71c7abda7c621b2f96363a"></a><!-- doxytag: member="vrt::BasicVRTPacket::getFieldType" ref="a4cb1678a3a71c7abda7c621b2f96363a" args="(int32_t id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ValueType vrt::BasicVRTPacket::getFieldType </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the type associated with a given field. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>The field ID (on range <code>[0,<a class="el" href="classvrt_1_1BasicVRTPacket.html#aeec8ba3ed0fdc05f4ea766a80608ff24" title="Gets the number of fields.">getFieldCount()</a>)</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The field type (n &gt; 0) or -N if the field is a vector of values where N is the component type of the vector. </dd></dl>

<p>Reimplemented from <a class="el" href="classvrt_1_1HasFields.html#ac0808fd37f45dfcc0f76c7ceaceb553d">vrt::HasFields</a>.</p>

<p>Reimplemented in <a class="el" href="classvrt_1_1BasicContextPacket.html#af274bb458105f4fbee75a1590561e8b5">vrt::BasicContextPacket</a>, <a class="el" href="classvrt_1_1BasicDataPacket.html#a8013a7abb16b51db23230578ba7b8d64">vrt::BasicDataPacket</a>, <a class="el" href="classvrt_1_1EphemerisPacket.html#ad1412b64c51644f7987402867d0b40e2">vrt::EphemerisPacket</a>, <a class="el" href="classvrt_1_1NoDataPacket.html#a1719ffd852ef276e58a8dce7f51bccf9">vrt::NoDataPacket</a>, <a class="el" href="classvrt_1_1ReferencePointPacket.html#a82d0ce6221469018f1f9a7280c2104a4">vrt::ReferencePointPacket</a>, <a class="el" href="classvrt_1_1StandardContextPacket.html#ad071e32ce3d52885350a3657cccb1cbe">vrt::StandardContextPacket</a>, <a class="el" href="classvrt_1_1StreamStatePacket.html#a0a58177f49118acfbb32ea227e5b011b">vrt::StreamStatePacket</a>, and <a class="el" href="classvrt_1_1TimestampAccuracyPacket.html#a0be3359af283839cbf697ec1f544ff7a">vrt::TimestampAccuracyPacket</a>.</p>

</div>
</div>
<a class="anchor" id="a0da41f9a95a036c7591f264fb992fb36"></a><!-- doxytag: member="vrt::BasicVRTPacket::getHeaderLength" ref="a0da41f9a95a036c7591f264fb992fb36" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t vrt::BasicVRTPacket::getHeaderLength </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the header length in bytes (does not include packet specific prologue or trailer). </p>
<p>The length of the header will be a value <b>up to</b> <a class="el" href="classvrt_1_1BasicVRTPacket.html#aa10f55e3e65fdbb63a621a8d278f9a2b">MAX_HEADER_LENGTH</a>. The header length will always be a multiple of 4-bytes. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The length of the header in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="abf7adc6d4d6f2cdd9fdfeebcef590ae7"></a><!-- doxytag: member="vrt::BasicVRTPacket::getPacket" ref="abf7adc6d4d6f2cdd9fdfeebcef590ae7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;char&gt; vrt::BasicVRTPacket::getPacket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the packet content as a vector. </p>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l00863">getPacketVector()</a>.</p>

</div>
</div>
<a class="anchor" id="aeaa5ba8e48855c2e27505a1f25875c96"></a><!-- doxytag: member="vrt::BasicVRTPacket::getPacketCount" ref="aeaa5ba8e48855c2e27505a1f25875c96" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t vrt::BasicVRTPacket::getPacketCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the packet count. </p>
<p>This is the modulo-16 count of all packets on this stream. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The packet count (0..15). </dd></dl>

</div>
</div>
<a class="anchor" id="ad84c42c68baa0da7f9b4d2273227c57d"></a><!-- doxytag: member="vrt::BasicVRTPacket::getPacketLength" ref="ad84c42c68baa0da7f9b4d2273227c57d" args="(const vector&lt; char &gt; &amp;buf, int32_t off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t vrt::BasicVRTPacket::getPacketLength </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Get VRT packet length using a buffer input. </p>

</div>
</div>
<a class="anchor" id="a40001fcd6ad5a5cc2532124048af3518"></a><!-- doxytag: member="vrt::BasicVRTPacket::getPacketLength" ref="a40001fcd6ad5a5cc2532124048af3518" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t vrt::BasicVRTPacket::getPacketLength </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the packet length in bytes. </p>
<p>The length of the header will be a value <b>up to</b> <a class="el" href="classvrt_1_1BasicVRTPacket.html#ace1fce903f77599d549f3ae7943a1b9e">MAX_PACKET_LENGTH</a> (see <a class="el" href="classvrt_1_1BasicVRTPacket.html#ace1fce903f77599d549f3ae7943a1b9e">MAX_PACKET_LENGTH</a> for explanation as to why actual packet lengths used are usually a lot less than this number). The packet length will always be a multiple of 4-bytes. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The total length of the packet in bytes. </dd></dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>.</p>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l00619">getPayloadLength()</a>.</p>

</div>
</div>
<a class="anchor" id="a4ce213365cd5f7f3e93e0af251dcc737"></a><!-- doxytag: member="vrt::BasicVRTPacket::getPacketPointer" ref="a4ce213365cd5f7f3e93e0af251dcc737" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* vrt::BasicVRTPacket::getPacketPointer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Experimental, use with care:</b> Gets a pointer to the packet content. </p>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l00872">getPacketPointer_type()</a>.</p>

</div>
</div>
<a class="anchor" id="a0bfd0a4e42ec4316bcb5f5af0a1f08eb"></a><!-- doxytag: member="vrt::BasicVRTPacket::getPacketPointer_type" ref="a0bfd0a4e42ec4316bcb5f5af0a1f08eb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* vrt::BasicVRTPacket::getPacketPointer_type </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Experimental, use with care:</b> Gets a pointer to the packet content. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>This function is present for backwards-compatibility with a user-extension, the proper function to use is <code><a class="el" href="classvrt_1_1BasicVRTPacket.html#a4ce213365cd5f7f3e93e0af251dcc737" title="Experimental, use with care: Gets a pointer to the packet content.">getPacketPointer()</a></code>. </dd></dl>

<p>References <a class="el" href="classvrt_1_1BasicVRTPacket.html#a4ce213365cd5f7f3e93e0af251dcc737">getPacketPointer()</a>.</p>

</div>
</div>
<a class="anchor" id="a3e6eeeb361350724ee2e7c75c6c41c15"></a><!-- doxytag: member="vrt::BasicVRTPacket::getPacketType" ref="a3e6eeeb361350724ee2e7c75c6c41c15" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PacketType vrt::BasicVRTPacket::getPacketType </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the packet type. </p>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l00359">hasStreamIdentifier()</a>.</p>

</div>
</div>
<a class="anchor" id="a0f09daf0899cc4d9d069ecdfeaea0a0c"></a><!-- doxytag: member="vrt::BasicVRTPacket::getPacketValid" ref="a0f09daf0899cc4d9d069ecdfeaea0a0c" args="(bool strict, int32_t length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual string vrt::BasicVRTPacket::getPacketValid </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>strict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks to see if the packet is valid. </p>
<p>This is identical to <code>isPacketValid(int32_t)</code> except that a description of the error is returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strict</em>&nbsp;</td><td>Should strict checking be done, or just enough to verify that things are OK for reading. No packet failing strict checking should ever be sent out, but it may be useful to disable strict checking when reading in a packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Verifies that the length of the packet matches this value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty string ("") if it is valid, a description of the error otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="classvrt_1_1BasicCommandPacket.html#a4716cfda99101722eef6096dbf9b4485">vrt::BasicCommandPacket</a>, <a class="el" href="classvrt_1_1BasicContextPacket.html#a9f29563dc9672db682a28e1762bdce4c">vrt::BasicContextPacket</a>, <a class="el" href="classvrt_1_1BasicControlPacket.html#a68dba5a6ce4b30256aef34f0b135f8de">vrt::BasicControlPacket</a>, <a class="el" href="classvrt_1_1BasicDataPacket.html#aeba2eca140af729e176d8c628f497cf5">vrt::BasicDataPacket</a>, <a class="el" href="classvrt_1_1StandardDataPacket.html#ad8162920cb8afb64b6dcd5209dd5e953">vrt::StandardDataPacket</a>, <a class="el" href="classvrt_1_1EphemerisPacket.html#a575813113c25d361c46982bdc0a6c4b9">vrt::EphemerisPacket</a>, <a class="el" href="classvrt_1_1NoDataPacket.html#a37cd51914b5eda5cfc98cdcdba5f0918">vrt::NoDataPacket</a>, <a class="el" href="classvrt_1_1ReferencePointPacket.html#a1a6fe538027381cae9a0f621e27f8ac2">vrt::ReferencePointPacket</a>, <a class="el" href="classvrt_1_1StandardContextPacket.html#a8143c684d50ee8c8fc4d41bdb7cfbdcf">vrt::StandardContextPacket</a>, <a class="el" href="classvrt_1_1StreamStatePacket.html#ae8b2345643dc36976f64c642dfeada03">vrt::StreamStatePacket</a>, and <a class="el" href="classvrt_1_1TimestampAccuracyPacket.html#a2d310492254388ce10c9434e5020124f">vrt::TimestampAccuracyPacket</a>.</p>

</div>
</div>
<a class="anchor" id="a75a0cfaedb0818423b932ebaf633468e"></a><!-- doxytag: member="vrt::BasicVRTPacket::getPacketValid" ref="a75a0cfaedb0818423b932ebaf633468e" args="(bool strict) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vrt::BasicVRTPacket::getPacketValid </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>strict</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks to see if the packet is valid. </p>
<p>This is identical to <code><a class="el" href="classvrt_1_1BasicVRTPacket.html#abada575c980c2e20543d3f0bfbaaad9f" title="Checks to see if the packet is valid.">isPacketValid()</a></code> except that a description of the error is returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strict</em>&nbsp;</td><td>Should strict checking be done, or just enough to verify that things are OK for reading. No packet failing strict checking should ever be sent out, but it may be useful to disable strict checking when reading in a packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty string ("") if it is valid, a description of the error otherwise. </dd></dl>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l00467">isPacketValid()</a>.</p>

</div>
</div>
<a class="anchor" id="a7363dea90200c32c000dc6879d45e18b"></a><!-- doxytag: member="vrt::BasicVRTPacket::getPacketVector" ref="a7363dea90200c32c000dc6879d45e18b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;char&gt; vrt::BasicVRTPacket::getPacketVector </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the packet content as a vector. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>This function is present for backwards-compatibility with a user-extension, the proper function to use is <code><a class="el" href="classvrt_1_1BasicVRTPacket.html#abf7adc6d4d6f2cdd9fdfeebcef590ae7" title="Reads the packet content as a vector.">getPacket()</a></code>. </dd></dl>

<p>References <a class="el" href="classvrt_1_1BasicVRTPacket.html#abf7adc6d4d6f2cdd9fdfeebcef590ae7">getPacket()</a>.</p>

</div>
</div>
<a class="anchor" id="aaea92ae8c2ad2f925b3502536351dd45"></a><!-- doxytag: member="vrt::BasicVRTPacket::getPadBitCount" ref="aaea92ae8c2ad2f925b3502536351dd45" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t vrt::BasicVRTPacket::getPadBitCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the number of pad bits inserted following the data in the payload such that the payload section is always a multiple of 4-bytes in length. </p>
<p>The number of pad bits is stored in five of the (formerly-reserved) bits in the ClassID block in the header as part of the suggested VITA-49.0 modifications (i.e. VITA-49.0b), but could be specified elsewhere for some user-defined class types. (The default implementation exclusively follows VITA-49.0b.) <br/>
 Note that reporting the number of pad bits is optional in situations where the number of pad bits is less than the length of a single sample (this may occur when using the link-efficient packing mode with a data format that does not evenly divide into a 32-/64-bit length). In this situation, the number of pad bits is implicit and can be determined after consideration of the data payload format and payload length (see <a class="el" href="classvrt_1_1BasicDataPacket.html#ade26b4b982fd93adf72f752cd93bf732">BasicDataPacket#getDataLength()</a>). This usage matches the VITA-49.0 specification. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of pad bits *reported* for a data packet. This will return 0 for context packets and data packets that do not report the number of pad bits. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classvrt_1_1BasicVRTPacket.html#a408e5bbadcd6099619e264a412223c36" title="Gets the payload length in bytes.">getPayloadLength()</a> </dd>
<dd>
<a class="el" href="classvrt_1_1BasicDataPacket.html#ade26b4b982fd93adf72f752cd93bf732" title="Gets the length of the data in number of elements.">BasicDataPacket::getDataLength()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac1aba013c1743a58d53e6a55025285a3"></a><!-- doxytag: member="vrt::BasicVRTPacket::getPayload" ref="ac1aba013c1743a58d53e6a55025285a3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;char&gt; vrt::BasicVRTPacket::getPayload </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the packet payload as a vector. </p>

</div>
</div>
<a class="anchor" id="a408e5bbadcd6099619e264a412223c36"></a><!-- doxytag: member="vrt::BasicVRTPacket::getPayloadLength" ref="a408e5bbadcd6099619e264a412223c36" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicVRTPacket::getPayloadLength </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the payload length in bytes. </p>
<p>The payload length is a derived value computed as: </p>
<pre>
    payloadLength = <a class="el" href="classvrt_1_1BasicVRTPacket.html#a40001fcd6ad5a5cc2532124048af3518">getPacketLength()</a> - <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a> - <a class="el" href="classvrt_1_1BasicVRTPacket.html#ae0b07bf5ad5721cbc4f4d769de18376b">getTrailerLength()</a>
  </pre><p> The payload length will always be a multiple of 4-bytes. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The length of the payload in bytes. </dd></dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00603">getPacketLength()</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="classvrt_1_1BasicVRTPacket.html#ae0b07bf5ad5721cbc4f4d769de18376b">getTrailerLength()</a>.</p>

<p>Referenced by <a class="el" href="BasicDataPacket_8h_source.html#l00678">vrt::BasicDataPacket::getData()</a>, <a class="el" href="ReferencePointPacket_8h_source.html#l00129">vrt::ReferencePointPacket::getDescription()</a>, <a class="el" href="StreamStatePacket_8h_source.html#l00312">vrt::StreamStatePacket::getMessage()</a>, <a class="el" href="EphemerisPacket_8h_source.html#l00551">vrt::EphemerisPacket::getPointCount()</a>, and <a class="el" href="BasicDataPacket_8h_source.html#l01192">vrt::BasicDataPacket::setData()</a>.</p>

</div>
</div>
<a class="anchor" id="af8678bf2163279e50610faa2b8abce9d"></a><!-- doxytag: member="vrt::BasicVRTPacket::getPayloadPointer" ref="af8678bf2163279e50610faa2b8abce9d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* vrt::BasicVRTPacket::getPayloadPointer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Experimental, use with care:</b> Gets a pointer to the packet payload. </p>

</div>
</div>
<a class="anchor" id="a4a6710bd7de5d1416c8377dc5a92d9a6"></a><!-- doxytag: member="vrt::BasicVRTPacket::getPktSpecificPrologueLength" ref="a4a6710bd7de5d1416c8377dc5a92d9a6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t vrt::BasicVRTPacket::getPktSpecificPrologueLength </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the packet specific prologue (PSP) length in bytes. </p>
<p>The length of the PSP will be a value <b>up to</b> <a class="el" href="classvrt_1_1BasicVRTPacket.html#aa2d11cdbf080d8fef18da55596bbe85e">MAX_PKT_SPECIFIC_PROLOGUE_LENGTH</a>. The PSP length will always be a multiple of 4-bytes. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The length of the packet specific prologue in bytes. </dd></dl>

<p>Reimplemented in <a class="el" href="classvrt_1_1BasicCommandPacket.html#a09be68308a83d8391436bedc4b104651">vrt::BasicCommandPacket</a>, and <a class="el" href="classvrt_1_1BasicControlPacket.html#a081f7ed57723743433d3e86edeed8e6b">vrt::BasicControlPacket</a>.</p>

</div>
</div>
<a class="anchor" id="a200f38adde97a2778b330fd75a5cbc8d"></a><!-- doxytag: member="vrt::BasicVRTPacket::getPrologueLength" ref="a200f38adde97a2778b330fd75a5cbc8d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t vrt::BasicVRTPacket::getPrologueLength </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the prologue length in bytes (includes header and packet specific prologue, but does not include trailer). </p>
<p>The length of the prologue will be a value <b>up to</b> <a class="el" href="classvrt_1_1BasicVRTPacket.html#aa747a5913faf7dcce6f79a3ced6a4007">MAX_PROLOGUE_LENGTH</a>. The prologue length will always be a multiple of 4-bytes. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The length of the prologue in bytes. </dd></dl>

<p>Reimplemented in <a class="el" href="classvrt_1_1BasicCommandPacket.html#a2bd7b5952c6fdee424fe8faad91f82e1">vrt::BasicCommandPacket</a>, and <a class="el" href="classvrt_1_1BasicControlPacket.html#a442228f7a5b94844edf913e8b409868d">vrt::BasicControlPacket</a>.</p>

<p>Referenced by <a class="el" href="BasicContextPacket_8h_source.html#l00316">vrt::BasicContextPacket::getContextIndicatorField0()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00883">vrt::BasicDataPacket::getDataByte()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00723">vrt::BasicDataPacket::getDataDouble()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00755">vrt::BasicDataPacket::getDataFloat()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00819">vrt::BasicDataPacket::getDataInt()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00787">vrt::BasicDataPacket::getDataLong()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00851">vrt::BasicDataPacket::getDataShort()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00619">getPayloadLength()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00982">packPayloadAscii()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00965">packPayloadBoolean()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00963">packPayloadBoolNull()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00951">packPayloadByte()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00971">packPayloadBytes()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00961">packPayloadDouble()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00959">packPayloadFloat()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00977">packPayloadInetAddr()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00955">packPayloadInt()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00957">packPayloadLong()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00969">packPayloadMetadata()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00967">packPayloadRecord()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00953">packPayloadShort()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00975">packPayloadTimeStamp()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00995">packPayloadUTF8()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00979">packPayloadUUID()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01365">vrt::BasicDataPacket::setDataByte()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01230">vrt::BasicDataPacket::setDataDouble()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01257">vrt::BasicDataPacket::setDataFloat()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01311">vrt::BasicDataPacket::setDataInt()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01284">vrt::BasicDataPacket::setDataLong()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01338">vrt::BasicDataPacket::setDataShort()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01039">unpackPayloadAscii()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01035">unpackPayloadBoolean()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01033">unpackPayloadBoolNull()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01021">unpackPayloadByte()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01045">unpackPayloadBytes()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01031">unpackPayloadDouble()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01029">unpackPayloadFloat()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01051">unpackPayloadInetAddr()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01025">unpackPayloadInt()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01027">unpackPayloadLong()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01043">unpackPayloadMetadata()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01037">unpackPayloadRecord()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01023">unpackPayloadShort()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01049">unpackPayloadTimeStamp()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01041">unpackPayloadUTF8()</a>, and <a class="el" href="BasicVRTPacket_8h_source.html#l01053">unpackPayloadUUID()</a>.</p>

</div>
</div>
<a class="anchor" id="aece0316a5d3a949e27f87e7d0e390045"></a><!-- doxytag: member="vrt::BasicVRTPacket::getStateEventBit" ref="aece0316a5d3a949e27f87e7d0e390045" args="(const vector&lt; char &gt; &amp;buf, int32_t off, int32_t enable, int32_t indicator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static boolNull vrt::BasicVRTPacket::getStateEventBit </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>indicator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the specified bit from the trailer. </p>
<p>By default all of the "is" methods that access the trailer call this method with the appropriate bit values (no other combinations of inputs is valid): </p>
<pre>
    Name                Enable Indicator
    ====================================
    CalibratedTimeStamp   31      19
    DataValid             30      18
    ReferenceLocked       29      17
    AutomaticGainControl  28      16
    SignalDetected        27      15
    InvertedSpectrum      26      14
    OverRange             25      13
    Discontinuious        24      12
    Bit11                 23      11 (Data and ExtData Only)
    Bit10                 22      10 (Data and ExtData Only)
    Bit9                  21       9 (Data and ExtData Only)
    Bit8                  20       8 (Data and ExtData Only)
  </pre> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The data buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>The offset into the data buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>Bit position of the enable flag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indicator</em>&nbsp;</td><td>Bit position of the indicator flag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>null if there is no trailer, null if the enable bit is not set, true if the enable bit is set and the indicator bit is set, false if the enable bit is set but the indicator bit is not set. </dd></dl>

</div>
</div>
<a class="anchor" id="a117c0c5f6a0d603acb3538b768d35103"></a><!-- doxytag: member="vrt::BasicVRTPacket::getStreamCode" ref="a117c0c5f6a0d603acb3538b768d35103" args="(const void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int64_t vrt::BasicVRTPacket::getStreamCode </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal use only:</b> Gets the packet stream code. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to the packet content. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The packet stream code. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7173b3eb60dd514781a886f003b2b9b"></a><!-- doxytag: member="vrt::BasicVRTPacket::getStreamCode" ref="ae7173b3eb60dd514781a886f003b2b9b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vrt::BasicVRTPacket::getStreamCode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal use only:</b> Swaps packet buffer contents. </p>
<p><b>Internal use only:</b> Swaps packet buffer contents. <b>Internal use only:</b> Gets the packet stream code. The stream code is a 64-bit value equal to: <code> 0xt0000000ssssssss where t = is the numeric value corresponding to the packet type s = the stream identifier or 0x00000000 if not specified </code> This is used as the hashtable key when doing packet sequence accounting since the counters are unique to the stream and type. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The packet stream code. </dd></dl>

</div>
</div>
<a class="anchor" id="a96eb7bf885c6a47ec745623dc8e81d42"></a><!-- doxytag: member="vrt::BasicVRTPacket::getStreamID" ref="a96eb7bf885c6a47ec745623dc8e81d42" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual string vrt::BasicVRTPacket::getStreamID </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the 32-bit packet stream identifier as a string. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The stream identifier or null if not specified. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d88f3cd41dfa0cfc287d30c0d285bd4"></a><!-- doxytag: member="vrt::BasicVRTPacket::getStreamIdentifier" ref="a0d88f3cd41dfa0cfc287d30c0d285bd4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t vrt::BasicVRTPacket::getStreamIdentifier </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the 32-bit packet stream identifier. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The stream identifier or INT4_NULL if not specified. </dd></dl>

</div>
</div>
<a class="anchor" id="ab380dc8f0635a24acd0f82e9eb2c36cb"></a><!-- doxytag: member="vrt::BasicVRTPacket::getTimeStamp" ref="ab380dc8f0635a24acd0f82e9eb2c36cb" args="(double sr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> vrt::BasicVRTPacket::getTimeStamp </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>sr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the time stamp of the packet for the given sampling rate. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sr</em>&nbsp;</td><td>the sampling rate </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The time stamp of the packet (never null). </dd></dl>

</div>
</div>
<a class="anchor" id="aa3addceef948a38f998e049d7e7cc678"></a><!-- doxytag: member="vrt::BasicVRTPacket::getTimeStamp" ref="aa3addceef948a38f998e049d7e7cc678" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> vrt::BasicVRTPacket::getTimeStamp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the time stamp of the packet. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The time stamp of the packet (never null). </dd></dl>

<p>Referenced by <a class="el" href="BasicContextPacket_8h_source.html#l00210">vrt::BasicContextPacket::getAdjustedTimeStamp()</a>.</p>

</div>
</div>
<a class="anchor" id="ae0b07bf5ad5721cbc4f4d769de18376b"></a><!-- doxytag: member="vrt::BasicVRTPacket::getTrailerLength" ref="ae0b07bf5ad5721cbc4f4d769de18376b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicVRTPacket::getTrailerLength </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the trailer length in bytes. </p>
<p>Note that the presence of the trailer is an all-or-nothing, so this method return either <a class="el" href="classvrt_1_1BasicVRTPacket.html#a74f683b39777f1e9289d6e3d7fe55dde">MAX_TRAILER_LENGTH</a> or <code>0</code>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The length of the trailer in bytes. </dd></dl>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l00619">getPayloadLength()</a>.</p>

</div>
</div>
<a class="anchor" id="a153b124b4aaa60133c196d2738c8a0c3"></a><!-- doxytag: member="vrt::BasicVRTPacket::hasPacketSpecificPrologue" ref="a153b124b4aaa60133c196d2738c8a0c3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::BasicVRTPacket::hasPacketSpecificPrologue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Does this packet have a packet specific prologue? </p>

</div>
</div>
<a class="anchor" id="aedce90e5f33fd34c5c5968626e1c53ad"></a><!-- doxytag: member="vrt::BasicVRTPacket::hasStreamIdentifier" ref="aedce90e5f33fd34c5c5968626e1c53ad" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::BasicVRTPacket::hasStreamIdentifier </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal use only:</b> Does the packet type have a stream identifier. </p>

<p>References <a class="el" href="classvrt_1_1BasicVRTPacket.html#a3e6eeeb361350724ee2e7c75c6c41c15">getPacketType()</a>.</p>

</div>
</div>
<a class="anchor" id="a4fc0ecb41084a1d92f48b903e5172f1d"></a><!-- doxytag: member="vrt::BasicVRTPacket::hasTrailer" ref="a4fc0ecb41084a1d92f48b903e5172f1d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::BasicVRTPacket::hasTrailer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Does this packet have a trailer? </p>

</div>
</div>
<a class="anchor" id="a494e79a853503875310d23fd8f57265d"></a><!-- doxytag: member="vrt::BasicVRTPacket::headerEquals" ref="a494e79a853503875310d23fd8f57265d" args="(const BasicVRTPacket &amp;p) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::BasicVRTPacket::headerEquals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for header equality with another <a class="el" href="classvrt_1_1BasicVRTPacket.html" title="A basic but full-featured implementation of BasicVRTPacket.">BasicVRTPacket</a>. </p>
<p>The headers of two VRT packets are considered equal if the content of the headers is bit-for-bit identical. The contents of the payload and trailer need not be equal for this method to return true. However, any two packets for which <a class="el" href="classvrt_1_1BasicVRTPacket.html#a9c8c4690d8cc6368963ccfc63fdb0ea5">equals</a> returns true, must have this method return true as well. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The other packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if they are identical, false otherwise. (This will always returns false if the packet is null.) </dd></dl>

</div>
</div>
<a class="anchor" id="a82261fee92bccb499235af9b827ba44b"></a><!-- doxytag: member="vrt::BasicVRTPacket::isCancelMode" ref="a82261fee92bccb499235af9b827ba44b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual boolNull vrt::BasicVRTPacket::isCancelMode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Command packets only: Gets the Cancel Mode (L). </p>
<p>This indicates if a command packet is a Control-Cancel packet: </p>
<pre>
    true  = Control-Cancel packet
    false = Not a Control-Cancel packet (which leaves Control or one of the Ack subtypes).
    null  = <em>Error: not a command packet</em>
  </pre> <dl class="return"><dt><b>Returns:</b></dt><dd>true or false as indicated above or null if this is not a command packet. </dd></dl>

</div>
</div>
<a class="anchor" id="afa9520fde9f8c9501116cb7fc0536da4"></a><!-- doxytag: member="vrt::BasicVRTPacket::isChangePacket" ref="afa9520fde9f8c9501116cb7fc0536da4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool vrt::BasicVRTPacket::isChangePacket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates if any fields have changes since the last packet in this stream. </p>
<p>Packet streams that do not support this concept, should always return true indicating that the recipient must read the packet to determine if there was a change. An IF Data stream will always return true. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if <b>anything</b> in the packet may have changed since the last context packet, false if <b>nothing</b> has changed since the last context packet. </dd></dl>

<p>Reimplemented in <a class="el" href="classvrt_1_1BasicContextPacket.html#ae0c4b163db38eb51636c73ef95ad9cb1">vrt::BasicContextPacket</a>, and <a class="el" href="classvrt_1_1BasicControlPacket.html#ad80178b5871a706e101452fcd39c21b0">vrt::BasicControlPacket</a>.</p>

</div>
</div>
<a class="anchor" id="a5a04d5fdcbe16ad478078a475fdbf79f"></a><!-- doxytag: member="vrt::BasicVRTPacket::isCommand" ref="a5a04d5fdcbe16ad478078a475fdbf79f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::BasicVRTPacket::isCommand </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the packet type a command packet? </p>

</div>
</div>
<a class="anchor" id="ac7c1c59ed02580aaa841d46833527f24"></a><!-- doxytag: member="vrt::BasicVRTPacket::isContext" ref="ac7c1c59ed02580aaa841d46833527f24" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::BasicVRTPacket::isContext </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the packet type a context packet? </p>

</div>
</div>
<a class="anchor" id="a283d2bbfc6b9d0c7726359105c900fb0"></a><!-- doxytag: member="vrt::BasicVRTPacket::isControlAckMode" ref="a283d2bbfc6b9d0c7726359105c900fb0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual boolNull vrt::BasicVRTPacket::isControlAckMode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Command packets only: Gets the Control/Ack Mode (ACK). </p>
<p>This indicates if a command packet is a Control or Ack subtype: </p>
<pre>
    true  = Ack subtype
    false = Control subtype
    null  = <em>Error: not a command packet</em>
  </pre> <dl class="return"><dt><b>Returns:</b></dt><dd>true or false as indicated above or null if this is not a command packet. </dd></dl>

</div>
</div>
<a class="anchor" id="a14275e1f04deb4d188c53a8ffb762e22"></a><!-- doxytag: member="vrt::BasicVRTPacket::isData" ref="a14275e1f04deb4d188c53a8ffb762e22" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::BasicVRTPacket::isData </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the packet type a data packet? </p>

</div>
</div>
<a class="anchor" id="a0676d7327afcd889e3873782c8f63235"></a><!-- doxytag: member="vrt::BasicVRTPacket::isNullValue" ref="a0676d7327afcd889e3873782c8f63235" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool vrt::BasicVRTPacket::isNullValue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is this object equal to null. </p>

<p>Reimplemented from <a class="el" href="classvrt_1_1VRTObject.html#ad5fc53758bf19350e251f4cd84670e2c">vrt::VRTObject</a>.</p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>.</p>

</div>
</div>
<a class="anchor" id="a90d6690a4cccdecc901625839af3e5d4"></a><!-- doxytag: member="vrt::BasicVRTPacket::isPacketValid" ref="a90d6690a4cccdecc901625839af3e5d4" args="(int32_t length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::BasicVRTPacket::isPacketValid </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks to see if the packet is valid. </p>
<p>This method adds an extra length check onto the basic checks performed by <a class="el" href="classvrt_1_1BasicVRTPacket.html#abada575c980c2e20543d3f0bfbaaad9f">isPacketValid()</a>. The most common use for this method is to verify that a packet read from a socket matches the length expected. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Verifies that the length of the packet matches this value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if it is valid, false otherwise. </dd></dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00488">getPacketValid()</a>.</p>

</div>
</div>
<a class="anchor" id="abada575c980c2e20543d3f0bfbaaad9f"></a><!-- doxytag: member="vrt::BasicVRTPacket::isPacketValid" ref="abada575c980c2e20543d3f0bfbaaad9f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::BasicVRTPacket::isPacketValid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks to see if the packet is valid. </p>
<p>This checks the overall structure of the packet (i.e. length is correct, reserved bits set to 0, etc.). It does not check the content of the packet or the validity of the data in the packet (the state and event indicators are provided for that purpose). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if it is valid, false otherwise. </dd></dl>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00488">getPacketValid()</a>.</p>

</div>
</div>
<a class="anchor" id="ac49c072692ebf58852246960501e84b6"></a><!-- doxytag: member="vrt::BasicVRTPacket::isSpectrumMode" ref="ac49c072692ebf58852246960501e84b6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual boolNull vrt::BasicVRTPacket::isSpectrumMode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Data packets only: Gets the Signal Spectrum Data Mode (S). </p>
<p>This indicates if a data packet is used to convey Signal Spectrum Data. </p>
<pre>
    true  = Signal Data Packet contains spectral or frequency domain data.
    false = Signal Data Packet contains time domain data.
    null  = <em>Error: not a data packet</em>
  </pre> <dl class="return"><dt><b>Returns:</b></dt><dd>true or false as indicated above or null if this is a data packet. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a1ca133afc41ae297b5dfca4e539617"></a><!-- doxytag: member="vrt::BasicVRTPacket::isTimeStampMode" ref="a7a1ca133afc41ae297b5dfca4e539617" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual boolNull vrt::BasicVRTPacket::isTimeStampMode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Context packets only: Gets the Time Stamp Mode (TSM). </p>
<p>This indicates if a context packet is being used to convey timing of context events related to the signal with fine or coarse resolution: </p>
<pre>
    true  = Time stamp fields indicate *precise* timing of context changes (to the
            resolution of the system)
    false = Time stamp fields indicate *general* timing of the context changes (i.e.
            the change occurred within the time interval covered by this packet)
    null  = <em>Error: not a context packet</em>
  </pre> <dl class="return"><dt><b>Returns:</b></dt><dd>true or false as indicated above or null if this is a data packet. </dd></dl>

</div>
</div>
<a class="anchor" id="a680d026fc3b81d0d6c1e9fb7bc27b949"></a><!-- doxytag: member="vrt::BasicVRTPacket::packPayloadAscii" ref="a680d026fc3b81d0d6c1e9fb7bc27b949" args="(int32_t off, string val, int32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::packPayloadAscii </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs an ASCII string into the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, <a class="el" href="namespacevrt_1_1VRTMath.html#a3c7d32193d1beb4a21fcbee46e7878b4">vrt::VRTMath::packAscii()</a>, and <a class="el" href="classvrt_1_1BasicVRTPacket.html#aa624a0ad7411af7dc8fdd173f0f80ffc">setPayloadLength()</a>.</p>

<p>Referenced by <a class="el" href="ReferencePointPacket_8h_source.html#l00121">vrt::ReferencePointPacket::setName()</a>, and <a class="el" href="EphemerisPacket_8h_source.html#l00438">vrt::EphemerisPacket::setProducedBy()</a>.</p>

</div>
</div>
<a class="anchor" id="a7ac23c01f1dce1287f3c9ee76cf87553"></a><!-- doxytag: member="vrt::BasicVRTPacket::packPayloadBoolean" ref="a7ac23c01f1dce1287f3c9ee76cf87553" args="(int32_t off, bool val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::packPayloadBoolean </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs a boolean value into the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="VRTMath_8h_source.html#l01470">vrt::VRTMath::packBoolean()</a>.</p>

</div>
</div>
<a class="anchor" id="a49ef62862d40493e4cd694269f525b08"></a><!-- doxytag: member="vrt::BasicVRTPacket::packPayloadBoolNull" ref="a49ef62862d40493e4cd694269f525b08" args="(int32_t off, boolNull val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::packPayloadBoolNull </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolNull&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs a <code>boolNull</code> value into the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="VRTMath_8h_source.html#l01442">vrt::VRTMath::packBoolNull()</a>.</p>

</div>
</div>
<a class="anchor" id="afbeb2663a36a0e7c5db41b70aebaef9e"></a><!-- doxytag: member="vrt::BasicVRTPacket::packPayloadByte" ref="afbeb2663a36a0e7c5db41b70aebaef9e" args="(int32_t off, char val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::packPayloadByte </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs an 8-bit integer into the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="VRTMath_8h_source.html#l01163">vrt::VRTMath::packByte()</a>.</p>

<p>Referenced by <a class="el" href="EphemerisPacket_8h_source.html#l00480">vrt::EphemerisPacket::setAccFixType()</a>, <a class="el" href="StreamStatePacket_8h_source.html#l00262">vrt::StreamStatePacket::setAggregateSystemStatus()</a>, <a class="el" href="EphemerisPacket_8h_source.html#l00494">vrt::EphemerisPacket::setAttFixType()</a>, <a class="el" href="StreamStatePacket_8h_source.html#l00276">vrt::StreamStatePacket::setInputStatus()</a>, <a class="el" href="StreamStatePacket_8h_source.html#l00290">vrt::StreamStatePacket::setInternalStatus()</a>, <a class="el" href="StreamStatePacket_8h_source.html#l00304">vrt::StreamStatePacket::setOutputStatus()</a>, <a class="el" href="EphemerisPacket_8h_source.html#l00452">vrt::EphemerisPacket::setPosFixType()</a>, <a class="el" href="StreamStatePacket_8h_source.html#l00248">vrt::StreamStatePacket::setSystemState()</a>, and <a class="el" href="EphemerisPacket_8h_source.html#l00466">vrt::EphemerisPacket::setVelFixType()</a>.</p>

</div>
</div>
<a class="anchor" id="a70c5432fa52fee585d6c178243616285"></a><!-- doxytag: member="vrt::BasicVRTPacket::packPayloadBytes" ref="a70c5432fa52fee585d6c178243616285" args="(int32_t off, const void *val, int32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::packPayloadBytes </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs a block of bytes into the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="VRTMath_8h_source.html#l01636">vrt::VRTMath::packBytes()</a>.</p>

</div>
</div>
<a class="anchor" id="afad208489c43f384919fee5b9de27c67"></a><!-- doxytag: member="vrt::BasicVRTPacket::packPayloadBytes" ref="afad208489c43f384919fee5b9de27c67" args="(int32_t off, const vector&lt; char &gt; &amp;val, int32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::packPayloadBytes </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs a block of bytes into the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="VRTMath_8h_source.html#l01636">vrt::VRTMath::packBytes()</a>.</p>

</div>
</div>
<a class="anchor" id="a97df14586888c9174608b61bce661cdc"></a><!-- doxytag: member="vrt::BasicVRTPacket::packPayloadDouble" ref="a97df14586888c9174608b61bce661cdc" args="(int32_t off, double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::packPayloadDouble </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs a 64-bit floating-point value into the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="VRTMath_8h_source.html#l01408">vrt::VRTMath::packDouble()</a>.</p>

</div>
</div>
<a class="anchor" id="aea27b9bcf68173cefa512366e67577e4"></a><!-- doxytag: member="vrt::BasicVRTPacket::packPayloadFloat" ref="aea27b9bcf68173cefa512366e67577e4" args="(int32_t off, float val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::packPayloadFloat </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs a 32-bit floating-point value into the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="VRTMath_8h_source.html#l01381">vrt::VRTMath::packFloat()</a>.</p>

</div>
</div>
<a class="anchor" id="afc9d38e9a6bb4a4c8de35ae811bccf2e"></a><!-- doxytag: member="vrt::BasicVRTPacket::packPayloadInetAddr" ref="afc9d38e9a6bb4a4c8de35ae811bccf2e" args="(int32_t off, InetAddress val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::packPayloadInetAddr </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrt_1_1InetAddress.html">InetAddress</a>&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs a <a class="el" href="classvrt_1_1InetAddress.html">InetAddress</a> into the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="InetAddress_8h_source.html#l00166">vrt::VRTMath::packInetAddr()</a>.</p>

</div>
</div>
<a class="anchor" id="a1a9f8ac2649d3299cc5e7c3d598a4390"></a><!-- doxytag: member="vrt::BasicVRTPacket::packPayloadInt" ref="a1a9f8ac2649d3299cc5e7c3d598a4390" args="(int32_t off, int32_t val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::packPayloadInt </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs a 32-bit integer into the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="VRTMath_8h_source.html#l01235">vrt::VRTMath::packInt()</a>.</p>

<p>Referenced by <a class="el" href="ReferencePointPacket_8h_source.html#l00101">vrt::ReferencePointPacket::setRefPointID()</a>.</p>

</div>
</div>
<a class="anchor" id="af687b8f4a50cb1cc0ce6d523d0885a01"></a><!-- doxytag: member="vrt::BasicVRTPacket::packPayloadLong" ref="af687b8f4a50cb1cc0ce6d523d0885a01" args="(int32_t off, int64_t val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::packPayloadLong </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs a 64-bit integer into the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="VRTMath_8h_source.html#l01256">vrt::VRTMath::packLong()</a>.</p>

<p>Referenced by <a class="el" href="EphemerisPacket_8h_source.html#l00528">vrt::EphemerisPacket::setFixDelta()</a>, and <a class="el" href="TimestampAccuracyPacket_8h_source.html#l00147">vrt::TimestampAccuracyPacket::setTimestampAccuracy()</a>.</p>

</div>
</div>
<a class="anchor" id="acb2907ab39b0db8acdb0b33feeac5de3"></a><!-- doxytag: member="vrt::BasicVRTPacket::packPayloadMetadata" ref="acb2907ab39b0db8acdb0b33feeac5de3" args="(int32_t off, MetadataBlock val, int32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::packPayloadMetadata </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrt_1_1MetadataBlock.html">MetadataBlock</a>&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs a metadata block into the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="namespacevrt_1_1VRTMath.html#a2caf91200db7580abace6c9c51c43374">vrt::VRTMath::packMetadata()</a>.</p>

</div>
</div>
<a class="anchor" id="ae42a70513e6ee01891995d8eab44a7c5"></a><!-- doxytag: member="vrt::BasicVRTPacket::packPayloadRecord" ref="ae42a70513e6ee01891995d8eab44a7c5" args="(int32_t off, Record val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::packPayloadRecord </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrt_1_1Record.html">Record</a>&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs a record value into the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="namespacevrt_1_1VRTMath.html#aaee853c53dbbfaab48ebfeff8d412b70">vrt::VRTMath::packRecord()</a>.</p>

</div>
</div>
<a class="anchor" id="a67288365a88ec115a587bd0bc6058bb0"></a><!-- doxytag: member="vrt::BasicVRTPacket::packPayloadShort" ref="a67288365a88ec115a587bd0bc6058bb0" args="(int32_t off, int16_t val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::packPayloadShort </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs a 16-bit integer into the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="VRTMath_8h_source.html#l01183">vrt::VRTMath::packShort()</a>.</p>

</div>
</div>
<a class="anchor" id="afe798f55a6a9292082e7d62c649beaff"></a><!-- doxytag: member="vrt::BasicVRTPacket::packPayloadTimeStamp" ref="afe798f55a6a9292082e7d62c649beaff" args="(int32_t off, TimeStamp val, IntegerMode epoch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::packPayloadTimeStamp </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a>&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerMode&nbsp;</td>
          <td class="paramname"> <em>epoch</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs a <a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> into the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="TimeStamp_8h_source.html#l01146">vrt::VRTMath::packTimeStamp()</a>.</p>

<p>Referenced by <a class="el" href="EphemerisPacket_8h_source.html#l00510">vrt::EphemerisPacket::setFixTime()</a>.</p>

</div>
</div>
<a class="anchor" id="a7bbe4a057be215992e01a69606c7bc16"></a><!-- doxytag: member="vrt::BasicVRTPacket::packPayloadUTF8" ref="a7bbe4a057be215992e01a69606c7bc16" args="(int32_t off, string val, int32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::packPayloadUTF8 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs a UTF-8 string into the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, <a class="el" href="namespacevrt_1_1VRTMath.html#a6d45e3bdc1dd1bc8153a07bc072f8c5a">vrt::VRTMath::packUTF8()</a>, and <a class="el" href="classvrt_1_1BasicVRTPacket.html#aa624a0ad7411af7dc8fdd173f0f80ffc">setPayloadLength()</a>.</p>

</div>
</div>
<a class="anchor" id="a9fbd27e881c5a4a3e4f2a536fce9c65d"></a><!-- doxytag: member="vrt::BasicVRTPacket::packPayloadUTF8" ref="a9fbd27e881c5a4a3e4f2a536fce9c65d" args="(int32_t off, wstring val, int32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::packPayloadUTF8 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wstring&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs a UTF-8 string into the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, <a class="el" href="namespacevrt_1_1VRTMath.html#a6d45e3bdc1dd1bc8153a07bc072f8c5a">vrt::VRTMath::packUTF8()</a>, and <a class="el" href="classvrt_1_1BasicVRTPacket.html#aa624a0ad7411af7dc8fdd173f0f80ffc">setPayloadLength()</a>.</p>

<p>Referenced by <a class="el" href="ReferencePointPacket_8h_source.html#l00137">vrt::ReferencePointPacket::setDescription()</a>, and <a class="el" href="StreamStatePacket_8h_source.html#l00320">vrt::StreamStatePacket::setMessage()</a>.</p>

</div>
</div>
<a class="anchor" id="af06ceeeb371f915351df4b31b115f4ec"></a><!-- doxytag: member="vrt::BasicVRTPacket::packPayloadUUID" ref="af06ceeeb371f915351df4b31b115f4ec" args="(int32_t off, UUID val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::packPayloadUUID </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrt_1_1UUID.html">UUID</a>&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packs a <a class="el" href="classvrt_1_1UUID.html">UUID</a> into the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="UUID_8h_source.html#l00138">vrt::VRTMath::packUUID()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e4e169b34625be2d378b9de73a6bfd4"></a><!-- doxytag: member="vrt::BasicVRTPacket::payloadEquals" ref="a5e4e169b34625be2d378b9de73a6bfd4" args="(const BasicVRTPacket &amp;p) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::BasicVRTPacket::payloadEquals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for payload equality with another <a class="el" href="classvrt_1_1BasicVRTPacket.html" title="A basic but full-featured implementation of BasicVRTPacket.">BasicVRTPacket</a>. </p>
<p>The payloads of two VRT packets are considered equal if the content of the payloads is bit-for-bit identical. The contents of the prologue and trailer need not be equal for this method to return true. However, any two packets for which <a class="el" href="classvrt_1_1BasicVRTPacket.html#a9c8c4690d8cc6368963ccfc63fdb0ea5">equals</a> returns true, must have this method return true as well. This will always return false if the tqo packets have different payload lengths. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The other packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if they are identical, false otherwise. (This will always returns false if the packet is null.) </dd></dl>

</div>
</div>
<a class="anchor" id="a17f4e865550c8484e46624a1ed84277e"></a><!-- doxytag: member="vrt::BasicVRTPacket::pktSpecificPrologueEquals" ref="a17f4e865550c8484e46624a1ed84277e" args="(const BasicVRTPacket &amp;p) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::BasicVRTPacket::pktSpecificPrologueEquals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for packet specific prologue (PSP) equality with another <a class="el" href="classvrt_1_1BasicVRTPacket.html" title="A basic but full-featured implementation of BasicVRTPacket.">BasicVRTPacket</a>. </p>
<p>The PSPs of two VRT packets are considered equal if the content of the PSPs is bit-for-bit identical. The contents of the payload and trailer need not be equal for this method to return true. However, any two packets for which <a class="el" href="classvrt_1_1BasicVRTPacket.html#a9c8c4690d8cc6368963ccfc63fdb0ea5">equals</a> returns true, must have this method return true as well. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The other packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if they are identical, false otherwise. (This will always returns false if the packet is null.) </dd></dl>

</div>
</div>
<a class="anchor" id="a208052c0b7c835c330ee11c38e5ac832"></a><!-- doxytag: member="vrt::BasicVRTPacket::prologueEquals" ref="a208052c0b7c835c330ee11c38e5ac832" args="(const BasicVRTPacket &amp;p) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::BasicVRTPacket::prologueEquals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for prologue equality with another <a class="el" href="classvrt_1_1BasicVRTPacket.html" title="A basic but full-featured implementation of BasicVRTPacket.">BasicVRTPacket</a>. </p>
<p>The prologues of two VRT packets are considered equal if the content of the prologues is bit-for-bit identical. The contents of the payload and trailer need not be equal for this method to return true. However, any two packets for which <a class="el" href="classvrt_1_1BasicVRTPacket.html#a9c8c4690d8cc6368963ccfc63fdb0ea5">equals</a> returns true, must have this method return true as well. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The other packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if they are identical, false otherwise. (This will always returns false if the packet is null.) </dd></dl>

</div>
</div>
<a class="anchor" id="a5eb34f257552e3908bd046dc85aeffdd"></a><!-- doxytag: member="vrt::BasicVRTPacket::readPacket" ref="a5eb34f257552e3908bd046dc85aeffdd" args="(void *buffer, int32_t poff, int32_t len) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicVRTPacket::readPacket </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>poff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the packet payload into the provided buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>The buffer to read into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poff</em>&nbsp;</td><td>The payload offset to start reading from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The maximum length to read in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes read or -1 if the end of the payload has been reached. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b6cd3b3102e227a8819650503e62ee4"></a><!-- doxytag: member="vrt::BasicVRTPacket::readPayload" ref="a7b6cd3b3102e227a8819650503e62ee4" args="(void *buffer, int32_t poff, int32_t len) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicVRTPacket::readPayload </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>poff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the packet payload into the provided buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>The buffer to read into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poff</em>&nbsp;</td><td>The payload offset to start reading from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The maximum length to read in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes read or -1 if the end of the payload has been reached. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2302481a1c9dea1ca3f86571b27ec79"></a><!-- doxytag: member="vrt::BasicVRTPacket::resetForResend" ref="ab2302481a1c9dea1ca3f86571b27ec79" args="(const TimeStamp &amp;t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool vrt::BasicVRTPacket::resetForResend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepares a packet for resend resetting any non-persistent values and clearing the context change flags. </p>
<p>At a minimum this will update the time stamp. This is implemented as follows: </p>
<pre>
    bool <a class="el" href="classvrt_1_1BasicVRTPacket.html#ab2302481a1c9dea1ca3f86571b27ec79" title="Prepares a packet for resend resetting any non-persistent values and clearing the...">BasicVRTPacket::resetForResend</a> (const <a class="el" href="classvrt_1_1TimeStamp.html" title="An immutable time stamp.">TimeStamp</a> &amp;t) {
      setTimeStamp(t);
      return false;
    }
  </pre> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The new time stamp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if non-persistent values and the change flags have been reset, false if only the time stamp has been updated. </dd></dl>

<p>Reimplemented in <a class="el" href="classvrt_1_1BasicContextPacket.html#a0d43a23f306bf7a37594edda1c37b1bb">vrt::BasicContextPacket</a>.</p>

</div>
</div>
<a class="anchor" id="a75d0c290d5f89061027884192643816c"></a><!-- doxytag: member="vrt::BasicVRTPacket::setCancelMode" ref="a75d0c290d5f89061027884192643816c" args="(bool v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::BasicVRTPacket::setCancelMode </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Command packets only: Gets the Cancel Mode (L). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The new value, see <a class="el" href="classvrt_1_1BasicVRTPacket.html#a82261fee92bccb499235af9b827ba44b">isCancelMode()</a> for details. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported or if the packet type doesn't support this setting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a173201b351780482420cfddc1218c45b"></a><!-- doxytag: member="vrt::BasicVRTPacket::setClassID" ref="a173201b351780482420cfddc1218c45b" args="(string v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::BasicVRTPacket::setClassID </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets the packet class identifier. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The packet class identifier or null if not specified. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the value passed in is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6bbd162709c8442d2e169adb07cddf05"></a><!-- doxytag: member="vrt::BasicVRTPacket::setClassIdentifier" ref="a6bbd162709c8442d2e169adb07cddf05" args="(int32_t oui, int16_t icc, int16_t pcc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::BasicVRTPacket::setClassIdentifier </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>oui</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&nbsp;</td>
          <td class="paramname"> <em>icc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&nbsp;</td>
          <td class="paramname"> <em>pcc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets the packet class identifier. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>oui</em>&nbsp;</td><td>The new OUI value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>icc</em>&nbsp;</td><td>The new ICC value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pcc</em>&nbsp;</td><td>The new PCC value. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the value passed in is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a59a0d4a44c700f346c04ae930c0846ff"></a><!-- doxytag: member="vrt::BasicVRTPacket::setClassIdentifier" ref="a59a0d4a44c700f346c04ae930c0846ff" args="(int64_t v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::BasicVRTPacket::setClassIdentifier </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets the packet class identifier. </p>
<p>See <a class="el" href="classvrt_1_1BasicVRTPacket.html#aaf45b61252939459bc2096ec3df68be2">getClassIdentifier()</a> for details. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The packet class identifier or INT64_NULL if not specified. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the value passed in is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6be05da88012d420c0c321b227866666"></a><!-- doxytag: member="vrt::BasicVRTPacket::setControlAckMode" ref="a6be05da88012d420c0c321b227866666" args="(bool v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::BasicVRTPacket::setControlAckMode </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Command packets only: Sets the Control/Ack Mode (ACK). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The new value, see <a class="el" href="classvrt_1_1BasicVRTPacket.html#a283d2bbfc6b9d0c7726359105c900fb0">isControlAckMode()</a> for details. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported or if the packet type doesn't support this setting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a832f112f8f1b4f4b6bbb117af7a7239e"></a><!-- doxytag: member="vrt::BasicVRTPacket::setField" ref="a832f112f8f1b4f4b6bbb117af7a7239e" args="(int32_t id, const Value *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::BasicVRTPacket::setField </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1Value.html">Value</a> *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the value of a field, based on the field's id. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>The field ID (on range <code>[0,<a class="el" href="classvrt_1_1BasicVRTPacket.html#aeec8ba3ed0fdc05f4ea766a80608ff24" title="Gets the number of fields.">getFieldCount()</a>)</code>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Pointer to the given value (must be of the applicable type). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classvrt_1_1HasFields.html#a0e2302c120d7fb56da99c6046df1e728">vrt::HasFields</a>.</p>

<p>Reimplemented in <a class="el" href="classvrt_1_1BasicContextPacket.html#a6d49b6ab1c9f1cbbd2ad06a8b1714718">vrt::BasicContextPacket</a>, <a class="el" href="classvrt_1_1BasicDataPacket.html#a26d23feba544bbcf35f14a38a5765d86">vrt::BasicDataPacket</a>, <a class="el" href="classvrt_1_1EphemerisPacket.html#a60553f80ce5a4cceb4b60dd5f66c71f7">vrt::EphemerisPacket</a>, <a class="el" href="classvrt_1_1NoDataPacket.html#a5d3ae8b1dbd5eb2708a62190e5fdd032">vrt::NoDataPacket</a>, <a class="el" href="classvrt_1_1ReferencePointPacket.html#a61d295f4c362a98a7119ebda58c44c42">vrt::ReferencePointPacket</a>, <a class="el" href="classvrt_1_1StandardContextPacket.html#a972a3f584b30660d7247b2c5c75fbe0a">vrt::StandardContextPacket</a>, <a class="el" href="classvrt_1_1StreamStatePacket.html#aa622b01eb6eefc9a5f4e854d17bf5107">vrt::StreamStatePacket</a>, and <a class="el" href="classvrt_1_1TimestampAccuracyPacket.html#a948a0231d0e906ea401ac9ef1aafb95b">vrt::TimestampAccuracyPacket</a>.</p>

</div>
</div>
<a class="anchor" id="a04ba853230821ea2e90f379785fc69d6"></a><!-- doxytag: member="vrt::BasicVRTPacket::setPacketCount" ref="a04ba853230821ea2e90f379785fc69d6" args="(void *ptr, int32_t v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void vrt::BasicVRTPacket::setPacketCount </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Sets the packet count. </p>
<p>This is the modulo-16 count of all packets on this stream. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to the packet content. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The packet count (0..15). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the value passed in is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a433e63307c5a881eb4ecf8f43922475d"></a><!-- doxytag: member="vrt::BasicVRTPacket::setPacketCount" ref="a433e63307c5a881eb4ecf8f43922475d" args="(int32_t v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::BasicVRTPacket::setPacketCount </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets the packet count. </p>
<p>This is the modulo-16 count of all packets on this stream. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The packet count (0..15). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the value passed in is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40a7e24752e1aca33b56c309870e0d0d"></a><!-- doxytag: member="vrt::BasicVRTPacket::setPacketLength" ref="a40a7e24752e1aca33b56c309870e0d0d" args="(int32_t v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::setPacketLength </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal use only:</b> Sets the packet length. </p>

</div>
</div>
<a class="anchor" id="ae215e242805855769eb7b1f840cc0da9"></a><!-- doxytag: member="vrt::BasicVRTPacket::setPacketType" ref="ae215e242805855769eb7b1f840cc0da9" args="(PacketType t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::BasicVRTPacket::setPacketType </td>
          <td>(</td>
          <td class="paramtype">PacketType&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets the packet type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The packet type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classvrt_1_1BasicAcknowledgePacket.html#abdffe0272305a1f5ffc21aba19381fb4">vrt::BasicAcknowledgePacket</a>, <a class="el" href="classvrt_1_1BasicCommandPacket.html#a589c0f8d89fc3a34c898ee782feb638c">vrt::BasicCommandPacket</a>, <a class="el" href="classvrt_1_1BasicContextPacket.html#a965a2202c99585e415fca51d090cf4c5">vrt::BasicContextPacket</a>, <a class="el" href="classvrt_1_1BasicControlPacket.html#a68e68bccd21aa00f1a600fe882a371e4">vrt::BasicControlPacket</a>, <a class="el" href="classvrt_1_1BasicDataPacket.html#af947fca253c101a6a97709c970e10a37">vrt::BasicDataPacket</a>, and <a class="el" href="classvrt_1_1BasicQueryAcknowledgePacket.html#a0636d12e2adc21b28490366f8439f7a1">vrt::BasicQueryAcknowledgePacket</a>.</p>

</div>
</div>
<a class="anchor" id="a974c8c2393fc1b4c7f75111010e250b0"></a><!-- doxytag: member="vrt::BasicVRTPacket::setPadBitCount" ref="a974c8c2393fc1b4c7f75111010e250b0" args="(int32_t bits, int32_t bitsPerSample)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::BasicVRTPacket::setPadBitCount </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bitsPerSample</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets the number of pad bits inserted following the data in the payload such that the payload section is always a multiple of 4-bytes in length (see <a class="el" href="classvrt_1_1BasicVRTPacket.html#aaea92ae8c2ad2f925b3502536351dd45">getPadBitCount()</a> for a detailed discussion about the reporting of pad bits). </p>
<p><br/>
 <br/>
 This function will *not* alter the packet if the number of pad bits is implicit (or zero) when in strict VITA-49.0 (rather than VITA-49.0b) mode. <br/>
 <br/>
 Note: <b>It is not possible to report the number of pad bits if the ClassID is not set.</b> If this function is called with a non-zero value, the number of pad bits is not implicit and the ClassID is not set, an exception will be thrown. <br/>
 <br/>
 Assuming this method is supported, it is safe to call this method on a non-data packet with a value of zero. <br/>
 <br/>
 <b>In most cases, this method should not be called directly (except to clear it by setting a value of zero); rather this should be called by <a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84">BasicDataPacket#setDataLength(int32_t)</a>.</b> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>The number of pad bits to report. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bitsPerSample</em>&nbsp;</td><td>Number of bits per sample. This is used to determine if the number of pad bits is implicit. Note the value of <code>bitsPerSample</code> is irrelevant when <code>bits</code> is zero, therefore users can just call <code>setPadBitCount(0,0)</code> to set the field to zero (where applicable). </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classvrt_1_1BasicVRTPacket.html#aa624a0ad7411af7dc8fdd173f0f80ffc" title="Optional functionality: Sets the payload length in bytes.">setPayloadLength(int32_t)</a> </dd>
<dd>
<a class="el" href="classvrt_1_1BasicDataPacket.html#ae80174a71d1d015e44a57e194e72fa84" title="Sets the length of the data in number of elements.">BasicDataPacket::setDataLength(int32_t)</a> </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is called with a non-zero value for a non-data packet or if the number of bits is not implicit and the ClassID is not set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86569211e1a389937bcaf3e852879eb1"></a><!-- doxytag: member="vrt::BasicVRTPacket::setPayload" ref="a86569211e1a389937bcaf3e852879eb1" args="(void *buffer, int32_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::setPayload </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets the content of the packet payload and updates the length of the payload. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>The new payload. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of bytes to copy from the buffer into the payload. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classvrt_1_1BasicVRTPacket.html#aa624a0ad7411af7dc8fdd173f0f80ffc">setPayloadLength()</a>, and <a class="el" href="classvrt_1_1BasicVRTPacket.html#a74d62dc0c3372e6fdff366e9dc518589">writePayload()</a>.</p>

</div>
</div>
<a class="anchor" id="a8e87bf5dcbc5b4bfe0d2cdea4bca20a4"></a><!-- doxytag: member="vrt::BasicVRTPacket::setPayload" ref="a8e87bf5dcbc5b4bfe0d2cdea4bca20a4" args="(vector&lt; char &gt; buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::setPayload </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt;&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets the content of the packet payload and updates the length of the payload. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>The new payload. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa624a0ad7411af7dc8fdd173f0f80ffc"></a><!-- doxytag: member="vrt::BasicVRTPacket::setPayloadLength" ref="aa624a0ad7411af7dc8fdd173f0f80ffc" args="(int32_t v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::BasicVRTPacket::setPayloadLength </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets the payload length in bytes. </p>
<p>The packet length is recomputed and trailer is shifted as required. The payload length must be a multiple of 4-bytes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The length of the payload in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the value passed in is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l00982">packPayloadAscii()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00995">packPayloadUTF8()</a>, <a class="el" href="ReferencePointPacket_8h_source.html#l00137">vrt::ReferencePointPacket::setDescription()</a>, <a class="el" href="StreamStatePacket_8h_source.html#l00320">vrt::StreamStatePacket::setMessage()</a>, and <a class="el" href="BasicVRTPacket_8h_source.html#l00918">setPayload()</a>.</p>

</div>
</div>
<a class="anchor" id="ac5f1e603d5f0d1366c54228fc9595705"></a><!-- doxytag: member="vrt::BasicVRTPacket::setSpectrumMode" ref="ac5f1e603d5f0d1366c54228fc9595705" args="(bool v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::BasicVRTPacket::setSpectrumMode </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Data packets only: Sets the Signal Spectrum Data Mode (S). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The new value, see <a class="el" href="classvrt_1_1BasicVRTPacket.html#ac49c072692ebf58852246960501e84b6">isSpectrumMode()</a> for details. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported or if the packet type doesn't support this setting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5fd725908b81bcab95d7954d406dc437"></a><!-- doxytag: member="vrt::BasicVRTPacket::setStateEventBit" ref="a5fd725908b81bcab95d7954d406dc437" args="(vector&lt; char &gt; &amp;buf, int32_t off, int32_t enable, int32_t indicator, boolNull value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void vrt::BasicVRTPacket::setStateEventBit </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>indicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolNull&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets the specified bit from the trailer. </p>
<p>By default all of the "set" methods that access the trailer call this method with the appropriate bit values (see <a class="el" href="classvrt_1_1BasicVRTPacket.html#aece0316a5d3a949e27f87e7d0e390045">getStateEventBit</a> for a list). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The data buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>The offset into the data buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>Bit position of the enable flag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indicator</em>&nbsp;</td><td>Bit position of the indicator flag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of the bits: null if the enable bit should not be set, true if the enable bit and the indicator bit should be set, false if the enable bit should be set but the indicator bit should not be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1572bd49ff24ace9e986bc3e0937f377"></a><!-- doxytag: member="vrt::BasicVRTPacket::setStreamID" ref="a1572bd49ff24ace9e986bc3e0937f377" args="(string v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::BasicVRTPacket::setStreamID </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets the 32-bit packet stream identifier. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The stream identifier or null if not specified. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa02ec067a110ac93582143c44a9cd956"></a><!-- doxytag: member="vrt::BasicVRTPacket::setStreamIdentifier" ref="aa02ec067a110ac93582143c44a9cd956" args="(int32_t v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::BasicVRTPacket::setStreamIdentifier </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets the 32-bit packet stream identifier. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The stream identifier or INT4_NULL if not specified. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea367e62bfcf7eca8047e9c05373c04e"></a><!-- doxytag: member="vrt::BasicVRTPacket::setTimeStamp" ref="aea367e62bfcf7eca8047e9c05373c04e" args="(const TimeStamp &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::BasicVRTPacket::setTimeStamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Sets the time stamp for the packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The new time stamp. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa40fc36ff16b000a74bfc637a093078"></a><!-- doxytag: member="vrt::BasicVRTPacket::setTimeStampMode" ref="aaa40fc36ff16b000a74bfc637a093078" args="(bool v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::BasicVRTPacket::setTimeStampMode </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Context packets only: Sets the Time Stamp Mode (TSM). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The new value, see <a class="el" href="classvrt_1_1BasicVRTPacket.html#a7a1ca133afc41ae297b5dfca4e539617">isTimeStampMode()</a> for details. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported or if the packet type doesn't support this setting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade1909da7e741c4cce1d9cc80038c439"></a><!-- doxytag: member="vrt::BasicVRTPacket::shiftHeader" ref="ade1909da7e741c4cce1d9cc80038c439" args="(int32_t field, int32_t bytes, bool present)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::shiftHeader </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>present</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal use only:</b> Shifts the header. </p>
<p>Creates or removes space for values in header. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>field</em>&nbsp;</td><td>bit field used to identify if field is currently included and the offset based on other fields that may be present. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes</em>&nbsp;</td><td>size of value to be included or removed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>present</em>&nbsp;</td><td>true if need space to store value associated with field, false if the value is not present in header. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28fd26d966e7c84abdc07df670bf2f81"></a><!-- doxytag: member="vrt::BasicVRTPacket::shiftPacketSpecificPrologue" ref="a28fd26d966e7c84abdc07df670bf2f81" args="(int32_t off, int32_t bytes, bool add)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicVRTPacket::shiftPacketSpecificPrologue </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>add</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal use only:</b> Shifts the packet specific prologue (PSP). </p>
<p>Insert or remove bytes at given offset. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset w/in PSP to insert/remove bytes. off&gt;=0 indicates value exists already, while off&lt;0 indicates it is not present. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes</em>&nbsp;</td><td>Non-negative number of bytes to insert or remove. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>add</em>&nbsp;</td><td>Indicates whether to add or remove bytes. Nothing is done if True and value exists, or if False and value is not present. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Non-negative value of off param, regardless of action taken (or not taken). </dd></dl>

</div>
</div>
<a class="anchor" id="a93d23c45790e2d5078d93849e905abab"></a><!-- doxytag: member="vrt::BasicVRTPacket::shiftPayload" ref="a93d23c45790e2d5078d93849e905abab" args="(int32_t off, int32_t bytes, bool add)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicVRTPacket::shiftPayload </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>add</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal use only:</b> Shifts the payload. </p>
<p>Insert or remove bytes at given offset. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset w/in payload to insert/remove bytes. off&gt;=0 indicates value exists already, while off&lt;0 indicates it is not present. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes</em>&nbsp;</td><td>Non-negative number of bytes to insert or remove. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>add</em>&nbsp;</td><td>Indicates whether to add or remove bytes. Nothing is done if True and value exists, or if False and value is not present. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Non-negative value of off param, regardless of action taken (or not taken). </dd></dl>

</div>
</div>
<a class="anchor" id="a7a14aa0880827fc29132b5f3c0b15fed"></a><!-- doxytag: member="vrt::BasicVRTPacket::shiftTrailer" ref="a7a14aa0880827fc29132b5f3c0b15fed" args="(bool add)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::shiftTrailer </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>add</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal use only:</b> Shifts the trailer. </p>
<p>Add or removes trailer of size MAX_TRAILER_LENGTH. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>add</em>&nbsp;</td><td>Indicates whether to add or remove trailer. If add is false, removes trailer from the packet and unsets the Trailer bit in the header. If add is true, increases packet by MAX_TRAILER_LENGTH and sets Trailer bit in header. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa676a350d0107aeb8edab093fe3767e3"></a><!-- doxytag: member="vrt::BasicVRTPacket::swap" ref="aa676a350d0107aeb8edab093fe3767e3" args="(BasicVRTPacket *pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Does a buffer swap. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, and <a class="el" href="BasicVRTPacket_8h_source.html#l00158">readOnly</a>.</p>

</div>
</div>
<a class="anchor" id="a4cc0f78031a5a367834227be7a4337d6"></a><!-- doxytag: member="vrt::BasicVRTPacket::swap" ref="a4cc0f78031a5a367834227be7a4337d6" args="(vector&lt; char &gt; *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::swap </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Does a buffer swap. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, and <a class="el" href="BasicVRTPacket_8h_source.html#l00158">readOnly</a>.</p>

</div>
</div>
<a class="anchor" id="a13b21e225e6ead2ef13f3553a8ef96f8"></a><!-- doxytag: member="vrt::BasicVRTPacket::toString" ref="a13b21e225e6ead2ef13f3553a8ef96f8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual string vrt::BasicVRTPacket::toString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts this class its string form. </p>

<p>Reimplemented from <a class="el" href="classvrt_1_1VRTObject.html#a8a8ca4be5d2b9075b6478685c2e121a1">vrt::VRTObject</a>.</p>

</div>
</div>
<a class="anchor" id="a1cdf8b4c9288d38516b8325a8a95b268"></a><!-- doxytag: member="vrt::BasicVRTPacket::toStringStream" ref="a1cdf8b4c9288d38516b8325a8a95b268" args="(ostringstream &amp;str) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vrt::BasicVRTPacket::toStringStream </td>
          <td>(</td>
          <td class="paramtype">ostringstream &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes the packet content to a string stream in a user-friendly format. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string stream to write to. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classvrt_1_1BasicAcknowledgePacket.html#a542a1649d6dfaa4aa0c7ae0989406951">vrt::BasicAcknowledgePacket</a>, <a class="el" href="classvrt_1_1BasicCommandPacket.html#a98918a7554cebf8bf219139fc8620041">vrt::BasicCommandPacket</a>, <a class="el" href="classvrt_1_1BasicContextPacket.html#a2f29d49dea26b0e12d466f94b6c538eb">vrt::BasicContextPacket</a>, <a class="el" href="classvrt_1_1BasicControlPacket.html#a23253cd65cb1669cea07643ceee91182">vrt::BasicControlPacket</a>, <a class="el" href="classvrt_1_1BasicDataPacket.html#aec33b2c7031772f446ec0a9703f2b457">vrt::BasicDataPacket</a>, <a class="el" href="classvrt_1_1BasicQueryAcknowledgePacket.html#a0a9a6c4afb2c703e8ad054063a87269c">vrt::BasicQueryAcknowledgePacket</a>, <a class="el" href="classvrt_1_1StandardDataPacket.html#aaae5248c395f8bcbd84c2b360a243041">vrt::StandardDataPacket</a>, <a class="el" href="classvrt_1_1EphemerisPacket.html#a3fb4e49c48ac3a1bed5931343bffc294">vrt::EphemerisPacket</a>, <a class="el" href="classvrt_1_1NoDataPacket.html#a95396645ea4a27b12a2b9dc5d5abe428">vrt::NoDataPacket</a>, <a class="el" href="classvrt_1_1ReferencePointPacket.html#a0914d276be5ed5f79bd90636eeb6b90d">vrt::ReferencePointPacket</a>, <a class="el" href="classvrt_1_1StandardContextPacket.html#a35822999e7d75de51d9f39e3ccad62ba">vrt::StandardContextPacket</a>, <a class="el" href="classvrt_1_1StreamStatePacket.html#a88cea52b1b5945d114a3e2a6c2681a08">vrt::StreamStatePacket</a>, and <a class="el" href="classvrt_1_1TimestampAccuracyPacket.html#a8d58c76db6b9e3205f030533fa1c015b">vrt::TimestampAccuracyPacket</a>.</p>

</div>
</div>
<a class="anchor" id="ad36365da9033cfaba2823bf297a95dd7"></a><!-- doxytag: member="vrt::BasicVRTPacket::trailerEquals" ref="ad36365da9033cfaba2823bf297a95dd7" args="(const BasicVRTPacket &amp;p, bool exact) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::BasicVRTPacket::trailerEquals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>exact</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for trailer equality with another <a class="el" href="classvrt_1_1BasicVRTPacket.html" title="A basic but full-featured implementation of BasicVRTPacket.">BasicVRTPacket</a>. </p>
<p>This method allows two different interpretations of trailer equality: </p>
<ul>
<li>
<b>Exact:</b> With "exact" equality, the trailers of two VRT packets are considered equal if the content of the trailers is either bit-for-bit identical, or if <b>both</b> packets omit the trailers.  </li>
<li>
<b>Equal:</b> With "equal" equality, the trailers of two VRT packets are considered equal if the content of the trailers conveys the same meaning. Conveying the same meaning means that the enable bits in the trailer are checked first. Any values not enabled, are ignored when comparing. In this form, a packet with no trailer is considered equal to a packet with a trailer that has nothing enabled.  </li>
</ul>
<p>Regardless of the comparison used, any two packets for which <a class="el" href="classvrt_1_1BasicVRTPacket.html#a9c8c4690d8cc6368963ccfc63fdb0ea5">equals</a> returns true, must have this method return true as well. This method will always return true if comparing two context packets since they do not contain trailers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The other packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exact</em>&nbsp;</td><td>true to use the <b>Exact</b> comparison, false to use the <b>Equal</b> comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if they are identical, false otherwise. (This will always returns false if the packet is null.) </dd></dl>

</div>
</div>
<a class="anchor" id="a26c1f6d9e5f9a022d937a1a0455df6c6"></a><!-- doxytag: member="vrt::BasicVRTPacket::trailerEquals" ref="a26c1f6d9e5f9a022d937a1a0455df6c6" args="(const BasicVRTPacket &amp;p) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::BasicVRTPacket::trailerEquals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for trailer equality with another <a class="el" href="classvrt_1_1BasicVRTPacket.html" title="A basic but full-featured implementation of BasicVRTPacket.">BasicVRTPacket</a>. </p>
<p>This method is identical to <code>trailerEquals(p,true)</code>. <b>In most cases, use of <code>trailerEquals(p,false)</code> is more appropriate for comparing trailers.</b> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The other packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if they are identical, false otherwise. (This will always returns false if the packet is null.) </dd></dl>

</div>
</div>
<a class="anchor" id="a6b844a70aaeaa39092f5ed6df11d9782"></a><!-- doxytag: member="vrt::BasicVRTPacket::unpackPayloadAscii" ref="a6b844a70aaeaa39092f5ed6df11d9782" args="(int32_t off, int32_t len) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vrt::BasicVRTPacket::unpackPayloadAscii </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks an ASCII string from the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="namespacevrt_1_1VRTMath.html#a8a61c533c98f77c4943a309bb1de9256">vrt::VRTMath::unpackAscii()</a>.</p>

<p>Referenced by <a class="el" href="ReferencePointPacket_8h_source.html#l00109">vrt::ReferencePointPacket::getName()</a>, and <a class="el" href="EphemerisPacket_8h_source.html#l00426">vrt::EphemerisPacket::getProducedBy()</a>.</p>

</div>
</div>
<a class="anchor" id="a99c2c7450c162dab673985f57b3e6a66"></a><!-- doxytag: member="vrt::BasicVRTPacket::unpackPayloadBoolean" ref="a99c2c7450c162dab673985f57b3e6a66" args="(int32_t off) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::BasicVRTPacket::unpackPayloadBoolean </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks a boolean value from the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="namespacevrt_1_1VRTMath.html#a5af1b4911b0d0103fa04ee5cca5d8c92">vrt::VRTMath::unpackBoolean()</a>.</p>

</div>
</div>
<a class="anchor" id="abfdcffe82511e71c9dea29e12ef5e62f"></a><!-- doxytag: member="vrt::BasicVRTPacket::unpackPayloadBoolNull" ref="abfdcffe82511e71c9dea29e12ef5e62f" args="(int32_t off) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolNull vrt::BasicVRTPacket::unpackPayloadBoolNull </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks a <code>boolNull</code> value from the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="namespacevrt_1_1VRTMath.html#ad724d3ff607ef08f13338e3f70cbdd88">vrt::VRTMath::unpackBoolNull()</a>.</p>

</div>
</div>
<a class="anchor" id="a8bd046cedab9244740ffee5b28c670cd"></a><!-- doxytag: member="vrt::BasicVRTPacket::unpackPayloadByte" ref="a8bd046cedab9244740ffee5b28c670cd" args="(int32_t off) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char vrt::BasicVRTPacket::unpackPayloadByte </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks an 8-bit integer from the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="VRTMath_8h_source.html#l00747">vrt::VRTMath::unpackByte()</a>.</p>

<p>Referenced by <a class="el" href="EphemerisPacket_8h_source.html#l00473">vrt::EphemerisPacket::getAccFixType()</a>, <a class="el" href="StreamStatePacket_8h_source.html#l00255">vrt::StreamStatePacket::getAggregateSystemStatus()</a>, <a class="el" href="EphemerisPacket_8h_source.html#l00487">vrt::EphemerisPacket::getAttFixType()</a>, <a class="el" href="StreamStatePacket_8h_source.html#l00269">vrt::StreamStatePacket::getInputStatus()</a>, <a class="el" href="StreamStatePacket_8h_source.html#l00283">vrt::StreamStatePacket::getInternalStatus()</a>, <a class="el" href="StreamStatePacket_8h_source.html#l00297">vrt::StreamStatePacket::getOutputStatus()</a>, <a class="el" href="EphemerisPacket_8h_source.html#l00445">vrt::EphemerisPacket::getPosFixType()</a>, <a class="el" href="StreamStatePacket_8h_source.html#l00241">vrt::StreamStatePacket::getSystemState()</a>, and <a class="el" href="EphemerisPacket_8h_source.html#l00459">vrt::EphemerisPacket::getVelFixType()</a>.</p>

</div>
</div>
<a class="anchor" id="ade26a3d5157f3a7efbbb5a3470778ceb"></a><!-- doxytag: member="vrt::BasicVRTPacket::unpackPayloadBytes" ref="ade26a3d5157f3a7efbbb5a3470778ceb" args="(int32_t off, void *val, int32_t len) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* vrt::BasicVRTPacket::unpackPayloadBytes </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks a block of bytes from the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="VRTMath_8h_source.html#l01133">vrt::VRTMath::unpackBytes()</a>.</p>

</div>
</div>
<a class="anchor" id="a09e534ac7e70c34091f83da9882b9b0b"></a><!-- doxytag: member="vrt::BasicVRTPacket::unpackPayloadBytes" ref="a09e534ac7e70c34091f83da9882b9b0b" args="(int32_t off, int32_t len) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;char&gt; vrt::BasicVRTPacket::unpackPayloadBytes </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks a block of bytes from the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="VRTMath_8h_source.html#l01133">vrt::VRTMath::unpackBytes()</a>.</p>

</div>
</div>
<a class="anchor" id="a69f3c039115623ab4298b60585daa33c"></a><!-- doxytag: member="vrt::BasicVRTPacket::unpackPayloadDouble" ref="a69f3c039115623ab4298b60585daa33c" args="(int32_t off) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vrt::BasicVRTPacket::unpackPayloadDouble </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks a 64-bit floating-point value from the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="VRTMath_8h_source.html#l00990">vrt::VRTMath::unpackDouble()</a>.</p>

</div>
</div>
<a class="anchor" id="af432ee5a3e8a97349e96ed78523bbebc"></a><!-- doxytag: member="vrt::BasicVRTPacket::unpackPayloadFloat" ref="af432ee5a3e8a97349e96ed78523bbebc" args="(int32_t off) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float vrt::BasicVRTPacket::unpackPayloadFloat </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks a 32-bit floating-point value from the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="VRTMath_8h_source.html#l00962">vrt::VRTMath::unpackFloat()</a>.</p>

</div>
</div>
<a class="anchor" id="a45f3a58b6a06ec785080e9d0c986fedf"></a><!-- doxytag: member="vrt::BasicVRTPacket::unpackPayloadInetAddr" ref="a45f3a58b6a06ec785080e9d0c986fedf" args="(int32_t off) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrt_1_1InetAddress.html">InetAddress</a> vrt::BasicVRTPacket::unpackPayloadInetAddr </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks a <a class="el" href="classvrt_1_1InetAddress.html">InetAddress</a> from the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="InetAddress_8h_source.html#l00185">vrt::VRTMath::unpackInetAddr()</a>.</p>

</div>
</div>
<a class="anchor" id="a8780af80abf334ac4b1984ab003586a6"></a><!-- doxytag: member="vrt::BasicVRTPacket::unpackPayloadInt" ref="a8780af80abf334ac4b1984ab003586a6" args="(int32_t off) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::BasicVRTPacket::unpackPayloadInt </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks a 32-bit integer from the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="VRTMath_8h_source.html#l00813">vrt::VRTMath::unpackInt()</a>.</p>

<p>Referenced by <a class="el" href="ReferencePointPacket_8h_source.html#l00094">vrt::ReferencePointPacket::getRefPointID()</a>.</p>

</div>
</div>
<a class="anchor" id="af32b45b09d2d1c80dfc1797874ea0638"></a><!-- doxytag: member="vrt::BasicVRTPacket::unpackPayloadLong" ref="af32b45b09d2d1c80dfc1797874ea0638" args="(int32_t off) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vrt::BasicVRTPacket::unpackPayloadLong </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks a 64-bit integer from the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="VRTMath_8h_source.html#l00835">vrt::VRTMath::unpackLong()</a>.</p>

<p>Referenced by <a class="el" href="EphemerisPacket_8h_source.html#l00519">vrt::EphemerisPacket::getFixDelta()</a>, and <a class="el" href="TimestampAccuracyPacket_8h_source.html#l00138">vrt::TimestampAccuracyPacket::getTimestampAccuracy()</a>.</p>

</div>
</div>
<a class="anchor" id="a25c8ae1cfb4ecc1f14c7ac3870fcc769"></a><!-- doxytag: member="vrt::BasicVRTPacket::unpackPayloadMetadata" ref="a25c8ae1cfb4ecc1f14c7ac3870fcc769" args="(int32_t off, int32_t len) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrt_1_1MetadataBlock.html">MetadataBlock</a> vrt::BasicVRTPacket::unpackPayloadMetadata </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks a metadata block from the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="namespacevrt_1_1VRTMath.html#a6cc65757d0e95057485375a6907703be">vrt::VRTMath::unpackMetadata()</a>.</p>

</div>
</div>
<a class="anchor" id="a72b46b8fab765919e60f2c710d5fd832"></a><!-- doxytag: member="vrt::BasicVRTPacket::unpackPayloadRecord" ref="a72b46b8fab765919e60f2c710d5fd832" args="(int32_t off, Record &amp;rec) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::unpackPayloadRecord </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrt_1_1Record.html">Record</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks a record from the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="namespacevrt_1_1VRTMath.html#a381a914b6e2172aa2715869569074ef5">vrt::VRTMath::unpackRecord()</a>.</p>

<p>Referenced by <a class="el" href="BasicContextPacket_8h_source.html#l00493">vrt::BasicContextPacket::get3DPointingVectorStructured()</a>, <a class="el" href="BasicContextPacket_8h_source.html#l00465">vrt::BasicContextPacket::getCIFsArray()</a>, <a class="el" href="BasicContextPacket_8h_source.html#l00426">vrt::BasicContextPacket::getContextAssocLists()</a>, <a class="el" href="BasicContextPacket_8h_source.html#l00396">vrt::BasicContextPacket::getEphemeris()</a>, <a class="el" href="BasicContextPacket_8h_source.html#l00388">vrt::BasicContextPacket::getGeolocation()</a>, <a class="el" href="BasicContextPacket_8h_source.html#l00412">vrt::BasicContextPacket::getGeoSentences()</a>, <a class="el" href="BasicContextPacket_8h_source.html#l00439">vrt::BasicContextPacket::getIndexList()</a>, <a class="el" href="BasicContextPacket_8h_source.html#l00452">vrt::BasicContextPacket::getSectorScanStep()</a>, and <a class="el" href="BasicContextPacket_8h_source.html#l00480">vrt::BasicContextPacket::getSpectrumField()</a>.</p>

</div>
</div>
<a class="anchor" id="a331f8f0dc0e3a6f6dc681f02ce6fa41a"></a><!-- doxytag: member="vrt::BasicVRTPacket::unpackPayloadShort" ref="a331f8f0dc0e3a6f6dc681f02ce6fa41a" args="(int32_t off) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t vrt::BasicVRTPacket::unpackPayloadShort </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks a 16-bit integer from the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="VRTMath_8h_source.html#l00767">vrt::VRTMath::unpackShort()</a>.</p>

</div>
</div>
<a class="anchor" id="a4baf23471e2c07a8ecfdd80e2513bf96"></a><!-- doxytag: member="vrt::BasicVRTPacket::unpackPayloadTimeStamp" ref="a4baf23471e2c07a8ecfdd80e2513bf96" args="(int32_t off, IntegerMode epoch) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> vrt::BasicVRTPacket::unpackPayloadTimeStamp </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerMode&nbsp;</td>
          <td class="paramname"> <em>epoch</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks a <a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> from the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="TimeStamp_8h_source.html#l01180">vrt::VRTMath::unpackTimeStamp()</a>.</p>

<p>Referenced by <a class="el" href="EphemerisPacket_8h_source.html#l00502">vrt::EphemerisPacket::getFixTime()</a>.</p>

</div>
</div>
<a class="anchor" id="a72d6603b1ccf650daab309a4c64132ed"></a><!-- doxytag: member="vrt::BasicVRTPacket::unpackPayloadUTF8" ref="a72d6603b1ccf650daab309a4c64132ed" args="(int32_t off, int32_t len) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wstring vrt::BasicVRTPacket::unpackPayloadUTF8 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks a UTF-8 string from the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="namespacevrt_1_1VRTMath.html#a887aa55d34bfb4e224a7766e897796d4">vrt::VRTMath::unpackUTF8()</a>.</p>

<p>Referenced by <a class="el" href="ReferencePointPacket_8h_source.html#l00129">vrt::ReferencePointPacket::getDescription()</a>, and <a class="el" href="StreamStatePacket_8h_source.html#l00312">vrt::StreamStatePacket::getMessage()</a>.</p>

</div>
</div>
<a class="anchor" id="a39f048ff416d2a0824317ba62820c97f"></a><!-- doxytag: member="vrt::BasicVRTPacket::unpackPayloadUUID" ref="a39f048ff416d2a0824317ba62820c97f" args="(int32_t off) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrt_1_1UUID.html">UUID</a> vrt::BasicVRTPacket::unpackPayloadUUID </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks a <a class="el" href="classvrt_1_1UUID.html">UUID</a> from the payload of the packet. </p>

<p>References <a class="el" href="BasicVRTPacket_8h_source.html#l00154">bbuf</a>, <a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d">getPrologueLength()</a>, and <a class="el" href="UUID_8h_source.html#l00157">vrt::VRTMath::unpackUUID()</a>.</p>

</div>
</div>
<a class="anchor" id="a74d62dc0c3372e6fdff366e9dc518589"></a><!-- doxytag: member="vrt::BasicVRTPacket::writePayload" ref="a74d62dc0c3372e6fdff366e9dc518589" args="(void *buffer, int32_t poff, int32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::BasicVRTPacket::writePayload </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>poff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>Optional functionality:</em> Writes to the packet payload, but does NOT update the length of the payload. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>The buffer to with the new data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poff</em>&nbsp;</td><td>The payload offset to start writing to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length to write. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If this method is not supported or if there is insufficient room to write to. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l00918">setPayload()</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a11bdcad0429c5f6899f5a37848d4ffb2"></a><!-- doxytag: member="vrt::BasicVRTPacket::bbuf" ref="a11bdcad0429c5f6899f5a37848d4ffb2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;char&gt; <a class="el" href="classvrt_1_1BasicVRTPacket.html#a11bdcad0429c5f6899f5a37848d4ffb2">vrt::BasicVRTPacket::bbuf</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packet buffer (always includes the header). </p>

<p>Referenced by <a class="el" href="BasicContextPacket_8h_source.html#l00316">vrt::BasicContextPacket::getContextIndicatorField0()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00883">vrt::BasicDataPacket::getDataByte()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00723">vrt::BasicDataPacket::getDataDouble()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00755">vrt::BasicDataPacket::getDataFloat()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00819">vrt::BasicDataPacket::getDataInt()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00787">vrt::BasicDataPacket::getDataLong()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l00851">vrt::BasicDataPacket::getDataShort()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00603">getPacketLength()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00219">isNullValue()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00982">packPayloadAscii()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00965">packPayloadBoolean()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00963">packPayloadBoolNull()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00951">packPayloadByte()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00971">packPayloadBytes()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00961">packPayloadDouble()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00959">packPayloadFloat()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00977">packPayloadInetAddr()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00955">packPayloadInt()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00957">packPayloadLong()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00969">packPayloadMetadata()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00967">packPayloadRecord()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00953">packPayloadShort()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00975">packPayloadTimeStamp()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00995">packPayloadUTF8()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00979">packPayloadUUID()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01365">vrt::BasicDataPacket::setDataByte()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01230">vrt::BasicDataPacket::setDataDouble()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01257">vrt::BasicDataPacket::setDataFloat()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01311">vrt::BasicDataPacket::setDataInt()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01284">vrt::BasicDataPacket::setDataLong()</a>, <a class="el" href="BasicDataPacket_8h_source.html#l01338">vrt::BasicDataPacket::setDataShort()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00937">swap()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01039">unpackPayloadAscii()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01035">unpackPayloadBoolean()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01033">unpackPayloadBoolNull()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01021">unpackPayloadByte()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01045">unpackPayloadBytes()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01031">unpackPayloadDouble()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01029">unpackPayloadFloat()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01051">unpackPayloadInetAddr()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01025">unpackPayloadInt()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01027">unpackPayloadLong()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01043">unpackPayloadMetadata()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01037">unpackPayloadRecord()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01023">unpackPayloadShort()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01049">unpackPayloadTimeStamp()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01041">unpackPayloadUTF8()</a>, and <a class="el" href="BasicVRTPacket_8h_source.html#l01053">unpackPayloadUUID()</a>.</p>

</div>
</div>
<a class="anchor" id="aa10f55e3e65fdbb63a621a8d278f9a2b"></a><!-- doxytag: member="vrt::BasicVRTPacket::MAX_HEADER_LENGTH" ref="aa10f55e3e65fdbb63a621a8d278f9a2b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="classvrt_1_1BasicVRTPacket.html#aa10f55e3e65fdbb63a621a8d278f9a2b">vrt::BasicVRTPacket::MAX_HEADER_LENGTH</a> = 7*4<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The maximum length of the header in bytes (all optional fields included). </p>
<p>Note that in cases where optional fields are not included, the header will be shorter. </p>
<pre>
    MAX_HEADER_LENGTH = 7*4
  </pre> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classvrt_1_1BasicVRTPacket.html#a0da41f9a95a036c7591f264fb992fb36" title="Gets the header length in bytes (does not include packet specific prologue or trailer)...">getHeaderLength()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ace1fce903f77599d549f3ae7943a1b9e"></a><!-- doxytag: member="vrt::BasicVRTPacket::MAX_PACKET_LENGTH" ref="ace1fce903f77599d549f3ae7943a1b9e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="classvrt_1_1BasicVRTPacket.html#ace1fce903f77599d549f3ae7943a1b9e">vrt::BasicVRTPacket::MAX_PACKET_LENGTH</a> = 65536*4<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The maximum length of the packet in bytes (header + payload + trailer). </p>
<p>Note that this is the absolute limit imposed by the VRT specification. The underlying transport protocols used (e.g. IP, UDP, TCP, etc.) have limits lower than this. </p>
<pre>
    MAX_PACKET_LENGTH = 65536*4
  </pre> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classvrt_1_1BasicVRTPacket.html#a40001fcd6ad5a5cc2532124048af3518" title="Gets the packet length in bytes.">getPacketLength()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a02ab6f6b7075f9e481abeecbfe095c45"></a><!-- doxytag: member="vrt::BasicVRTPacket::MAX_PAYLOAD_LENGTH" ref="a02ab6f6b7075f9e481abeecbfe095c45" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="classvrt_1_1BasicVRTPacket.html#a02ab6f6b7075f9e481abeecbfe095c45">vrt::BasicVRTPacket::MAX_PAYLOAD_LENGTH</a> = <a class="el" href="classvrt_1_1BasicVRTPacket.html#ace1fce903f77599d549f3ae7943a1b9e">MAX_PACKET_LENGTH</a> - <a class="el" href="classvrt_1_1BasicVRTPacket.html#aa747a5913faf7dcce6f79a3ced6a4007">MAX_PROLOGUE_LENGTH</a> - <a class="el" href="classvrt_1_1BasicVRTPacket.html#a74f683b39777f1e9289d6e3d7fe55dde">MAX_TRAILER_LENGTH</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The <b>de-facto</b> maximum length of the payload in bytes. </p>
<p>Note that the de-jure limit can be up to 28 bytes more than this when optional fields in the header, packet specific prologue, and trailer are dropped. In practice this difference is nearly meaningless since (as noted with <a class="el" href="classvrt_1_1BasicVRTPacket.html#ace1fce903f77599d549f3ae7943a1b9e">MAX_PACKET_LENGTH</a>) this value exceeds the limits of the underlying transport protocols. </p>
<pre>
    MAX_PAYLOAD_LENGTH = MAX_PACKET_LENGTH - MAX_PROLOGUE_LENGTH - MAX_TRAILER_LENGTH
  </pre> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classvrt_1_1BasicVRTPacket.html#a408e5bbadcd6099619e264a412223c36" title="Gets the payload length in bytes.">getPayloadLength()</a> </dd></dl>

<p>Referenced by <a class="el" href="ReferencePointPacket_8h_source.html#l00137">vrt::ReferencePointPacket::setDescription()</a>, and <a class="el" href="StreamStatePacket_8h_source.html#l00320">vrt::StreamStatePacket::setMessage()</a>.</p>

</div>
</div>
<a class="anchor" id="aa2d11cdbf080d8fef18da55596bbe85e"></a><!-- doxytag: member="vrt::BasicVRTPacket::MAX_PKT_SPECIFIC_PROLOGUE_LENGTH" ref="aa2d11cdbf080d8fef18da55596bbe85e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="classvrt_1_1BasicVRTPacket.html#aa2d11cdbf080d8fef18da55596bbe85e">vrt::BasicVRTPacket::MAX_PKT_SPECIFIC_PROLOGUE_LENGTH</a> = 10*4<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The maximum length of the packet specific prologue (PSP) in bytes (all optional fields included). </p>
<p>Note that in cases where optional fields are not included, the PSP will be shorter. </p>
<pre>
    MAX_PKT_SPECIFIC_PROLOGUE_LENGTH = 10*4
  </pre> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classvrt_1_1BasicVRTPacket.html#a4a6710bd7de5d1416c8377dc5a92d9a6" title="Gets the packet specific prologue (PSP) length in bytes.">getPktSpecificPrologueLength()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa747a5913faf7dcce6f79a3ced6a4007"></a><!-- doxytag: member="vrt::BasicVRTPacket::MAX_PROLOGUE_LENGTH" ref="aa747a5913faf7dcce6f79a3ced6a4007" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="classvrt_1_1BasicVRTPacket.html#aa747a5913faf7dcce6f79a3ced6a4007">vrt::BasicVRTPacket::MAX_PROLOGUE_LENGTH</a> = <a class="el" href="classvrt_1_1BasicVRTPacket.html#aa10f55e3e65fdbb63a621a8d278f9a2b">MAX_HEADER_LENGTH</a> + <a class="el" href="classvrt_1_1BasicVRTPacket.html#aa2d11cdbf080d8fef18da55596bbe85e">MAX_PKT_SPECIFIC_PROLOGUE_LENGTH</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The maximum length of the prologue in bytes (all optional fields included). </p>
<p>Note that in cases where optional fields are not included, the prologue will be shorter. </p>
<pre>
    MAX_PROLOGUE_LENGTH = MAX_HEADER_LENGTH + MAX_PKT_SPECIFIC_PROLOGUE_LENGTH
  </pre> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classvrt_1_1BasicVRTPacket.html#a200f38adde97a2778b330fd75a5cbc8d" title="Gets the prologue length in bytes (includes header and packet specific prologue,...">getPrologueLength()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a74f683b39777f1e9289d6e3d7fe55dde"></a><!-- doxytag: member="vrt::BasicVRTPacket::MAX_TRAILER_LENGTH" ref="a74f683b39777f1e9289d6e3d7fe55dde" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="classvrt_1_1BasicVRTPacket.html#a74f683b39777f1e9289d6e3d7fe55dde">vrt::BasicVRTPacket::MAX_TRAILER_LENGTH</a> = 1*4<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The maximum length of the trailer in bytes. </p>
<pre>
    MAX_TRAILER_LENGTH = 1*4
  </pre> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classvrt_1_1BasicVRTPacket.html#ae0b07bf5ad5721cbc4f4d769de18376b" title="Gets the trailer length in bytes.">getTrailerLength()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa2d0565c557146d39cc817a7f7b2241d"></a><!-- doxytag: member="vrt::BasicVRTPacket::NULL_PACKET" ref="aa2d0565c557146d39cc817a7f7b2241d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvrt_1_1BasicVRTPacket.html">BasicVRTPacket</a> <a class="el" href="classvrt_1_1BasicVRTPacket.html#aa2d0565c557146d39cc817a7f7b2241d">vrt::BasicVRTPacket::NULL_PACKET</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Represents a null VRT packet. </p>

</div>
</div>
<a class="anchor" id="a40626801621f637d0be9da791c68e788"></a><!-- doxytag: member="vrt::BasicVRTPacket::readOnly" ref="a40626801621f637d0be9da791c68e788" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvrt_1_1BasicVRTPacket.html#a40626801621f637d0be9da791c68e788">vrt::BasicVRTPacket::readOnly</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is this instance read-only? </p>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l00937">swap()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cpp_src/vrt/lib/<a class="el" href="BasicVRTPacket_8h_source.html">BasicVRTPacket.h</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 29 Jun 2018 for VRT by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>

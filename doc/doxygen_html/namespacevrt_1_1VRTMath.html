<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VRT: vrt::VRTMath Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>vrt</b>::<a class="el" href="namespacevrt_1_1VRTMath.html">VRTMath</a>
  </div>
</div>
<div class="contents">
<h1>vrt::VRTMath Namespace Reference</h1>
<p>Supports conversions to/from the various numeric representations used within a VITA 49 packet.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvrt_1_1VRTMath_1_1type__requirement_3_01true_00_01T_01_4.html">type_requirement&lt; true, T &gt;</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a0d551f4f59ae709fbb4afaa2c8ac3cea">_fromHalfInternal</a> (int16_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an IEEE 754-2008 half-precision floating-point (storage only) bit representation to an IEEE 754 single-precision floating-point value.  <a href="#a0d551f4f59ae709fbb4afaa2c8ac3cea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a8895ec7c7071157bc9935387edcc665c">_toHalfInternal</a> (float val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Converts an IEEE 754 single-precision floating-point value to the bits equating to an IEEE 754-2008 half-precision (storage only) value.  <a href="#a8895ec7c7071157bc9935387edcc665c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a43097d96e865bb8961bf5ca28828316a">doubleToRawLongBits</a> (double val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an IEEE-764 double into the corresponding 64-bits contained in a 64-bit integer.  <a href="#a43097d96e865bb8961bf5ca28828316a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a3a5e19820ad6eb1d86b2469dec5109ef">floatToRawIntBits</a> (float val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an IEEE-764 float into the corresponding 32-bits contained in a 32-bit integer.  <a href="#a3a5e19820ad6eb1d86b2469dec5109ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a7e719ae80be55ed0636497aae91b6403">fromDouble16</a> (int32_t radixPoint, double val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a float to a 32-bit fixed point number.  <a href="#a7e719ae80be55ed0636497aae91b6403"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a646919c24ab63544a2bf71275fcc5bda">fromDouble32</a> (int32_t radixPoint, double val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a float to a 32-bit fixed point number.  <a href="#a646919c24ab63544a2bf71275fcc5bda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a430c35069ac3ed99bb869b1f2f04437f">fromDouble64</a> (int32_t radixPoint, double val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a float to a 64-bit fixed point number.  <a href="#a430c35069ac3ed99bb869b1f2f04437f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a540db23a4c75b5a3ee9304958c6836fd">fromFloat16</a> (int32_t radixPoint, float val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a float to a 16-bit fixed point number.  <a href="#a540db23a4c75b5a3ee9304958c6836fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#aaf74c4fda38336ff6bae10fcf695d0c6">fromFloat32</a> (int32_t radixPoint, float val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a float to a 32-bit fixed point number.  <a href="#aaf74c4fda38336ff6bae10fcf695d0c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ae9c88539c09271dffba0c1ed7d78aabe">fromFloat64</a> (int32_t radixPoint, float val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a float to a 64-bit fixed point number.  <a href="#ae9c88539c09271dffba0c1ed7d78aabe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a62cff3f408b479e8632d48213b3989b6">fromHalf</a> (int16_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an IEEE 754-2008 half-precision floating-point (storage only) bit representation to an IEEE 754 single-precision floating-point value.  <a href="#a62cff3f408b479e8632d48213b3989b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ab42f6366b5ff1b99f6d0d56258030cff">fromInt16</a> (int32_t radixPoint, int32_t val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an int32_t to a 16-bit fixed point number.  <a href="#ab42f6366b5ff1b99f6d0d56258030cff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ae4a12c5cbada1dd6828a0a93edba34f8">fromInt32</a> (int32_t radixPoint, int32_t val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an int32_t to a 32-bit fixed point number.  <a href="#ae4a12c5cbada1dd6828a0a93edba34f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a4c0003a8473053eac6b69ea894d5a2b4">fromInt64</a> (int32_t radixPoint, int32_t val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an int32_t to a 64-bit fixed point number.  <a href="#a4c0003a8473053eac6b69ea894d5a2b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a2694b03436ff74677a52e7526b157396">fromLong16</a> (int32_t radixPoint, int64_t val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a int64_t to a 16-bit fixed point number.  <a href="#a2694b03436ff74677a52e7526b157396"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#aba0d575654a72bed050c2649bc8ef42c">fromLong32</a> (int32_t radixPoint, int64_t val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a int64_t to a 32-bit fixed point number.  <a href="#aba0d575654a72bed050c2649bc8ef42c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#aed8186191c41d3738fbc72806c11863c">fromLong64</a> (int32_t radixPoint, int64_t val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a int64_t to a 64-bit fixed point number.  <a href="#aed8186191c41d3738fbc72806c11863c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ada379ba6716250930fa5a72bd251dbc1">fromVRTFloat</a> (DataItemFormat form, int32_t dSize, int64_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts from the packed bits for a VRT floating-point to an IEEE-754 double-precision floating-point value.  <a href="#ada379ba6716250930fa5a72bd251dbc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a7232367c8b58f283cbe17c70dfd85bc1">fromVRTFloat32</a> (bool sign, int32_t eSize, int32_t dSize, int32_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Converts from the packed bits for a VRT floating-point to an IEEE-754 double-precision floating-point value <b>without normal safety checks</b>.  <a href="#a7232367c8b58f283cbe17c70dfd85bc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a2dafad324689c30811784fea28aa8040">fromVRTFloat64</a> (bool sign, int32_t eSize, int32_t dSize, int64_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Converts from the packed bits for a VRT floating-point to an IEEE-754 double-precision floating-point value <b>without normal safety checks</b>.  <a href="#a2dafad324689c30811784fea28aa8040"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a52dd95b940336a845ee6d6402385f576">intBitsToFloat</a> (int32_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts the 32-bits corresponding to an IEEE-764 float, as contained in a 32-bit integer, into an IEEE-764 float.  <a href="#a52dd95b940336a845ee6d6402385f576"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ac3da15de0e858bc834dfc69bd43eb1d6">lengthUTF8</a> (const string &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the length a UTF-8 string will need in a buffer.  <a href="#ac3da15de0e858bc834dfc69bd43eb1d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a57216579825b7412fe806ff934bf2d06">lengthUTF8</a> (const wstring &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the length a UTF-8 string will need in a buffer.  <a href="#a57216579825b7412fe806ff934bf2d06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ae3d20200405607229adb9ff895d87666">longBitsToDouble</a> (int64_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts the 64-bits corresponding to an IEEE-764 double, as contained in a 64-bit integer, into an IEEE-764 double.  <a href="#ae3d20200405607229adb9ff895d87666"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a82e52db07eb2793bc50d6c426580c9ac">packAscii</a> (vector&lt; char &gt; &amp;buf, int32_t off, const wstring &amp;val, int32_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a ASCII string into a buffer.  <a href="#a82e52db07eb2793bc50d6c426580c9ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a0d0682ced2552f28417c3bcb7d90cc6b">packAscii</a> (void *ptr, int32_t off, const wstring &amp;val, int32_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a ASCII string into a buffer.  <a href="#a0d0682ced2552f28417c3bcb7d90cc6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#acd50c652565b2a911041026f12929f26">packAscii</a> (vector&lt; char &gt; &amp;buf, int32_t off, const string &amp;val, int32_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a ASCII string into a buffer.  <a href="#acd50c652565b2a911041026f12929f26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a3c7d32193d1beb4a21fcbee46e7878b4">packAscii</a> (void *ptr, int32_t off, const string &amp;val, int32_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a ASCII string into a buffer.  <a href="#a3c7d32193d1beb4a21fcbee46e7878b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a4dca5bed2dbaee957d13213ef134dd2f">packBits32</a> (void *ptr, int32_t bitOffset, int32_t bitCount, int32_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Writes bits to a buffer without safety checks.  <a href="#a4dca5bed2dbaee957d13213ef134dd2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a1fae166f2656fa3904d9102be0ed9603">packBits64</a> (void *ptr, int32_t bitOffset, int32_t bitCount, int64_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Writes bits to a buffer without safety checks.  <a href="#a1fae166f2656fa3904d9102be0ed9603"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#acf648738bb08d255cd043c9adb669e00">packBoolean</a> (vector&lt; char &gt; &amp;buf, int32_t off, bool val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a boolean into a buffer.  <a href="#acf648738bb08d255cd043c9adb669e00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#abdcc61a2586d1b270225dd6888ee5c71">packBoolean</a> (void *ptr, int32_t off, bool val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a boolean into a buffer.  <a href="#abdcc61a2586d1b270225dd6888ee5c71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a741764ec207f434ad71a357fbd21cd46">packBoolNull</a> (vector&lt; char &gt; &amp;buf, int32_t off, boolNull val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a boolean into a buffer.  <a href="#a741764ec207f434ad71a357fbd21cd46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ac760c83504c33af645ff166664a85f12">packBoolNull</a> (void *ptr, int32_t off, boolNull val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a boolean into a buffer.  <a href="#ac760c83504c33af645ff166664a85f12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a72a924f8922c5eee9590a7a01d9947ec">packByte</a> (vector&lt; char &gt; &amp;buf, int32_t off, char val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack byte data into byte buffer.  <a href="#a72a924f8922c5eee9590a7a01d9947ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a709891d5b906fd8394361171282db02b">packByte</a> (void *ptr, int32_t off, char val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack byte data into byte buffer.  <a href="#a709891d5b906fd8394361171282db02b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ad31bc1800a6d1066119eb7f9c2161567">packBytes</a> (vector&lt; char &gt; &amp;buf, int32_t off, const void *buffer, int32_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack an array of bytes into the buffer.  <a href="#ad31bc1800a6d1066119eb7f9c2161567"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#abff703bbf1162e53453c3dc17aecd02f">packBytes</a> (vector&lt; char &gt; &amp;buf, int32_t off, const vector&lt; char &gt; &amp;buffer, int32_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack an array of bytes into the buffer.  <a href="#abff703bbf1162e53453c3dc17aecd02f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a3a8d6998c4d54e367205f9c743870a0d">packDouble</a> (vector&lt; char &gt; &amp;buf, int32_t off, double val, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack double data into byte buffer.  <a href="#a3a8d6998c4d54e367205f9c743870a0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ac65bfb3c4ec48f778bc0354728d8e90e">packDouble</a> (void *ptr, int32_t off, double val, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack double data into byte buffer.  <a href="#ac65bfb3c4ec48f778bc0354728d8e90e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a8211a9b689ec93d3faacb86a0f224257">packFloat</a> (vector&lt; char &gt; &amp;buf, int32_t off, float val, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack float data into byte buffer.  <a href="#a8211a9b689ec93d3faacb86a0f224257"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a788ce2377377ec076ed0f360b2808dc3">packFloat</a> (void *ptr, int32_t off, float val, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack float data into byte buffer.  <a href="#a788ce2377377ec076ed0f360b2808dc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#aa6f69ac01e3321c53acfe665bc438f7a">packInetAddr</a> (vector&lt; char &gt; &amp;buf, int32_t off, const <a class="el" href="classvrt_1_1InetAddress.html">InetAddress</a> &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a 16-byte IPv6 address into a buffer.  <a href="#aa6f69ac01e3321c53acfe665bc438f7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ac0fff2b83255a420f25e0784bd366f9f">packInetAddr</a> (void *ptr, int32_t off, const <a class="el" href="classvrt_1_1InetAddress.html">InetAddress</a> &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a 16-byte IPv6 address into a buffer.  <a href="#ac0fff2b83255a420f25e0784bd366f9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a4c60a3faa0a40b6a98896df4f5120fe3">packInt</a> (vector&lt; char &gt; &amp;buf, int32_t off, int32_t val, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack int data into byte buffer.  <a href="#a4c60a3faa0a40b6a98896df4f5120fe3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a21e984c1aa15564f2ad335c50797346a">packInt</a> (void *ptr, int32_t off, int32_t val, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack int data into byte buffer.  <a href="#a21e984c1aa15564f2ad335c50797346a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ae6ff0f0aaa4aab02874a7bcbba74c297">packInt24</a> (vector&lt; char &gt; &amp;buf, int32_t off, int32_t val, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Pack a 24-bit integer value as an int data from a byte buffer.  <a href="#ae6ff0f0aaa4aab02874a7bcbba74c297"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a504a335987dcd521f40f938f2834a04f">packInt24</a> (void *ptr, int32_t off, int32_t val, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Pack a 24-bit integer value as an int data from a byte buffer.  <a href="#a504a335987dcd521f40f938f2834a04f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a685141bef563f93ad0ee7592b9199ffb">packLong</a> (vector&lt; char &gt; &amp;buf, int32_t off, int64_t val, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack long data into byte buffer.  <a href="#a685141bef563f93ad0ee7592b9199ffb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a718994d7c18bb58c72aa3914783ff10d">packLong</a> (void *ptr, int32_t off, int64_t val, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack long data into byte buffer.  <a href="#a718994d7c18bb58c72aa3914783ff10d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a2caf91200db7580abace6c9c51c43374">packMetadata</a> (vector&lt; char &gt; &amp;buf, int32_t off, const <a class="el" href="classvrt_1_1MetadataBlock.html">MetadataBlock</a> &amp;val, int32_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a metadata block into a buffer.  <a href="#a2caf91200db7580abace6c9c51c43374"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#aaee853c53dbbfaab48ebfeff8d412b70">packRecord</a> (vector&lt; char &gt; &amp;buf, int32_t off, const <a class="el" href="classvrt_1_1Record.html">Record</a> &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a record into a buffer.  <a href="#aaee853c53dbbfaab48ebfeff8d412b70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a634798fab7866c4a877832b9368a471c">packShort</a> (vector&lt; char &gt; &amp;buf, int32_t off, int16_t val, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack short data into byte buffer.  <a href="#a634798fab7866c4a877832b9368a471c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a95e2cba136b7006243b8cfd95f4c6d20">packShort</a> (void *ptr, int32_t off, int16_t val, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack short data into byte buffer.  <a href="#a95e2cba136b7006243b8cfd95f4c6d20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a2308a1e7f88edabafa9738f1e0302fae">packTimeStamp</a> (vector&lt; char &gt; &amp;buf, int32_t off, const <a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> &amp;val, IntegerMode epoch, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a VITA 49.0 time stamp into a buffer.  <a href="#a2308a1e7f88edabafa9738f1e0302fae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#aef7be55d6b817aaa8a8ec8d7aaf8ffbc">packTimeStamp</a> (void *ptr, int32_t off, const <a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> &amp;val, IntegerMode epoch, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a VITA 49.0 time stamp into a buffer.  <a href="#aef7be55d6b817aaa8a8ec8d7aaf8ffbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a59a70ac0f0dde361264a8134319d6c1f">packUByte</a> (vector&lt; char &gt; &amp;buf, int32_t off, unsigned char val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack unsigned byte data into byte buffer.  <a href="#a59a70ac0f0dde361264a8134319d6c1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a83e4319491815e18d67083f7fe7f82a1">packUByte</a> (void *ptr, int32_t off, unsigned char val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack unsigned byte data into byte buffer.  <a href="#a83e4319491815e18d67083f7fe7f82a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a4d93f8143d901d88ce09bc532677edb9">packUInt</a> (vector&lt; char &gt; &amp;buf, int32_t off, uint32_t val, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack unsigned int data into byte buffer.  <a href="#a4d93f8143d901d88ce09bc532677edb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#aed3d8fae40e2a74a0f83c1b473ada722">packUInt</a> (void *ptr, int32_t off, uint32_t val, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack unsigned int data into byte buffer.  <a href="#aed3d8fae40e2a74a0f83c1b473ada722"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a0d9e3197b19aaca2aa1c23677e7f27c1">packUInt24</a> (vector&lt; char &gt; &amp;buf, int32_t off, int32_t val, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Pack a 24-bit integer value as an int data from a byte buffer.  <a href="#a0d9e3197b19aaca2aa1c23677e7f27c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a21f615b284f6de71c91b60c25425c9c6">packUInt24</a> (void *ptr, int32_t off, int32_t val, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Pack a 24-bit integer value as an int data from a byte buffer.  <a href="#a21f615b284f6de71c91b60c25425c9c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a8d22289b0510651bfb41d3b865d6ab22">packULong</a> (vector&lt; char &gt; &amp;buf, int32_t off, uint64_t val, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack unsigned long data into byte buffer.  <a href="#a8d22289b0510651bfb41d3b865d6ab22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#aad974fe764dd16d6bf08f63a6fb172b5">packULong</a> (void *ptr, int32_t off, uint64_t val, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack unsigned long data into byte buffer.  <a href="#aad974fe764dd16d6bf08f63a6fb172b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a0abab924b972a5c2585b5a386091a947">packUShort</a> (vector&lt; char &gt; &amp;buf, int32_t off, uint16_t val, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack unsigned short data into byte buffer.  <a href="#a0abab924b972a5c2585b5a386091a947"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a344ad933388deeb8a3f7e1ee95dd397e">packUShort</a> (void *ptr, int32_t off, uint16_t val, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack unsigned short data into byte buffer.  <a href="#a344ad933388deeb8a3f7e1ee95dd397e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a0f370d9020f895f4b82eb1250639a080">packUTF8</a> (vector&lt; char &gt; &amp;buf, int32_t off, const string &amp;val, int32_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a UTF-8 string into a buffer.  <a href="#a0f370d9020f895f4b82eb1250639a080"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a7173b0890a7478776514b928864a02f0">packUTF8</a> (void *ptr, int32_t off, const string &amp;val, int32_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a UTF-8 string into a buffer.  <a href="#a7173b0890a7478776514b928864a02f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a07851bb74a8a691dbe598671e573f131">packUTF8</a> (vector&lt; char &gt; &amp;buf, int32_t off, const wstring &amp;val, int32_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a UTF-8 string into a buffer.  <a href="#a07851bb74a8a691dbe598671e573f131"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a6d45e3bdc1dd1bc8153a07bc072f8c5a">packUTF8</a> (void *ptr, int32_t off, const wstring &amp;val, int32_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a UTF-8 string into a buffer.  <a href="#a6d45e3bdc1dd1bc8153a07bc072f8c5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a422ee13d4da795e155762db2904be954">packUUID</a> (vector&lt; char &gt; &amp;buf, int32_t off, const <a class="el" href="classvrt_1_1UUID.html">UUID</a> &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a 16-byte <a class="el" href="classvrt_1_1UUID.html" title="A 128-bit universally unique identifier (UUID).">UUID</a> into a buffer.  <a href="#a422ee13d4da795e155762db2904be954"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a5e026ce2a877b2bc66ecaec8662d3261">packUUID</a> (void *ptr, int32_t off, const <a class="el" href="classvrt_1_1UUID.html">UUID</a> &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a 16-byte <a class="el" href="classvrt_1_1UUID.html" title="A 128-bit universally unique identifier (UUID).">UUID</a> into a buffer.  <a href="#a5e026ce2a877b2bc66ecaec8662d3261"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T2&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a2052c6872f58b38323ca705d4d1a2c67">safecastT1ToT2</a> (T1 val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an from one type to another type of same size using memcpy.  <a href="#a2052c6872f58b38323ca705d4d1a2c67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a9e129192d5b590ed56aa125c1e6d413e">toDouble16</a> (int32_t radixPoint, int16_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a 16-bit fixed point number to a float.  <a href="#a9e129192d5b590ed56aa125c1e6d413e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ae53780bfdea74c0b88b3793211d6c73d">toDouble32</a> (int32_t radixPoint, int32_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a 32-bit fixed point number to a float.  <a href="#ae53780bfdea74c0b88b3793211d6c73d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a96d510640398f31e066d204389c215e1">toDouble64</a> (int32_t radixPoint, int64_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a 64-bit fixed point number to a float.  <a href="#a96d510640398f31e066d204389c215e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a0dd42dc696edf245b7828d93868768ac">toFloat16</a> (int32_t radixPoint, int16_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a 16-bit fixed point number to a float.  <a href="#a0dd42dc696edf245b7828d93868768ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a354e6d7856c069b2f5d0664c355b5df7">toFloat32</a> (int32_t radixPoint, int32_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a 32-bit fixed point number to a float.  <a href="#a354e6d7856c069b2f5d0664c355b5df7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a64830a9fffc52a78aeecb77db880b118">toFloat64</a> (int32_t radixPoint, int64_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a 64-bit fixed point number to a float.  <a href="#a64830a9fffc52a78aeecb77db880b118"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ab99e24105366c3d00ac441809794378c">toHalf</a> (float val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an IEEE 754 single-precision floating-point value to the bits equating to an IEEE 754-2008 half-precision (storage only) value.  <a href="#ab99e24105366c3d00ac441809794378c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a4a69985e46106bc4f96d5d22d695a077">toInt16</a> (int32_t radixPoint, int16_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a 16-bit fixed point number to an int.  <a href="#a4a69985e46106bc4f96d5d22d695a077"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ac82e658005d695c91c3762da94a644f8">toInt32</a> (int32_t radixPoint, int32_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a 32-bit fixed point number to an int.  <a href="#ac82e658005d695c91c3762da94a644f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a9158791670e78a460da2a6d9ad623f60">toInt64</a> (int32_t radixPoint, int64_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a 64-bit fixed point number to an int.  <a href="#a9158791670e78a460da2a6d9ad623f60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a1e96a28bb7b16625bb2bb06134fe68c3">toLong16</a> (int32_t radixPoint, int16_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a 16-bit fixed point number to a long.  <a href="#a1e96a28bb7b16625bb2bb06134fe68c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a629b94640a99fcf526ea2a7297b0c427">toLong32</a> (int32_t radixPoint, int32_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a 32-bit fixed point number to a long.  <a href="#a629b94640a99fcf526ea2a7297b0c427"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#acb8d8b085b2034184fb8ace3589e4fb6">toLong64</a> (int32_t radixPoint, int64_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a 64-bit fixed point number to a long.  <a href="#acb8d8b085b2034184fb8ace3589e4fb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a8a2101a77f6c3a94652ca3f730470ab9">toVRTFloat</a> (DataItemFormat form, int32_t dSize, double val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts from an IEEE-754 double-precision floating-point value to the packed bits for a VRT floating-point.  <a href="#a8a2101a77f6c3a94652ca3f730470ab9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a148e111a58dbb1f246e2e3e406761132">toVRTFloat32</a> (bool sign, int32_t eSize, int32_t dSize, double val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Converts from an IEEE-754 double-precision floating-point value to the packed bits for a VRT floating-point <b>without normal safety checks</b>.  <a href="#a148e111a58dbb1f246e2e3e406761132"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#abd63dd135e0208eaa7a958d875d17541">toVRTFloat64</a> (bool sign, int32_t eSize, int32_t dSize, double val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Converts from an IEEE-754 double-precision floating-point value to the packed bits for a VRT floating-point <b>without normal safety checks</b>.  <a href="#abd63dd135e0208eaa7a958d875d17541"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a1887b011e4b9e34055e8aa4fac1f2edc">unpackAscii</a> (const vector&lt; char &gt; &amp;buf, int32_t off, int32_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack a ASCII string from a buffer.  <a href="#a1887b011e4b9e34055e8aa4fac1f2edc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a8a61c533c98f77c4943a309bb1de9256">unpackAscii</a> (const void *ptr, int32_t off, int32_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack a ASCII string from a buffer.  <a href="#a8a61c533c98f77c4943a309bb1de9256"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ab0964b5106e2564ec1fcdf5e584e4f52">unpackBits32</a> (const void *ptr, int32_t bitOffset, int32_t bitCount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Reads bits from a buffer without safety checks.  <a href="#ab0964b5106e2564ec1fcdf5e584e4f52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a152343c94e81e4599939cc706465e87f">unpackBits64</a> (const void *ptr, int32_t bitOffset, int32_t bitCount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Reads bits from a buffer without safety checks.  <a href="#a152343c94e81e4599939cc706465e87f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a51cb541743703f32dad387848d8661f2">unpackBoolean</a> (const vector&lt; char &gt; &amp;buf, int32_t off)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack a boolean from a buffer.  <a href="#a51cb541743703f32dad387848d8661f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a5af1b4911b0d0103fa04ee5cca5d8c92">unpackBoolean</a> (const void *ptr, int32_t off)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack a boolean from a buffer.  <a href="#a5af1b4911b0d0103fa04ee5cca5d8c92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#abf00115fe69ec308c79c3aabe16ae21e">unpackBoolNull</a> (const vector&lt; char &gt; &amp;buf, int32_t off)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack a boolean from a buffer.  <a href="#abf00115fe69ec308c79c3aabe16ae21e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolNull&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ad724d3ff607ef08f13338e3f70cbdd88">unpackBoolNull</a> (const void *ptr, int32_t off)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack a boolean from a buffer.  <a href="#ad724d3ff607ef08f13338e3f70cbdd88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a70b29888a678452a463ab33242bbea7e">unpackByte</a> (const vector&lt; char &gt; &amp;buf, int32_t off)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack byte data from a byte buffer.  <a href="#a70b29888a678452a463ab33242bbea7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#aeb55aaee77f65011a8d0577e06cf03b1">unpackByte</a> (const void *ptr, int32_t off)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack byte data from a byte buffer.  <a href="#aeb55aaee77f65011a8d0577e06cf03b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a85530f02ecde8bf8f4a1384cb5b020b7">unpackBytes</a> (const vector&lt; char &gt; &amp;buf, int32_t off, void *buffer, int32_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack an array of bytes from a buffer.  <a href="#a85530f02ecde8bf8f4a1384cb5b020b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; char &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ae6d94aa2c4846211481fbd42955bc63c">unpackBytes</a> (const vector&lt; char &gt; &amp;buf, int32_t off, int32_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack an array of bytes from a buffer.  <a href="#ae6d94aa2c4846211481fbd42955bc63c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a1c52c26d8fa09f18562f937b2c6cac90">unpackDouble</a> (const vector&lt; char &gt; &amp;buf, int32_t off, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack double data from a byte buffer.  <a href="#a1c52c26d8fa09f18562f937b2c6cac90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a83c714efccb03423bf8357813bc08f35">unpackDouble</a> (const void *ptr, int32_t off, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack double data from a byte buffer.  <a href="#a83c714efccb03423bf8357813bc08f35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#aafefc4c9041eb868d16727f4da900faa">unpackFloat</a> (const vector&lt; char &gt; &amp;buf, int32_t off, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack float data from a byte buffer.  <a href="#aafefc4c9041eb868d16727f4da900faa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a31268efa9a769ed7842c1ecc656a0e36">unpackFloat</a> (const void *ptr, int32_t off, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack float data from a byte buffer.  <a href="#a31268efa9a769ed7842c1ecc656a0e36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrt_1_1InetAddress.html">InetAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#aee75c62c9dc18373008c80bcfbdb7f17">unpackInetAddr</a> (const vector&lt; char &gt; &amp;buf, int32_t off)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack a 16-byte IPv6 address from a buffer.  <a href="#aee75c62c9dc18373008c80bcfbdb7f17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrt_1_1InetAddress.html">InetAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#af33991d7efb59e7ed0cabb1d8b935439">unpackInetAddr</a> (const void *ptr, int32_t off)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack a 16-byte IPv6 address from a buffer.  <a href="#af33991d7efb59e7ed0cabb1d8b935439"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ab644c651177bd2c3f81085f7f1beeb07">unpackInt</a> (const vector&lt; char &gt; &amp;buf, int32_t off, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack int data from a byte buffer.  <a href="#ab644c651177bd2c3f81085f7f1beeb07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ad5bf9b32f28078eab2d733c2318fa1d1">unpackInt</a> (const void *ptr, int32_t off, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack int data from a byte buffer.  <a href="#ad5bf9b32f28078eab2d733c2318fa1d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ac40fcd1efc24876703aaa328c662bac0">unpackInt24</a> (const vector&lt; char &gt; &amp;buf, int32_t off, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Unpack a 24-bit integer value as an int data from a byte buffer  <a href="#ac40fcd1efc24876703aaa328c662bac0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ae84b2606228c76a229343a34aaff8244">unpackInt24</a> (const void *ptr, int32_t off, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Unpack a 24-bit integer value as an int data from a byte buffer  <a href="#ae84b2606228c76a229343a34aaff8244"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ac8196945ee3c93169ee200d612a74b3b">unpackLong</a> (const vector&lt; char &gt; &amp;buf, int32_t off, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack long data from a byte buffer.  <a href="#ac8196945ee3c93169ee200d612a74b3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a7672d15d90aff779434ca999995b38b7">unpackLong</a> (const void *ptr, int32_t off, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack long data from a byte buffer.  <a href="#a7672d15d90aff779434ca999995b38b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrt_1_1MetadataBlock.html">MetadataBlock</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a6cc65757d0e95057485375a6907703be">unpackMetadata</a> (const vector&lt; char &gt; &amp;buf, int32_t off, int32_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack a metadata block into a buffer.  <a href="#a6cc65757d0e95057485375a6907703be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a381a914b6e2172aa2715869569074ef5">unpackRecord</a> (const vector&lt; char &gt; &amp;buf, int32_t off, <a class="el" href="classvrt_1_1Record.html">Record</a> &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a record into a buffer.  <a href="#a381a914b6e2172aa2715869569074ef5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#afb9d13c6454cb5815dc3fb642cc6866d">unpackShort</a> (const vector&lt; char &gt; &amp;buf, int32_t off, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack short data from a byte buffer.  <a href="#afb9d13c6454cb5815dc3fb642cc6866d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a264fbdb80810f4db5f85096fdfe59c36">unpackShort</a> (const void *ptr, int32_t off, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack short data from a byte buffer.  <a href="#a264fbdb80810f4db5f85096fdfe59c36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ac53dfa251acf1887213518bca6fca93e">unpackTimeStamp</a> (const vector&lt; char &gt; &amp;buf, int32_t off, IntegerMode epoch, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack an VITA 49.0 time stamp from a buffer.  <a href="#ac53dfa251acf1887213518bca6fca93e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a8ebad613b55ad53a76ce530dc6726cfa">unpackTimeStamp</a> (const void *ptr, int32_t off, IntegerMode epoch, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack an VITA 49.0 time stamp from a buffer.  <a href="#a8ebad613b55ad53a76ce530dc6726cfa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#abe4dbc7887c1fb5269bd2de5301bd355">unpackUByte</a> (const vector&lt; char &gt; &amp;buf, int32_t off)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack unsigned byte data from a byte buffer.  <a href="#abe4dbc7887c1fb5269bd2de5301bd355"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a2b3a973f0cd00ebfae95fee5c64486aa">unpackUByte</a> (const void *ptr, int32_t off)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack unsigned byte data from a byte buffer.  <a href="#a2b3a973f0cd00ebfae95fee5c64486aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a093290796e219d44aa4d3aff4f5d8a1e">unpackUInt</a> (const vector&lt; char &gt; &amp;buf, int32_t off, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack unsigned int data from a byte buffer.  <a href="#a093290796e219d44aa4d3aff4f5d8a1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ae199a445f6393f76e87b76ba26ff0c4b">unpackUInt</a> (const void *ptr, int32_t off, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack unsigned int data from a byte buffer.  <a href="#ae199a445f6393f76e87b76ba26ff0c4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a05d058ea4e35e8211b46536e6f7ef602">unpackUInt24</a> (const vector&lt; char &gt; &amp;buf, int32_t off, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Unpack an unsigned 24-bit integer value as an int data from a byte buffer  <a href="#a05d058ea4e35e8211b46536e6f7ef602"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a5364224e826a0f9ffd1885cd42c9a14b">unpackUInt24</a> (const void *ptr, int32_t off, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Internal Use Only:</b> Unpack an unsigned 24-bit integer value as an int data from a byte buffer  <a href="#a5364224e826a0f9ffd1885cd42c9a14b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#aece17a32b84e416d01ec650be6fa5c44">unpackULong</a> (const vector&lt; char &gt; &amp;buf, int32_t off, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack unsigned long data from a byte buffer.  <a href="#aece17a32b84e416d01ec650be6fa5c44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a40a76b7acab976cd87c1dc73f725f5cd">unpackULong</a> (const void *ptr, int32_t off, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack unsigned long data from a byte buffer.  <a href="#a40a76b7acab976cd87c1dc73f725f5cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a83ddd4d364b9a4271d09aa546e5bbc69">unpackUShort</a> (const vector&lt; char &gt; &amp;buf, int32_t off, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack unsigned short data from a byte buffer.  <a href="#a83ddd4d364b9a4271d09aa546e5bbc69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a029d8638649d515c09bddcbf59aecc38">unpackUShort</a> (const void *ptr, int32_t off, ByteOrder rep=BIG_ENDIAN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack unsigned short data from a byte buffer.  <a href="#a029d8638649d515c09bddcbf59aecc38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#ad9ff76ee1537464c6139198b4a45ff13">unpackUTF8</a> (const vector&lt; char &gt; &amp;buf, int32_t off, int32_t len, wchar_t replacement='?')</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack a modified UTF-8 string from a buffer.  <a href="#ad9ff76ee1537464c6139198b4a45ff13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#a887aa55d34bfb4e224a7766e897796d4">unpackUTF8</a> (const void *ptr, int32_t off, int32_t len, wchar_t replacement='?')</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack a modified UTF-8 string from a buffer.  <a href="#a887aa55d34bfb4e224a7766e897796d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrt_1_1UUID.html">UUID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#abd1bdc2a7ab31312cb3d58e7af21ec86">unpackUUID</a> (const vector&lt; char &gt; &amp;buf, int32_t off)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack a 16-byte <a class="el" href="classvrt_1_1UUID.html" title="A 128-bit universally unique identifier (UUID).">UUID</a> from a buffer.  <a href="#abd1bdc2a7ab31312cb3d58e7af21ec86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrt_1_1UUID.html">UUID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevrt_1_1VRTMath.html#aa2587a0037e96b2a8629dccff49258de">unpackUUID</a> (const void *ptr, int32_t off)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack a 16-byte <a class="el" href="classvrt_1_1UUID.html" title="A 128-bit universally unique identifier (UUID).">UUID</a> from a buffer.  <a href="#aa2587a0037e96b2a8629dccff49258de"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Supports conversions to/from the various numeric representations used within a VITA 49 packet. </p>
<p>The name <code><a class="el" href="namespacevrt_1_1VRTMath.html" title="Supports conversions to/from the various numeric representations used within a VITA...">VRTMath</a></code> is a bit of an anachronism in that the only "math" done on the special data types used in a VITA 49 (VRT) packet is in the functions that convert between these special types and standard Java/C++ data types. <br/>
 <br/>
 </p>
<h2>IEEE 754-2008 16-bit Floating-Point Numbers</h2>
<p><b><em>The use of 16-bit IEEE 754-2008 floating-point numbers is not currently part of the VITA 49 standard, but is under consideration for inclusion in a future revision. Their inclusion here is to support the necessary analysis work that would precede any such inclusion.</em></b><br/>
 <br/>
 Since IEEE 754-2008 16-bit floating-point numbers are a storage-only format and are not supported by Java or C++ <em>(though some C++ compilers have non-standard extensions for them)</em> the routines necessary for converting between 16-bit floating-point numbers (called "half-precision") and single-precision numbers are included here. <br/>
 <br/>
 </p>
<h2>VRT Floating-Point Numbers</h2>
<p>Supports conversion between an IEEE-754 floating-point value and the packed packed bits for a VRT floating-point. <br/>
 <br/>
 Although VRT floating-point values can express many values in multiple ways within the binary form (e.g. 1/4 or 2/8) this function outputs the values in a "normalized form" where the output value will have a 1 in the most-significant-(non-sign-)bit of the mantissa, excepting for small values close to zero where the exponent is zero. This mirrors the behavior of IEEE-754 floating-point values, excepting that the highest bit is always present (not just for "denormal" values). <br/>
 <br/>
 Since the range of VRT floating-point numbers is [0,1) (signed) or [-1,1) (unsigned) any values below/above that range will be converted to the smallest/largest value possible in that range. Any NaN values passed in will be converted to zero. <em>This is similar to the standard behavior for IEEE 754 numbers when converting them to an integer.</em> <br/>
 <br/>
 </p>
<h2>VRT Fixed-Point Numbers</h2>
<p>Supports fixed-point numbers compatible with VRT. </p>
<pre>
    Example:</pre><pre>    31                                  0
    [00000000|00000000|0000oooo|oooooooo]
                           ^ radixPoint = 12</pre><pre>    20-bit whole number (2's complement) + 12 bit binary fraction</pre><pre>    Convert to/from double: toDouble32(20, bits)  -&gt; val
                            fromDouble32(20, val) -&gt; bits
  </pre><p> <b>Note that all of the VRT fixed-point conversions assume that a valid radix point has been given, and will have unspecified behavior if the radix point is invalid.</b> <br/>
 <br/>
 Any values given that are out-of-range with respect to the output will be automatically converted to the nearest in-range value, and any floating-point NaN values given will become zero. Where the fixed-point value has less precision than the input value, the input value will be "rounded" to the nearest fixed-point value.<br/>
 <br/>
 <em>Implementation Note: Prior versions of this library took a "garbage in
  garbage out" approach to out-of-range values in the interest of maximizing performance. Unfortunately the rounding involved in converting the numbers to fixed point created a situation where input values extremely close to the min/max limits could end up rounded to an out-of-range value and result in a bogus result. In the end the code to perform a conversion to the nearest in-range value (for all input values) is no more complex than the code required to support this special-case situation, hence the current approach. </em><br/>
 <br/>
 </p>
<h2>Summary</h2>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<th><p>&nbsp; </p>
</th><th colspan="2"><p>Convert to/from <code>long</code> </p>
</th><th colspan="2"><p>Convert to/from <code>int</code> </p>
</th><th colspan="2"><p>Convert to/from <code>double</code> </p>
</th><th colspan="2"><p>Convert to/from <code>float</code>  </p>
</th></tr>
<tr>
<th><p>IEEE 754 16-bit Floating-Point </p>
</th><td><p>n/a </p>
</td><td><p>n/a </p>
</td><td><p>n/a </p>
</td><td><p>n/a </p>
</td><td><p>n/a </p>
</td><td><p>n/a </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#ab99e24105366c3d00ac441809794378c">toHalf(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#a62cff3f408b479e8632d48213b3989b6">fromHalf(..)</a>  </p>
</td></tr>
<tr>
<th><p>VRT Floating-Point </p>
</th><td><p>n/a </p>
</td><td><p>n/a </p>
</td><td><p>n/a </p>
</td><td><p>n/a </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#a8a2101a77f6c3a94652ca3f730470ab9">toVRTFloat(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#ada379ba6716250930fa5a72bd251dbc1">fromVRTFloat(..)</a> </p>
</td><td><p>TBD </p>
</td><td><p>TBD  </p>
</td></tr>
<tr>
<th><p>VRT 64-bit Fixed <a class="el" href="classvrt_1_1Point.html" title="Point Definition.">Point</a> </p>
</th><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#acb8d8b085b2034184fb8ace3589e4fb6">toLong64(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#aed8186191c41d3738fbc72806c11863c">fromLong64(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#a9158791670e78a460da2a6d9ad623f60">toInt64(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#a4c0003a8473053eac6b69ea894d5a2b4">fromInt64(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#a96d510640398f31e066d204389c215e1">toDouble64(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#a430c35069ac3ed99bb869b1f2f04437f">fromDouble64(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#a64830a9fffc52a78aeecb77db880b118">toFloat64(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#ae9c88539c09271dffba0c1ed7d78aabe">fromFloat64(..)</a>  </p>
</td></tr>
<tr>
<th><p>VRT 32-bit Fixed <a class="el" href="classvrt_1_1Point.html" title="Point Definition.">Point</a> </p>
</th><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#a629b94640a99fcf526ea2a7297b0c427">toLong32(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#aba0d575654a72bed050c2649bc8ef42c">fromLong32(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#ac82e658005d695c91c3762da94a644f8">toInt32(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#ae4a12c5cbada1dd6828a0a93edba34f8">fromInt32(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#ae53780bfdea74c0b88b3793211d6c73d">toDouble32(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#a646919c24ab63544a2bf71275fcc5bda">fromDouble32(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#a354e6d7856c069b2f5d0664c355b5df7">toFloat32(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#aaf74c4fda38336ff6bae10fcf695d0c6">fromFloat32(..)</a>  </p>
</td></tr>
<tr>
<th><p>VRT 16-bit Fixed <a class="el" href="classvrt_1_1Point.html" title="Point Definition.">Point</a> </p>
</th><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#a1e96a28bb7b16625bb2bb06134fe68c3">toLong16(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#a2694b03436ff74677a52e7526b157396">fromLong16(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#a4a69985e46106bc4f96d5d22d695a077">toInt16(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#ab42f6366b5ff1b99f6d0d56258030cff">fromInt16(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#a9e129192d5b590ed56aa125c1e6d413e">toDouble16(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#a7e719ae80be55ed0636497aae91b6403">fromDouble16(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#a0dd42dc696edf245b7828d93868768ac">toFloat16(..)</a> </p>
</td><td><p><a class="el" href="namespacevrt_1_1VRTMath.html#a540db23a4c75b5a3ee9304958c6836fd">fromFloat16(..)</a>  </p>
</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a0d551f4f59ae709fbb4afaa2c8ac3cea"></a><!-- doxytag: member="vrt::VRTMath::_fromHalfInternal" ref="a0d551f4f59ae709fbb4afaa2c8ac3cea" args="(int16_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float vrt::VRTMath::_fromHalfInternal </td>
          <td>(</td>
          <td class="paramtype">int16_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts an IEEE 754-2008 half-precision floating-point (storage only) bit representation to an IEEE 754 single-precision floating-point value. </p>
<p><br/>
 <br/>
 This is the "internal library" call provided as a companion to <code>fromHalf(..)</code> and should never be called directly. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>The bits representing the half-precision value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The single-precision value. </dd></dl>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00449">fromHalf()</a>.</p>

</div>
</div>
<a class="anchor" id="a8895ec7c7071157bc9935387edcc665c"></a><!-- doxytag: member="vrt::VRTMath::_toHalfInternal" ref="a8895ec7c7071157bc9935387edcc665c" args="(float val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t vrt::VRTMath::_toHalfInternal </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Converts an IEEE 754 single-precision floating-point value to the bits equating to an IEEE 754-2008 half-precision (storage only) value. </p>
<p><br/>
 <br/>
 This is the "internal library" call provided as a companion to <code>toHalf(..)</code> and should never be called directly. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The single-precision value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bits representing the half-precision value. </dd></dl>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00406">toHalf()</a>.</p>

</div>
</div>
<a class="anchor" id="a43097d96e865bb8961bf5ca28828316a"></a><!-- doxytag: member="vrt::VRTMath::doubleToRawLongBits" ref="a43097d96e865bb8961bf5ca28828316a" args="(double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vrt::VRTMath::doubleToRawLongBits </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts an IEEE-764 double into the corresponding 64-bits contained in a 64-bit integer. </p>
<p><br/>
 <br/>
 The name of this function is patterned after the Java function (as this provides some consistency between the Java and C++ version), but the implementation is entirely different. </p>

<p>References <a class="el" href="VRTMath_8h_source.html#l00328">doubleToRawLongBits()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00328">doubleToRawLongBits()</a>.</p>

</div>
</div>
<a class="anchor" id="a3a5e19820ad6eb1d86b2469dec5109ef"></a><!-- doxytag: member="vrt::VRTMath::floatToRawIntBits" ref="a3a5e19820ad6eb1d86b2469dec5109ef" args="(float val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::floatToRawIntBits </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts an IEEE-764 float into the corresponding 32-bits contained in a 32-bit integer. </p>
<p><br/>
 <br/>
 The name of this function is patterned after the Java function (as this provides some consistency between the Java and C++ version), but the implementation is entirely different. </p>

<p>References <a class="el" href="VRTMath_8h_source.html#l00339">floatToRawIntBits()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00339">floatToRawIntBits()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e719ae80be55ed0636497aae91b6403"></a><!-- doxytag: member="vrt::VRTMath::fromDouble16" ref="a7e719ae80be55ed0636497aae91b6403" args="(int32_t radixPoint, double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t vrt::VRTMath::fromDouble16 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a float to a 32-bit fixed point number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..15). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The floating-point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bits representing the fixed-point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00654">fromDouble16()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00654">fromDouble16()</a>, and <a class="el" href="VRTMath_8h_source.html#l00676">fromFloat16()</a>.</p>

</div>
</div>
<a class="anchor" id="a646919c24ab63544a2bf71275fcc5bda"></a><!-- doxytag: member="vrt::VRTMath::fromDouble32" ref="a646919c24ab63544a2bf71275fcc5bda" args="(int32_t radixPoint, double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::fromDouble32 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a float to a 32-bit fixed point number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..31). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The floating-point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bits representing the fixed-point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00567">fromDouble32()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00567">fromDouble32()</a>, <a class="el" href="VRTMath_8h_source.html#l00589">fromFloat32()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00751">vrt::Geolocation::setAltitude()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00892">vrt::Ephemeris::setAttitudeAlpha()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00900">vrt::Ephemeris::setAttitudeBeta()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00908">vrt::Ephemeris::setAttitudePhi()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00767">vrt::Geolocation::setHeadingAngle()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00735">vrt::Geolocation::setLatitude()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00743">vrt::Geolocation::setLongitude()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00783">vrt::Geolocation::setMagneticVariation()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00844">vrt::Ephemeris::setPositionX()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00852">vrt::Ephemeris::setPositionY()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00860">vrt::Ephemeris::setPositionZ()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03311">vrt::IndicatorFieldProvider::setRange()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00759">vrt::Geolocation::setSpeedOverGround()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00775">vrt::Geolocation::setTrackAngle()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00940">vrt::Ephemeris::setVelocityX()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00948">vrt::Ephemeris::setVelocityY()</a>, and <a class="el" href="IndicatorFields_8h_source.html#l00956">vrt::Ephemeris::setVelocityZ()</a>.</p>

</div>
</div>
<a class="anchor" id="a430c35069ac3ed99bb869b1f2f04437f"></a><!-- doxytag: member="vrt::VRTMath::fromDouble64" ref="a430c35069ac3ed99bb869b1f2f04437f" args="(int32_t radixPoint, double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vrt::VRTMath::fromDouble64 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a float to a 64-bit fixed point number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..63). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The floating-point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bits representing the fixed-point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00481">fromDouble64()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00481">fromDouble64()</a>, <a class="el" href="VRTMath_8h_source.html#l00503">fromFloat64()</a>, <a class="el" href="IndicatorFields_8h_source.html#l02876">vrt::IndicatorFieldProvider::setAuxBandwidth()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03006">vrt::IndicatorFieldProvider::setAuxFrequency()</a>, <a class="el" href="IndicatorFields_8h_source.html#l02481">vrt::IndicatorFieldProvider::setBandOffsetIF()</a>, <a class="el" href="IndicatorFields_8h_source.html#l02445">vrt::IndicatorFieldProvider::setBandwidth()</a>, <a class="el" href="IndicatorFields_8h_source.html#l02454">vrt::IndicatorFieldProvider::setFrequencyIF()</a>, <a class="el" href="IndicatorFields_8h_source.html#l02472">vrt::IndicatorFieldProvider::setFrequencyOffsetRF()</a>, <a class="el" href="IndicatorFields_8h_source.html#l02463">vrt::IndicatorFieldProvider::setFrequencyRF()</a>, and <a class="el" href="IndicatorFields_8h_source.html#l02531">vrt::IndicatorFieldProvider::setSampleRate()</a>.</p>

</div>
</div>
<a class="anchor" id="a540db23a4c75b5a3ee9304958c6836fd"></a><!-- doxytag: member="vrt::VRTMath::fromFloat16" ref="a540db23a4c75b5a3ee9304958c6836fd" args="(int32_t radixPoint, float val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t vrt::VRTMath::fromFloat16 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a float to a 16-bit fixed point number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..15). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The floating-point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bits representing the fixed-point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00654">fromDouble16()</a>, and <a class="el" href="VRTMath_8h_source.html#l00676">fromFloat16()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00676">fromFloat16()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03532">vrt::IndicatorFieldProvider::set3DPointingVectorAzimuth()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03512">vrt::IndicatorFieldProvider::set3DPointingVectorElevation()</a>, <a class="el" href="IndicatorFields_8h_source.html#l04702">vrt::IndicatorFieldProvider::setAirTemperature()</a>, <a class="el" href="IndicatorFields_8h_source.html#l02937">vrt::IndicatorFieldProvider::setAuxGain1()</a>, <a class="el" href="IndicatorFields_8h_source.html#l02958">vrt::IndicatorFieldProvider::setAuxGain2()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03285">vrt::IndicatorFieldProvider::setBitErrorRate()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03266">vrt::IndicatorFieldProvider::setEbN0()</a>, <a class="el" href="IndicatorFields_8h_source.html#l02502">vrt::IndicatorFieldProvider::setGain1()</a>, <a class="el" href="IndicatorFields_8h_source.html#l02518">vrt::IndicatorFieldProvider::setGain2()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03066">vrt::IndicatorFieldProvider::setNoiseFigure()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03144">vrt::IndicatorFieldProvider::setOneDecibelCompressionPoint()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03619">vrt::IndicatorFieldProvider::setPhaseOffset()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03589">vrt::IndicatorFieldProvider::setPolarizationEllipticityAngle()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03571">vrt::IndicatorFieldProvider::setPolarizationTiltAngle()</a>, <a class="el" href="IndicatorFields_8h_source.html#l02490">vrt::IndicatorFieldProvider::setReferenceLevel()</a>, <a class="el" href="IndicatorFields_8h_source.html#l04672">vrt::IndicatorFieldProvider::setSeaGroundTemperature()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03103">vrt::IndicatorFieldProvider::setSecondOrderInputInterceptPoint()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03046">vrt::IndicatorFieldProvider::setSNR()</a>, <a class="el" href="IndicatorFields_8h_source.html#l02550">vrt::IndicatorFieldProvider::setTemperature()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03120">vrt::IndicatorFieldProvider::setThirdOrderInputInterceptPoint()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03187">vrt::IndicatorFieldProvider::setThreshold1()</a>, and <a class="el" href="IndicatorFields_8h_source.html#l03202">vrt::IndicatorFieldProvider::setThreshold2()</a>.</p>

</div>
</div>
<a class="anchor" id="aaf74c4fda38336ff6bae10fcf695d0c6"></a><!-- doxytag: member="vrt::VRTMath::fromFloat32" ref="aaf74c4fda38336ff6bae10fcf695d0c6" args="(int32_t radixPoint, float val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::fromFloat32 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a float to a 32-bit fixed point number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..31). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The floating-point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bits representing the fixed-point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00567">fromDouble32()</a>, and <a class="el" href="VRTMath_8h_source.html#l00589">fromFloat32()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00589">fromFloat32()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03327">vrt::IndicatorFieldProvider::setBeamwidth()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03354">vrt::IndicatorFieldProvider::setHorizontalBeamwidth()</a>, and <a class="el" href="IndicatorFields_8h_source.html#l03379">vrt::IndicatorFieldProvider::setVerticalBeamwidth()</a>.</p>

</div>
</div>
<a class="anchor" id="ae9c88539c09271dffba0c1ed7d78aabe"></a><!-- doxytag: member="vrt::VRTMath::fromFloat64" ref="ae9c88539c09271dffba0c1ed7d78aabe" args="(int32_t radixPoint, float val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vrt::VRTMath::fromFloat64 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a float to a 64-bit fixed point number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..63). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The floating-point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bits representing the fixed-point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00481">fromDouble64()</a>, and <a class="el" href="VRTMath_8h_source.html#l00503">fromFloat64()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00503">fromFloat64()</a>.</p>

</div>
</div>
<a class="anchor" id="a62cff3f408b479e8632d48213b3989b6"></a><!-- doxytag: member="vrt::VRTMath::fromHalf" ref="a62cff3f408b479e8632d48213b3989b6" args="(int16_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float vrt::VRTMath::fromHalf </td>
          <td>(</td>
          <td class="paramtype">int16_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts an IEEE 754-2008 half-precision floating-point (storage only) bit representation to an IEEE 754 single-precision floating-point value. </p>
<pre>
    References:
      [1] IEEE 754-2008.
      [2] Jeroen van der Zijp. "Fast Half Float Conversions." November
          2008 (Revised September 2010).
          <a href="ftp://ftp.fox-toolkit.org/pub/fasthalffloatconversion.pdf">ftp://ftp.fox-toolkit.org/pub/fasthalffloatconversion.pdf</a>
      [3] Free Software Foundation, Inc. "Using the GNU Compiler Collection
          (GCC)." 2013. [Section 6.12 "Half-Precision Floating Point."]
          <a href="http://gcc.gnu.org/onlinedocs/gcc/Half_002dPrecision.html">http://gcc.gnu.org/onlinedocs/gcc/Half_002dPrecision.html</a>
          [Last Accessed 5 Aug 2013]
      [4] Intel. "Intel C++ Compiler XE 13.1 User and Reference Guides."
          Document Number 323273-131US. 2013. ["Intrinsics for Converting
          Half Floats."]
          <a href="http://software.intel.com/sites/products/documentation/doclib/iss/2013/compiler/cpp-lin/GUID-23C8FF6D-3D66-4961-A3A0-E2A7DC874304.htm">http://software.intel.com/sites/products/documentation/doclib/iss/2013/compiler/cpp-lin/GUID-23C8FF6D-3D66-4961-A3A0-E2A7DC874304.htm</a>
          [Last Accessed 5 Aug 2013]
  </pre> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>The bits representing the half-precision value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The single-precision value. </dd></dl>

<p>References <a class="el" href="namespacevrt_1_1VRTMath.html#a0d551f4f59ae709fbb4afaa2c8ac3cea">_fromHalfInternal()</a>, and <a class="el" href="VRTMath_8h_source.html#l00449">fromHalf()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00449">fromHalf()</a>.</p>

</div>
</div>
<a class="anchor" id="ab42f6366b5ff1b99f6d0d56258030cff"></a><!-- doxytag: member="vrt::VRTMath::fromInt16" ref="ab42f6366b5ff1b99f6d0d56258030cff" args="(int32_t radixPoint, int32_t val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t vrt::VRTMath::fromInt16 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts an int32_t to a 16-bit fixed point number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..15). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bits representing the fixed-point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00698">fromInt16()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00698">fromInt16()</a>.</p>

</div>
</div>
<a class="anchor" id="ae4a12c5cbada1dd6828a0a93edba34f8"></a><!-- doxytag: member="vrt::VRTMath::fromInt32" ref="ae4a12c5cbada1dd6828a0a93edba34f8" args="(int32_t radixPoint, int32_t val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::fromInt32 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts an int32_t to a 32-bit fixed point number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..31). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bits representing the fixed-point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00610">fromInt32()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00610">fromInt32()</a>.</p>

</div>
</div>
<a class="anchor" id="a4c0003a8473053eac6b69ea894d5a2b4"></a><!-- doxytag: member="vrt::VRTMath::fromInt64" ref="a4c0003a8473053eac6b69ea894d5a2b4" args="(int32_t radixPoint, int32_t val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vrt::VRTMath::fromInt64 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts an int32_t to a 64-bit fixed point number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..63). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bits representing the fixed-point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00544">fromInt64()</a>, and <a class="el" href="VRTMath_8h_source.html#l00524">fromLong64()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00544">fromInt64()</a>.</p>

</div>
</div>
<a class="anchor" id="a2694b03436ff74677a52e7526b157396"></a><!-- doxytag: member="vrt::VRTMath::fromLong16" ref="a2694b03436ff74677a52e7526b157396" args="(int32_t radixPoint, int64_t val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t vrt::VRTMath::fromLong16 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a int64_t to a 16-bit fixed point number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..15). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bits representing the fixed-point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00718">fromLong16()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00718">fromLong16()</a>.</p>

</div>
</div>
<a class="anchor" id="aba0d575654a72bed050c2649bc8ef42c"></a><!-- doxytag: member="vrt::VRTMath::fromLong32" ref="aba0d575654a72bed050c2649bc8ef42c" args="(int32_t radixPoint, int64_t val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::fromLong32 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a int64_t to a 32-bit fixed point number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..31). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bits representing the fixed-point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00630">fromLong32()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00630">fromLong32()</a>.</p>

</div>
</div>
<a class="anchor" id="aed8186191c41d3738fbc72806c11863c"></a><!-- doxytag: member="vrt::VRTMath::fromLong64" ref="aed8186191c41d3738fbc72806c11863c" args="(int32_t radixPoint, int64_t val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vrt::VRTMath::fromLong64 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a int64_t to a 64-bit fixed point number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..63). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bits representing the fixed-point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00524">fromLong64()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00544">fromInt64()</a>, and <a class="el" href="VRTMath_8h_source.html#l00524">fromLong64()</a>.</p>

</div>
</div>
<a class="anchor" id="ada379ba6716250930fa5a72bd251dbc1"></a><!-- doxytag: member="vrt::VRTMath::fromVRTFloat" ref="ada379ba6716250930fa5a72bd251dbc1" args="(DataItemFormat form, int32_t dSize, int64_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vrt::VRTMath::fromVRTFloat </td>
          <td>(</td>
          <td class="paramtype">DataItemFormat&nbsp;</td>
          <td class="paramname"> <em>form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>dSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts from the packed bits for a VRT floating-point to an IEEE-754 double-precision floating-point value. </p>
<p><br/>
 <br/>
 Despite the fact that <a class="el" href="namespacevrt_1_1VRTMath.html#a8a2101a77f6c3a94652ca3f730470ab9">toVRTFloat</a> normalizes its output values, this function will support all of the valid VRT forms and convert them to their respective IEEE-754 value. Since IEEE-754 values are normalized this process results not reflective. </p>
<pre>
    References:
      [1] ANSI/VITA 49.0, Appendix D
      [2] IEEE-754
  </pre> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>form</em>&nbsp;</td><td>The data item format. This must be one of the VRT floating-point formats. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dSize</em>&nbsp;</td><td>The data size in bits (2..63). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>The packed bits to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The IEEE-754 floating-point number. </dd></dl>

</div>
</div>
<a class="anchor" id="a7232367c8b58f283cbe17c70dfd85bc1"></a><!-- doxytag: member="vrt::VRTMath::fromVRTFloat32" ref="a7232367c8b58f283cbe17c70dfd85bc1" args="(bool sign, int32_t eSize, int32_t dSize, int32_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vrt::VRTMath::fromVRTFloat32 </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>eSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>dSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Converts from the packed bits for a VRT floating-point to an IEEE-754 double-precision floating-point value <b>without normal safety checks</b>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sign</em>&nbsp;</td><td>Is output signed? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eSize</em>&nbsp;</td><td>The number of exponent bits (1 to 6). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dSize</em>&nbsp;</td><td>The data size in bits (2..63). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>The packed bits to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2dafad324689c30811784fea28aa8040"></a><!-- doxytag: member="vrt::VRTMath::fromVRTFloat64" ref="a2dafad324689c30811784fea28aa8040" args="(bool sign, int32_t eSize, int32_t dSize, int64_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vrt::VRTMath::fromVRTFloat64 </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>eSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>dSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Converts from the packed bits for a VRT floating-point to an IEEE-754 double-precision floating-point value <b>without normal safety checks</b>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sign</em>&nbsp;</td><td>Is output signed? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eSize</em>&nbsp;</td><td>The number of exponent bits (1 to 6). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dSize</em>&nbsp;</td><td>The data size in bits (2..63). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>The packed bits to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a52dd95b940336a845ee6d6402385f576"></a><!-- doxytag: member="vrt::VRTMath::intBitsToFloat" ref="a52dd95b940336a845ee6d6402385f576" args="(int32_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float vrt::VRTMath::intBitsToFloat </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts the 32-bits corresponding to an IEEE-764 float, as contained in a 32-bit integer, into an IEEE-764 float. </p>
<p><br/>
 <br/>
 The name of this function is patterned after the Java function (as this provides some consistency between the Java and C++ version), but the implementation is entirely different. </p>

<p>References <a class="el" href="VRTMath_8h_source.html#l00361">intBitsToFloat()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00361">intBitsToFloat()</a>.</p>

</div>
</div>
<a class="anchor" id="ac3da15de0e858bc834dfc69bd43eb1d6"></a><!-- doxytag: member="vrt::VRTMath::lengthUTF8" ref="ac3da15de0e858bc834dfc69bd43eb1d6" args="(const string &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::lengthUTF8 </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the length a UTF-8 string will need in a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The string </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The length required to hold the entire UTF-8 string. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01617">lengthUTF8()</a>, and <a class="el" href="namespacevrt_1_1VRTMath.html#a6d45e3bdc1dd1bc8153a07bc072f8c5a">packUTF8()</a>.</p>

</div>
</div>
<a class="anchor" id="a57216579825b7412fe806ff934bf2d06"></a><!-- doxytag: member="vrt::VRTMath::lengthUTF8" ref="a57216579825b7412fe806ff934bf2d06" args="(const wstring &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::lengthUTF8 </td>
          <td>(</td>
          <td class="paramtype">const wstring &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the length a UTF-8 string will need in a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The string </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The length required to hold the entire UTF-8 string. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01617">lengthUTF8()</a>, and <a class="el" href="namespacevrt_1_1VRTMath.html#a6d45e3bdc1dd1bc8153a07bc072f8c5a">packUTF8()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l01617">lengthUTF8()</a>, <a class="el" href="ReferencePointPacket_8h_source.html#l00137">vrt::ReferencePointPacket::setDescription()</a>, and <a class="el" href="StreamStatePacket_8h_source.html#l00320">vrt::StreamStatePacket::setMessage()</a>.</p>

</div>
</div>
<a class="anchor" id="ae3d20200405607229adb9ff895d87666"></a><!-- doxytag: member="vrt::VRTMath::longBitsToDouble" ref="ae3d20200405607229adb9ff895d87666" args="(int64_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vrt::VRTMath::longBitsToDouble </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts the 64-bits corresponding to an IEEE-764 double, as contained in a 64-bit integer, into an IEEE-764 double. </p>
<p><br/>
 <br/>
 The name of this function is patterned after the Java function (as this provides some consistency between the Java and C++ version), but the implementation is entirely different. </p>

<p>References <a class="el" href="VRTMath_8h_source.html#l00350">longBitsToDouble()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00350">longBitsToDouble()</a>.</p>

</div>
</div>
<a class="anchor" id="a82e52db07eb2793bc50d6c426580c9ac"></a><!-- doxytag: member="vrt::VRTMath::packAscii" ref="a82e52db07eb2793bc50d6c426580c9ac" args="(vector&lt; char &gt; &amp;buf, int32_t off, const wstring &amp;val, int32_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::packAscii </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wstring &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a ASCII string into a buffer. </p>
<p>Any non-ASCII characters or ASCII control characters will be replaces with '?' upon insertion. If <code>val</code> is longer than <code>len</code> it will be truncated without explicit warning. If <code>val</code> is shorter than <code>len</code> it will be padded out with ASCII NUL characters to fill the length. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Byte array of data [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td><a class="el" href="classvrt_1_1Value.html" title="A generic value used in conjunction with HasFields.">Value</a> to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Length of the string in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The actual length required to hold the entire string. (This is for compatibility with <code>packUTF8(..)</code>, but in practice just returns <code>val.length()</code>.) </dd></dl>

<p>References <a class="el" href="namespacevrt_1_1VRTMath.html#a3c7d32193d1beb4a21fcbee46e7878b4">packAscii()</a>.</p>

</div>
</div>
<a class="anchor" id="a0d0682ced2552f28417c3bcb7d90cc6b"></a><!-- doxytag: member="vrt::VRTMath::packAscii" ref="a0d0682ced2552f28417c3bcb7d90cc6b" args="(void *ptr, int32_t off, const wstring &amp;val, int32_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::packAscii </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wstring &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a ASCII string into a buffer. </p>
<p>Any non-ASCII characters or ASCII control characters will be replaces with '?' upon insertion. If <code>val</code> is longer than <code>len</code> it will be truncated without explicit warning. If <code>val</code> is shorter than <code>len</code> it will be padded out with ASCII NUL characters to fill the length. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td><a class="el" href="classvrt_1_1Value.html" title="A generic value used in conjunction with HasFields.">Value</a> to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Length of the string in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The actual length required to hold the entire string. (This is for compatibility with <code>packUTF8(..)</code>, but in practice just returns <code>val.length()</code>.) </dd></dl>

</div>
</div>
<a class="anchor" id="acd50c652565b2a911041026f12929f26"></a><!-- doxytag: member="vrt::VRTMath::packAscii" ref="acd50c652565b2a911041026f12929f26" args="(vector&lt; char &gt; &amp;buf, int32_t off, const string &amp;val, int32_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::packAscii </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a ASCII string into a buffer. </p>
<p>Any non-ASCII characters or ASCII control characters will be replaces with '?' upon insertion. If <code>val</code> is longer than <code>len</code> it will be truncated without explicit warning. If <code>val</code> is shorter than <code>len</code> it will be padded out with ASCII NUL characters to fill the length. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Byte array of data [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td><a class="el" href="classvrt_1_1Value.html" title="A generic value used in conjunction with HasFields.">Value</a> to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Length of the string in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The actual length required to hold the entire string. (This is for compatibility with <code>packUTF8(..)</code>, but in practice just returns <code>val.length()</code>.) </dd></dl>

<p>References <a class="el" href="namespacevrt_1_1VRTMath.html#a3c7d32193d1beb4a21fcbee46e7878b4">packAscii()</a>.</p>

</div>
</div>
<a class="anchor" id="a3c7d32193d1beb4a21fcbee46e7878b4"></a><!-- doxytag: member="vrt::VRTMath::packAscii" ref="a3c7d32193d1beb4a21fcbee46e7878b4" args="(void *ptr, int32_t off, const string &amp;val, int32_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::packAscii </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a ASCII string into a buffer. </p>
<p>Any non-ASCII characters or ASCII control characters will be replaces with '?' upon insertion. If <code>val</code> is longer than <code>len</code> it will be truncated without explicit warning. If <code>val</code> is shorter than <code>len</code> it will be padded out with ASCII NUL characters to fill the length. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td><a class="el" href="classvrt_1_1Value.html" title="A generic value used in conjunction with HasFields.">Value</a> to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Length of the string in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The actual length required to hold the entire string. (This is for compatibility with <code>packUTF8(..)</code>, but in practice just returns <code>val.length()</code>.) </dd></dl>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l01513">packAscii()</a>, and <a class="el" href="BasicVRTPacket_8h_source.html#l00982">vrt::BasicVRTPacket::packPayloadAscii()</a>.</p>

</div>
</div>
<a class="anchor" id="a4dca5bed2dbaee957d13213ef134dd2f"></a><!-- doxytag: member="vrt::VRTMath::packBits32" ref="a4dca5bed2dbaee957d13213ef134dd2f" args="(void *ptr, int32_t bitOffset, int32_t bitCount, int32_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packBits32 </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bitOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bitCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Writes bits to a buffer without safety checks. </p>

</div>
</div>
<a class="anchor" id="a1fae166f2656fa3904d9102be0ed9603"></a><!-- doxytag: member="vrt::VRTMath::packBits64" ref="a1fae166f2656fa3904d9102be0ed9603" args="(void *ptr, int32_t bitOffset, int32_t bitCount, int64_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packBits64 </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bitOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bitCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Writes bits to a buffer without safety checks. </p>

</div>
</div>
<a class="anchor" id="acf648738bb08d255cd043c9adb669e00"></a><!-- doxytag: member="vrt::VRTMath::packBoolean" ref="acf648738bb08d255cd043c9adb669e00" args="(vector&lt; char &gt; &amp;buf, int32_t off, bool val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packBoolean </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a boolean into a buffer. </p>
<p>The boolean is stored as: </p>
<pre>
    true  = +1
    false = -1
  </pre> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01470">packBoolean()</a>.</p>

</div>
</div>
<a class="anchor" id="abdcc61a2586d1b270225dd6888ee5c71"></a><!-- doxytag: member="vrt::VRTMath::packBoolean" ref="abdcc61a2586d1b270225dd6888ee5c71" args="(void *ptr, int32_t off, bool val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packBoolean </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a boolean into a buffer. </p>
<p>The boolean is stored as: </p>
<pre>
    true  = +1
    false = -1
  </pre> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01470">packBoolean()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l01470">packBoolean()</a>, and <a class="el" href="BasicVRTPacket_8h_source.html#l00965">vrt::BasicVRTPacket::packPayloadBoolean()</a>.</p>

</div>
</div>
<a class="anchor" id="a741764ec207f434ad71a357fbd21cd46"></a><!-- doxytag: member="vrt::VRTMath::packBoolNull" ref="a741764ec207f434ad71a357fbd21cd46" args="(vector&lt; char &gt; &amp;buf, int32_t off, boolNull val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packBoolNull </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolNull&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a boolean into a buffer. </p>
<p>The boolean is stored as: </p>
<pre>
    null  =  0
    true  = +1
    false = -1
  </pre> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01442">packBoolNull()</a>.</p>

</div>
</div>
<a class="anchor" id="ac760c83504c33af645ff166664a85f12"></a><!-- doxytag: member="vrt::VRTMath::packBoolNull" ref="ac760c83504c33af645ff166664a85f12" args="(void *ptr, int32_t off, boolNull val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packBoolNull </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolNull&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a boolean into a buffer. </p>
<p>The boolean is stored as: </p>
<pre>
    null  =  0
    true  = +1
    false = -1
  </pre> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01442">packBoolNull()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l01442">packBoolNull()</a>, and <a class="el" href="BasicVRTPacket_8h_source.html#l00963">vrt::BasicVRTPacket::packPayloadBoolNull()</a>.</p>

</div>
</div>
<a class="anchor" id="a72a924f8922c5eee9590a7a01d9947ec"></a><!-- doxytag: member="vrt::VRTMath::packByte" ref="a72a924f8922c5eee9590a7a01d9947ec" args="(vector&lt; char &gt; &amp;buf, int32_t off, char val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packByte </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack byte data into byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01163">packByte()</a>.</p>

</div>
</div>
<a class="anchor" id="a709891d5b906fd8394361171282db02b"></a><!-- doxytag: member="vrt::VRTMath::packByte" ref="a709891d5b906fd8394361171282db02b" args="(void *ptr, int32_t off, char val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packByte </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack byte data into byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l01173">packByte()</a>, and <a class="el" href="BasicVRTPacket_8h_source.html#l00951">vrt::BasicVRTPacket::packPayloadByte()</a>.</p>

</div>
</div>
<a class="anchor" id="ad31bc1800a6d1066119eb7f9c2161567"></a><!-- doxytag: member="vrt::VRTMath::packBytes" ref="ad31bc1800a6d1066119eb7f9c2161567" args="(vector&lt; char &gt; &amp;buf, int32_t off, const void *buffer, int32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packBytes </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack an array of bytes into the buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>The buffer to pack into the array [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length to pack. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If <code>off</code>, <code>boff</code> or <code>len</code> are invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01636">packBytes()</a>.</p>

</div>
</div>
<a class="anchor" id="abff703bbf1162e53453c3dc17aecd02f"></a><!-- doxytag: member="vrt::VRTMath::packBytes" ref="abff703bbf1162e53453c3dc17aecd02f" args="(vector&lt; char &gt; &amp;buf, int32_t off, const vector&lt; char &gt; &amp;buffer, int32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packBytes </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack an array of bytes into the buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>The buffer to pack into the array [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length to pack. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If <code>buffer.length != len</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01636">packBytes()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l01636">packBytes()</a>, and <a class="el" href="BasicVRTPacket_8h_source.html#l00971">vrt::BasicVRTPacket::packPayloadBytes()</a>.</p>

</div>
</div>
<a class="anchor" id="a3a8d6998c4d54e367205f9c743870a0d"></a><!-- doxytag: member="vrt::VRTMath::packDouble" ref="a3a8d6998c4d54e367205f9c743870a0d" args="(vector&lt; char &gt; &amp;buf, int32_t off, double val, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packDouble </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack double data into byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01408">packDouble()</a>.</p>

</div>
</div>
<a class="anchor" id="ac65bfb3c4ec48f778bc0354728d8e90e"></a><!-- doxytag: member="vrt::VRTMath::packDouble" ref="ac65bfb3c4ec48f778bc0354728d8e90e" args="(void *ptr, int32_t off, double val, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packDouble </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack double data into byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01408">packDouble()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l01408">packDouble()</a>, and <a class="el" href="BasicVRTPacket_8h_source.html#l00961">vrt::BasicVRTPacket::packPayloadDouble()</a>.</p>

</div>
</div>
<a class="anchor" id="a8211a9b689ec93d3faacb86a0f224257"></a><!-- doxytag: member="vrt::VRTMath::packFloat" ref="a8211a9b689ec93d3faacb86a0f224257" args="(vector&lt; char &gt; &amp;buf, int32_t off, float val, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packFloat </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack float data into byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01381">packFloat()</a>.</p>

</div>
</div>
<a class="anchor" id="a788ce2377377ec076ed0f360b2808dc3"></a><!-- doxytag: member="vrt::VRTMath::packFloat" ref="a788ce2377377ec076ed0f360b2808dc3" args="(void *ptr, int32_t off, float val, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packFloat </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack float data into byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01381">packFloat()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l01381">packFloat()</a>, and <a class="el" href="BasicVRTPacket_8h_source.html#l00959">vrt::BasicVRTPacket::packPayloadFloat()</a>.</p>

</div>
</div>
<a class="anchor" id="aa6f69ac01e3321c53acfe665bc438f7a"></a><!-- doxytag: member="vrt::VRTMath::packInetAddr" ref="aa6f69ac01e3321c53acfe665bc438f7a" args="(vector&lt; char &gt; &amp;buf, int32_t off, const InetAddress &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packInetAddr </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InetAddress &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a 16-byte IPv6 address into a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="InetAddress_8h_source.html#l00094">vrt::InetAddress::toIPv6()</a>.</p>

</div>
</div>
<a class="anchor" id="ac0fff2b83255a420f25e0784bd366f9f"></a><!-- doxytag: member="vrt::VRTMath::packInetAddr" ref="ac0fff2b83255a420f25e0784bd366f9f" args="(void *ptr, int32_t off, const InetAddress &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packInetAddr </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InetAddress &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a 16-byte IPv6 address into a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="InetAddress_8h_source.html#l00094">vrt::InetAddress::toIPv6()</a>.</p>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l00977">vrt::BasicVRTPacket::packPayloadInetAddr()</a>.</p>

</div>
</div>
<a class="anchor" id="a4c60a3faa0a40b6a98896df4f5120fe3"></a><!-- doxytag: member="vrt::VRTMath::packInt" ref="a4c60a3faa0a40b6a98896df4f5120fe3" args="(vector&lt; char &gt; &amp;buf, int32_t off, int32_t val, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packInt </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack int data into byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01235">packInt()</a>.</p>

</div>
</div>
<a class="anchor" id="a21e984c1aa15564f2ad335c50797346a"></a><!-- doxytag: member="vrt::VRTMath::packInt" ref="a21e984c1aa15564f2ad335c50797346a" args="(void *ptr, int32_t off, int32_t val, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packInt </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack int data into byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01235">packInt()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l01235">packInt()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00955">vrt::BasicVRTPacket::packPayloadInt()</a>, and <a class="el" href="TimeStamp_8h_source.html#l01146">packTimeStamp()</a>.</p>

</div>
</div>
<a class="anchor" id="ae6ff0f0aaa4aab02874a7bcbba74c297"></a><!-- doxytag: member="vrt::VRTMath::packInt24" ref="ae6ff0f0aaa4aab02874a7bcbba74c297" args="(vector&lt; char &gt; &amp;buf, int32_t off, int32_t val, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packInt24 </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Pack a 24-bit integer value as an int data from a byte buffer. </p>
<p>Any high-order bits (i.e. bits 24 to 31) are ignored. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01205">packInt24()</a>.</p>

</div>
</div>
<a class="anchor" id="a504a335987dcd521f40f938f2834a04f"></a><!-- doxytag: member="vrt::VRTMath::packInt24" ref="a504a335987dcd521f40f938f2834a04f" args="(void *ptr, int32_t off, int32_t val, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packInt24 </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Pack a 24-bit integer value as an int data from a byte buffer. </p>
<p>Any high-order bits (i.e. bits 24 to 31) are ignored. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01205">packInt24()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l01205">packInt24()</a>, and <a class="el" href="VRTMath_8h_source.html#l01318">packUInt24()</a>.</p>

</div>
</div>
<a class="anchor" id="a685141bef563f93ad0ee7592b9199ffb"></a><!-- doxytag: member="vrt::VRTMath::packLong" ref="a685141bef563f93ad0ee7592b9199ffb" args="(vector&lt; char &gt; &amp;buf, int32_t off, int64_t val, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packLong </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack long data into byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01256">packLong()</a>.</p>

</div>
</div>
<a class="anchor" id="a718994d7c18bb58c72aa3914783ff10d"></a><!-- doxytag: member="vrt::VRTMath::packLong" ref="a718994d7c18bb58c72aa3914783ff10d" args="(void *ptr, int32_t off, int64_t val, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packLong </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack long data into byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01256">packLong()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l01256">packLong()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00957">vrt::BasicVRTPacket::packPayloadLong()</a>, and <a class="el" href="TimeStamp_8h_source.html#l01146">packTimeStamp()</a>.</p>

</div>
</div>
<a class="anchor" id="a2caf91200db7580abace6c9c51c43374"></a><!-- doxytag: member="vrt::VRTMath::packMetadata" ref="a2caf91200db7580abace6c9c51c43374" args="(vector&lt; char &gt; &amp;buf, int32_t off, const MetadataBlock &amp;val, int32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::packMetadata </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetadataBlock &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a metadata block into a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The metadata block to pack </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the block </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l00969">vrt::BasicVRTPacket::packPayloadMetadata()</a>.</p>

</div>
</div>
<a class="anchor" id="aaee853c53dbbfaab48ebfeff8d412b70"></a><!-- doxytag: member="vrt::VRTMath::packRecord" ref="aaee853c53dbbfaab48ebfeff8d412b70" args="(vector&lt; char &gt; &amp;buf, int32_t off, const Record &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packRecord </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Record &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a record into a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The record to pack </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l00967">vrt::BasicVRTPacket::packPayloadRecord()</a>.</p>

</div>
</div>
<a class="anchor" id="a634798fab7866c4a877832b9368a471c"></a><!-- doxytag: member="vrt::VRTMath::packShort" ref="a634798fab7866c4a877832b9368a471c" args="(vector&lt; char &gt; &amp;buf, int32_t off, int16_t val, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packShort </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack short data into byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01183">packShort()</a>.</p>

</div>
</div>
<a class="anchor" id="a95e2cba136b7006243b8cfd95f4c6d20"></a><!-- doxytag: member="vrt::VRTMath::packShort" ref="a95e2cba136b7006243b8cfd95f4c6d20" args="(void *ptr, int32_t off, int16_t val, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packShort </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack short data into byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01183">packShort()</a>.</p>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l00953">vrt::BasicVRTPacket::packPayloadShort()</a>, and <a class="el" href="VRTMath_8h_source.html#l01183">packShort()</a>.</p>

</div>
</div>
<a class="anchor" id="a2308a1e7f88edabafa9738f1e0302fae"></a><!-- doxytag: member="vrt::VRTMath::packTimeStamp" ref="a2308a1e7f88edabafa9738f1e0302fae" args="(vector&lt; char &gt; &amp;buf, int32_t off, const TimeStamp &amp;val, IntegerMode epoch, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packTimeStamp </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TimeStamp &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerMode&nbsp;</td>
          <td class="paramname"> <em>epoch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a VITA 49.0 time stamp into a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>epoch</em>&nbsp;</td><td>The epoch to use (must be either <code>IntegerMode_UTC</code> or <code>IntegerMode_GPS</code>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="TimeStamp_8h_source.html#l01146">packTimeStamp()</a>.</p>

</div>
</div>
<a class="anchor" id="aef7be55d6b817aaa8a8ec8d7aaf8ffbc"></a><!-- doxytag: member="vrt::VRTMath::packTimeStamp" ref="aef7be55d6b817aaa8a8ec8d7aaf8ffbc" args="(void *ptr, int32_t off, const TimeStamp &amp;val, IntegerMode epoch, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packTimeStamp </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TimeStamp &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerMode&nbsp;</td>
          <td class="paramname"> <em>epoch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a VITA 49.0 time stamp into a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>epoch</em>&nbsp;</td><td>The epoch to use (must be either <code>IntegerMode_UTC</code> or <code>IntegerMode_GPS</code>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classvrt_1_1TimeStamp.html#a765f699c0bd679c5e2a4efb3e1d87196">vrt::TimeStamp::getPicoSeconds()</a>, <a class="el" href="classvrt_1_1TimeStamp.html#aff0196f9f6c370bc74776a11f9da68b4">vrt::TimeStamp::getSecondsGPS()</a>, <a class="el" href="classvrt_1_1TimeStamp.html#a874cc97fe5e98ef0548132f421605fb6">vrt::TimeStamp::getSecondsUTC()</a>, <a class="el" href="VRTMath_8h_source.html#l01235">packInt()</a>, and <a class="el" href="VRTMath_8h_source.html#l01256">packLong()</a>.</p>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l00975">vrt::BasicVRTPacket::packPayloadTimeStamp()</a>, and <a class="el" href="TimeStamp_8h_source.html#l01169">packTimeStamp()</a>.</p>

</div>
</div>
<a class="anchor" id="a59a70ac0f0dde361264a8134319d6c1f"></a><!-- doxytag: member="vrt::VRTMath::packUByte" ref="a59a70ac0f0dde361264a8134319d6c1f" args="(vector&lt; char &gt; &amp;buf, int32_t off, unsigned char val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packUByte </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack unsigned byte data into byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01276">packUByte()</a>.</p>

</div>
</div>
<a class="anchor" id="a83e4319491815e18d67083f7fe7f82a1"></a><!-- doxytag: member="vrt::VRTMath::packUByte" ref="a83e4319491815e18d67083f7fe7f82a1" args="(void *ptr, int32_t off, unsigned char val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packUByte </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack unsigned byte data into byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01276">packUByte()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l01276">packUByte()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d93f8143d901d88ce09bc532677edb9"></a><!-- doxytag: member="vrt::VRTMath::packUInt" ref="a4d93f8143d901d88ce09bc532677edb9" args="(vector&lt; char &gt; &amp;buf, int32_t off, uint32_t val, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packUInt </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack unsigned int data into byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01339">packUInt()</a>.</p>

</div>
</div>
<a class="anchor" id="aed3d8fae40e2a74a0f83c1b473ada722"></a><!-- doxytag: member="vrt::VRTMath::packUInt" ref="aed3d8fae40e2a74a0f83c1b473ada722" args="(void *ptr, int32_t off, uint32_t val, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packUInt </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack unsigned int data into byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01339">packUInt()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l01339">packUInt()</a>.</p>

</div>
</div>
<a class="anchor" id="a0d9e3197b19aaca2aa1c23677e7f27c1"></a><!-- doxytag: member="vrt::VRTMath::packUInt24" ref="a0d9e3197b19aaca2aa1c23677e7f27c1" args="(vector&lt; char &gt; &amp;buf, int32_t off, int32_t val, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packUInt24 </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Pack a 24-bit integer value as an int data from a byte buffer. </p>
<p>Any high-order bits (i.e. bits 24 to 31) are ignored. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01318">packUInt24()</a>.</p>

</div>
</div>
<a class="anchor" id="a21f615b284f6de71c91b60c25425c9c6"></a><!-- doxytag: member="vrt::VRTMath::packUInt24" ref="a21f615b284f6de71c91b60c25425c9c6" args="(void *ptr, int32_t off, int32_t val, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packUInt24 </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Pack a 24-bit integer value as an int data from a byte buffer. </p>
<p>Any high-order bits (i.e. bits 24 to 31) are ignored. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01205">packInt24()</a>, and <a class="el" href="VRTMath_8h_source.html#l01318">packUInt24()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l01318">packUInt24()</a>.</p>

</div>
</div>
<a class="anchor" id="a8d22289b0510651bfb41d3b865d6ab22"></a><!-- doxytag: member="vrt::VRTMath::packULong" ref="a8d22289b0510651bfb41d3b865d6ab22" args="(vector&lt; char &gt; &amp;buf, int32_t off, uint64_t val, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packULong </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack unsigned long data into byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01360">packULong()</a>.</p>

</div>
</div>
<a class="anchor" id="aad974fe764dd16d6bf08f63a6fb172b5"></a><!-- doxytag: member="vrt::VRTMath::packULong" ref="aad974fe764dd16d6bf08f63a6fb172b5" args="(void *ptr, int32_t off, uint64_t val, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packULong </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack unsigned long data into byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01360">packULong()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l01360">packULong()</a>.</p>

</div>
</div>
<a class="anchor" id="a0abab924b972a5c2585b5a386091a947"></a><!-- doxytag: member="vrt::VRTMath::packUShort" ref="a0abab924b972a5c2585b5a386091a947" args="(vector&lt; char &gt; &amp;buf, int32_t off, uint16_t val, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packUShort </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack unsigned short data into byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01296">packUShort()</a>.</p>

</div>
</div>
<a class="anchor" id="a344ad933388deeb8a3f7e1ee95dd397e"></a><!-- doxytag: member="vrt::VRTMath::packUShort" ref="a344ad933388deeb8a3f7e1ee95dd397e" args="(void *ptr, int32_t off, uint16_t val, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packUShort </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack unsigned short data into byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into output array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01296">packUShort()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l01296">packUShort()</a>.</p>

</div>
</div>
<a class="anchor" id="a0f370d9020f895f4b82eb1250639a080"></a><!-- doxytag: member="vrt::VRTMath::packUTF8" ref="a0f370d9020f895f4b82eb1250639a080" args="(vector&lt; char &gt; &amp;buf, int32_t off, const string &amp;val, int32_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::packUTF8 </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a UTF-8 string into a buffer. </p>
<p>If <code>val</code> is longer than <code>len</code> it will be truncated without explicit warning. If <code>val</code> is shorter than <code>len</code> it will be padded out with ASCII NUL characters to fill the length. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Byte array of data [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td><a class="el" href="classvrt_1_1Value.html" title="A generic value used in conjunction with HasFields.">Value</a> to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Length of the string in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The length required to hold the entire UTF-8 string. If this is less than or equal to <code>length</code>, it means that the entire string has been stored in the buffer. If this is greater than <code>length</code>, it means that only part of the string has been stored in the buffer and that a buffer with the specified size would be required to hold the entire string. Note that since the individual characters UTF-8 can take from 1 to 4 bytes when stored, this can be used to indicate the required size for a re-sized buffer. </dd></dl>

<p>References <a class="el" href="namespacevrt_1_1VRTMath.html#a6d45e3bdc1dd1bc8153a07bc072f8c5a">packUTF8()</a>.</p>

</div>
</div>
<a class="anchor" id="a7173b0890a7478776514b928864a02f0"></a><!-- doxytag: member="vrt::VRTMath::packUTF8" ref="a7173b0890a7478776514b928864a02f0" args="(void *ptr, int32_t off, const string &amp;val, int32_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::packUTF8 </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a UTF-8 string into a buffer. </p>
<p>If <code>val</code> is longer than <code>len</code> it will be truncated without explicit warning. If <code>val</code> is shorter than <code>len</code> it will be padded out with ASCII NUL characters to fill the length. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td><a class="el" href="classvrt_1_1Value.html" title="A generic value used in conjunction with HasFields.">Value</a> to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Length of the string in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The length required to hold the entire UTF-8 string. If this is less than or equal to <code>length</code>, it means that the entire string has been stored in the buffer. If this is greater than <code>length</code>, it means that only part of the string has been stored in the buffer and that a buffer with the specified size would be required to hold the entire string. Note that since the individual characters UTF-8 can take from 1 to 4 bytes when stored, this can be used to indicate the required size for a re-sized buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a07851bb74a8a691dbe598671e573f131"></a><!-- doxytag: member="vrt::VRTMath::packUTF8" ref="a07851bb74a8a691dbe598671e573f131" args="(vector&lt; char &gt; &amp;buf, int32_t off, const wstring &amp;val, int32_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::packUTF8 </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wstring &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a UTF-8 string into a buffer. </p>
<p>If <code>val</code> is longer than <code>len</code> it will be truncated without explicit warning. If <code>val</code> is shorter than <code>len</code> it will be padded out with ASCII NUL characters to fill the length. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Byte array of data [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td><a class="el" href="classvrt_1_1Value.html" title="A generic value used in conjunction with HasFields.">Value</a> to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Length of the string in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The length required to hold the entire UTF-8 string. If this is less than or equal to <code>length</code>, it means that the entire string has been stored in the buffer. If this is greater than <code>length</code>, it means that only part of the string has been stored in the buffer and that a buffer with the specified size would be required to hold the entire string. Note that since the individual characters UTF-8 can take from 1 to 4 bytes when stored, this can be used to indicate the required size for a re-sized buffer. </dd></dl>

<p>References <a class="el" href="namespacevrt_1_1VRTMath.html#a6d45e3bdc1dd1bc8153a07bc072f8c5a">packUTF8()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d45e3bdc1dd1bc8153a07bc072f8c5a"></a><!-- doxytag: member="vrt::VRTMath::packUTF8" ref="a6d45e3bdc1dd1bc8153a07bc072f8c5a" args="(void *ptr, int32_t off, const wstring &amp;val, int32_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::packUTF8 </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wstring &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a UTF-8 string into a buffer. </p>
<p>If <code>val</code> is longer than <code>len</code> it will be truncated without explicit warning. If <code>val</code> is shorter than <code>len</code> it will be padded out with ASCII NUL characters to fill the length. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td><a class="el" href="classvrt_1_1Value.html" title="A generic value used in conjunction with HasFields.">Value</a> to pack [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Length of the string in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The length required to hold the entire UTF-8 string. If this is less than or equal to <code>length</code>, it means that the entire string has been stored in the buffer. If this is greater than <code>length</code>, it means that only part of the string has been stored in the buffer and that a buffer with the specified size would be required to hold the entire string. Note that since the individual characters UTF-8 can take from 1 to 4 bytes when stored, this can be used to indicate the required size for a re-sized buffer. </dd></dl>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l01617">lengthUTF8()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l00995">vrt::BasicVRTPacket::packPayloadUTF8()</a>, and <a class="el" href="VRTMath_8h_source.html#l01575">packUTF8()</a>.</p>

</div>
</div>
<a class="anchor" id="a422ee13d4da795e155762db2904be954"></a><!-- doxytag: member="vrt::VRTMath::packUUID" ref="a422ee13d4da795e155762db2904be954" args="(vector&lt; char &gt; &amp;buf, int32_t off, const UUID &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packUUID </td>
          <td>(</td>
          <td class="paramtype">vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UUID &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a 16-byte <a class="el" href="classvrt_1_1UUID.html" title="A 128-bit universally unique identifier (UUID).">UUID</a> into a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="UUID_8h_source.html#l00104">vrt::UUID::getValue()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e026ce2a877b2bc66ecaec8662d3261"></a><!-- doxytag: member="vrt::VRTMath::packUUID" ref="a5e026ce2a877b2bc66ecaec8662d3261" args="(void *ptr, int32_t off, const UUID &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::packUUID </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UUID &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a 16-byte <a class="el" href="classvrt_1_1UUID.html" title="A 128-bit universally unique identifier (UUID).">UUID</a> into a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to packed byte array [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>value to pack [INPUT] </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="UUID_8h_source.html#l00104">vrt::UUID::getValue()</a>.</p>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l00979">vrt::BasicVRTPacket::packPayloadUUID()</a>.</p>

</div>
</div>
<a class="anchor" id="a2052c6872f58b38323ca705d4d1a2c67"></a><!-- doxytag: member="vrt::VRTMath::safecastT1ToT2" ref="a2052c6872f58b38323ca705d4d1a2c67" args="(T1 val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T2 vrt::VRTMath::safecastT1ToT2 </td>
          <td>(</td>
          <td class="paramtype">T1&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts an from one type to another type of same size using memcpy. </p>
<p>templateparam T1 From-type templateparam T2 To-type </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td><a class="el" href="classvrt_1_1Value.html" title="A generic value used in conjunction with HasFields.">Value</a> to convert from (should have type T1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classvrt_1_1Value.html" title="A generic value used in conjunction with HasFields.">Value</a> as type T2 </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00315">safecastT1ToT2()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00315">safecastT1ToT2()</a>.</p>

</div>
</div>
<a class="anchor" id="a9e129192d5b590ed56aa125c1e6d413e"></a><!-- doxytag: member="vrt::VRTMath::toDouble16" ref="a9e129192d5b590ed56aa125c1e6d413e" args="(int32_t radixPoint, int16_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vrt::VRTMath::toDouble16 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a 16-bit fixed point number to a float. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..15). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>The bits representing the fixed-point number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The floating-point value of the fixed point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00644">toDouble16()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00644">toDouble16()</a>, and <a class="el" href="VRTMath_8h_source.html#l00667">toFloat16()</a>.</p>

</div>
</div>
<a class="anchor" id="ae53780bfdea74c0b88b3793211d6c73d"></a><!-- doxytag: member="vrt::VRTMath::toDouble32" ref="ae53780bfdea74c0b88b3793211d6c73d" args="(int32_t radixPoint, int32_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vrt::VRTMath::toDouble32 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a 32-bit fixed point number to a float. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..31). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>The bits representing the fixed-point number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The floating-point value of the fixed point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00557">toDouble32()</a>.</p>

<p>Referenced by <a class="el" href="IndicatorFields_8h_source.html#l00695">vrt::Geolocation::getAltitude()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00868">vrt::Ephemeris::getAttitudeAlpha()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00876">vrt::Ephemeris::getAttitudeBeta()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00884">vrt::Ephemeris::getAttitudePhi()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00711">vrt::Geolocation::getHeadingAngle()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00679">vrt::Geolocation::getLatitude()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00687">vrt::Geolocation::getLongitude()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00727">vrt::Geolocation::getMagneticVariation()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00820">vrt::Ephemeris::getPositionX()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00828">vrt::Ephemeris::getPositionY()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00836">vrt::Ephemeris::getPositionZ()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03299">vrt::IndicatorFieldProvider::getRange()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00703">vrt::Geolocation::getSpeedOverGround()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00719">vrt::Geolocation::getTrackAngle()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00916">vrt::Ephemeris::getVelocityX()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00924">vrt::Ephemeris::getVelocityY()</a>, <a class="el" href="IndicatorFields_8h_source.html#l00932">vrt::Ephemeris::getVelocityZ()</a>, <a class="el" href="IndicatorFields_8h_source.html#l01456">vrt::SpectrumField::getWindowTimeDeltaFloat()</a>, <a class="el" href="VRTMath_8h_source.html#l00557">toDouble32()</a>, and <a class="el" href="VRTMath_8h_source.html#l00580">toFloat32()</a>.</p>

</div>
</div>
<a class="anchor" id="a96d510640398f31e066d204389c215e1"></a><!-- doxytag: member="vrt::VRTMath::toDouble64" ref="a96d510640398f31e066d204389c215e1" args="(int32_t radixPoint, int64_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vrt::VRTMath::toDouble64 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a 64-bit fixed point number to a float. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..63). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>The bits representing the fixed-point number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The floating-point value of the fixed point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00471">toDouble64()</a>.</p>

<p>Referenced by <a class="el" href="IndicatorFields_8h_source.html#l02866">vrt::IndicatorFieldProvider::getAuxBandwidth()</a>, <a class="el" href="IndicatorFields_8h_source.html#l02996">vrt::IndicatorFieldProvider::getAuxFrequency()</a>, <a class="el" href="IndicatorFields_8h_source.html#l02007">vrt::IndicatorFieldProvider::getBandOffsetIF()</a>, <a class="el" href="IndicatorFields_8h_source.html#l01971">vrt::IndicatorFieldProvider::getBandwidth()</a>, <a class="el" href="IndicatorFields_8h_source.html#l01980">vrt::IndicatorFieldProvider::getFrequencyIF()</a>, <a class="el" href="IndicatorFields_8h_source.html#l01998">vrt::IndicatorFieldProvider::getFrequencyOffsetRF()</a>, <a class="el" href="IndicatorFields_8h_source.html#l01989">vrt::IndicatorFieldProvider::getFrequencyRF()</a>, <a class="el" href="IndicatorFields_8h_source.html#l01410">vrt::SpectrumField::getResolution()</a>, <a class="el" href="IndicatorFields_8h_source.html#l02047">vrt::IndicatorFieldProvider::getSampleRate()</a>, <a class="el" href="IndicatorFields_8h_source.html#l01422">vrt::SpectrumField::getSpan()</a>, <a class="el" href="VRTMath_8h_source.html#l00471">toDouble64()</a>, and <a class="el" href="VRTMath_8h_source.html#l00494">toFloat64()</a>.</p>

</div>
</div>
<a class="anchor" id="a0dd42dc696edf245b7828d93868768ac"></a><!-- doxytag: member="vrt::VRTMath::toFloat16" ref="a0dd42dc696edf245b7828d93868768ac" args="(int32_t radixPoint, int16_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float vrt::VRTMath::toFloat16 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a 16-bit fixed point number to a float. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..15). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>The bits representing the fixed-point number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The floating-point value of the fixed point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00644">toDouble16()</a>, and <a class="el" href="VRTMath_8h_source.html#l00667">toFloat16()</a>.</p>

<p>Referenced by <a class="el" href="IndicatorFields_8h_source.html#l03494">vrt::IndicatorFieldProvider::get3DPointingVectorAzimuth()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03482">vrt::IndicatorFieldProvider::get3DPointingVectorElevation()</a>, <a class="el" href="IndicatorFields_8h_source.html#l04687">vrt::IndicatorFieldProvider::getAirTemperature()</a>, <a class="el" href="IndicatorFields_8h_source.html#l02892">vrt::IndicatorFieldProvider::getAuxGain1()</a>, <a class="el" href="IndicatorFields_8h_source.html#l02908">vrt::IndicatorFieldProvider::getAuxGain2()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03251">vrt::IndicatorFieldProvider::getBitErrorRate()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03239">vrt::IndicatorFieldProvider::getEbN0()</a>, <a class="el" href="IndicatorFields_8h_source.html#l02027">vrt::IndicatorFieldProvider::getGain1()</a>, <a class="el" href="IndicatorFields_8h_source.html#l02038">vrt::IndicatorFieldProvider::getGain2()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03033">vrt::IndicatorFieldProvider::getNoiseFigure()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03134">vrt::IndicatorFieldProvider::getOneDecibelCompressionPoint()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03606">vrt::IndicatorFieldProvider::getPhaseOffset()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03557">vrt::IndicatorFieldProvider::getPolarizationEllipticityAngle()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03547">vrt::IndicatorFieldProvider::getPolarizationTiltAngle()</a>, <a class="el" href="IndicatorFields_8h_source.html#l02016">vrt::IndicatorFieldProvider::getReferenceLevel()</a>, <a class="el" href="IndicatorFields_8h_source.html#l04657">vrt::IndicatorFieldProvider::getSeaGroundTemperature()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03080">vrt::IndicatorFieldProvider::getSecondOrderInputInterceptPoint()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03020">vrt::IndicatorFieldProvider::getSNR()</a>, <a class="el" href="IndicatorFields_8h_source.html#l02066">vrt::IndicatorFieldProvider::getTemperature()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03090">vrt::IndicatorFieldProvider::getThirdOrderInputInterceptPoint()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03160">vrt::IndicatorFieldProvider::getThreshold1()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03173">vrt::IndicatorFieldProvider::getThreshold2()</a>, and <a class="el" href="VRTMath_8h_source.html#l00667">toFloat16()</a>.</p>

</div>
</div>
<a class="anchor" id="a354e6d7856c069b2f5d0664c355b5df7"></a><!-- doxytag: member="vrt::VRTMath::toFloat32" ref="a354e6d7856c069b2f5d0664c355b5df7" args="(int32_t radixPoint, int32_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float vrt::VRTMath::toFloat32 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a 32-bit fixed point number to a float. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..31). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>The bits representing the fixed-point number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The floating-point value of the fixed point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00557">toDouble32()</a>, and <a class="el" href="VRTMath_8h_source.html#l00580">toFloat32()</a>.</p>

<p>Referenced by <a class="el" href="IndicatorFields_8h_source.html#l03343">vrt::IndicatorFieldProvider::getHorizontalBeamwidth()</a>, <a class="el" href="IndicatorFields_8h_source.html#l03368">vrt::IndicatorFieldProvider::getVerticalBeamwidth()</a>, and <a class="el" href="VRTMath_8h_source.html#l00580">toFloat32()</a>.</p>

</div>
</div>
<a class="anchor" id="a64830a9fffc52a78aeecb77db880b118"></a><!-- doxytag: member="vrt::VRTMath::toFloat64" ref="a64830a9fffc52a78aeecb77db880b118" args="(int32_t radixPoint, int64_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float vrt::VRTMath::toFloat64 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a 64-bit fixed point number to a float. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..63). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>The bits representing the fixed-point number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The floating-point value of the fixed point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00471">toDouble64()</a>, and <a class="el" href="VRTMath_8h_source.html#l00494">toFloat64()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00494">toFloat64()</a>.</p>

</div>
</div>
<a class="anchor" id="ab99e24105366c3d00ac441809794378c"></a><!-- doxytag: member="vrt::VRTMath::toHalf" ref="ab99e24105366c3d00ac441809794378c" args="(float val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t vrt::VRTMath::toHalf </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts an IEEE 754 single-precision floating-point value to the bits equating to an IEEE 754-2008 half-precision (storage only) value. </p>
<pre>
    References:
      [1] IEEE 754-2008.
      [2] Jeroen van der Zijp. "Fast Half Float Conversions." November
          2008 (Revised September 2010).
          <a href="ftp://ftp.fox-toolkit.org/pub/fasthalffloatconversion.pdf">ftp://ftp.fox-toolkit.org/pub/fasthalffloatconversion.pdf</a>
      [3] Free Software Foundation, Inc. "Using the GNU Compiler Collection
          (GCC)." 2013. [Section 6.12 "Half-Precision Floating Point."]
          <a href="http://gcc.gnu.org/onlinedocs/gcc/Half_002dPrecision.html">http://gcc.gnu.org/onlinedocs/gcc/Half_002dPrecision.html</a>
          [Last Accessed 5 Aug 2013]
      [4] Intel. "Intel C++ Compiler XE 13.1 User and Reference Guides."
          Document Number 323273-131US. 2013. ["Intrinsics for Converting
          Half Floats."]
          <a href="http://software.intel.com/sites/products/documentation/doclib/iss/2013/compiler/cpp-lin/GUID-23C8FF6D-3D66-4961-A3A0-E2A7DC874304.htm">http://software.intel.com/sites/products/documentation/doclib/iss/2013/compiler/cpp-lin/GUID-23C8FF6D-3D66-4961-A3A0-E2A7DC874304.htm</a>
          [Last Accessed 5 Aug 2013]
  </pre> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The single-precision value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bits representing the half-precision value. </dd></dl>

<p>References <a class="el" href="namespacevrt_1_1VRTMath.html#a8895ec7c7071157bc9935387edcc665c">_toHalfInternal()</a>, and <a class="el" href="VRTMath_8h_source.html#l00406">toHalf()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00406">toHalf()</a>.</p>

</div>
</div>
<a class="anchor" id="a4a69985e46106bc4f96d5d22d695a077"></a><!-- doxytag: member="vrt::VRTMath::toInt16" ref="a4a69985e46106bc4f96d5d22d695a077" args="(int32_t radixPoint, int16_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::toInt16 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a 16-bit fixed point number to an int. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..15). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>The bits representing the fixed-point number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The integer value of the fixed point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00685">toInt16()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00685">toInt16()</a>, and <a class="el" href="VRTMath_8h_source.html#l00709">toLong16()</a>.</p>

</div>
</div>
<a class="anchor" id="ac82e658005d695c91c3762da94a644f8"></a><!-- doxytag: member="vrt::VRTMath::toInt32" ref="ac82e658005d695c91c3762da94a644f8" args="(int32_t radixPoint, int32_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::toInt32 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a 32-bit fixed point number to an int. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..31). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>The bits representing the fixed-point number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The integer value of the fixed point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00598">toInt32()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00598">toInt32()</a>, and <a class="el" href="VRTMath_8h_source.html#l00621">toLong32()</a>.</p>

</div>
</div>
<a class="anchor" id="a9158791670e78a460da2a6d9ad623f60"></a><!-- doxytag: member="vrt::VRTMath::toInt64" ref="a9158791670e78a460da2a6d9ad623f60" args="(int32_t radixPoint, int64_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::toInt64 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a 64-bit fixed point number to an int. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..63). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>The bits representing the fixed-point number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The integer value of the fixed point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00535">toInt64()</a>, and <a class="el" href="VRTMath_8h_source.html#l00512">toLong64()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00535">toInt64()</a>.</p>

</div>
</div>
<a class="anchor" id="a1e96a28bb7b16625bb2bb06134fe68c3"></a><!-- doxytag: member="vrt::VRTMath::toLong16" ref="a1e96a28bb7b16625bb2bb06134fe68c3" args="(int32_t radixPoint, int16_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vrt::VRTMath::toLong16 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a 16-bit fixed point number to a long. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..15). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>The bits representing the fixed-point number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The integer value of the fixed point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00685">toInt16()</a>, and <a class="el" href="VRTMath_8h_source.html#l00709">toLong16()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00709">toLong16()</a>.</p>

</div>
</div>
<a class="anchor" id="a629b94640a99fcf526ea2a7297b0c427"></a><!-- doxytag: member="vrt::VRTMath::toLong32" ref="a629b94640a99fcf526ea2a7297b0c427" args="(int32_t radixPoint, int32_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vrt::VRTMath::toLong32 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a 32-bit fixed point number to a long. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..31). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>The bits representing the fixed-point number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The integer value of the fixed point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00598">toInt32()</a>, and <a class="el" href="VRTMath_8h_source.html#l00621">toLong32()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00621">toLong32()</a>.</p>

</div>
</div>
<a class="anchor" id="acb8d8b085b2034184fb8ace3589e4fb6"></a><!-- doxytag: member="vrt::VRTMath::toLong64" ref="acb8d8b085b2034184fb8ace3589e4fb6" args="(int32_t radixPoint, int64_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vrt::VRTMath::toLong64 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>radixPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a 64-bit fixed point number to a long. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radixPoint</em>&nbsp;</td><td>The radix point of the number (1..63). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>The bits representing the fixed-point number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The integer value of the fixed point number. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00512">toLong64()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00535">toInt64()</a>, and <a class="el" href="VRTMath_8h_source.html#l00512">toLong64()</a>.</p>

</div>
</div>
<a class="anchor" id="a8a2101a77f6c3a94652ca3f730470ab9"></a><!-- doxytag: member="vrt::VRTMath::toVRTFloat" ref="a8a2101a77f6c3a94652ca3f730470ab9" args="(DataItemFormat form, int32_t dSize, double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vrt::VRTMath::toVRTFloat </td>
          <td>(</td>
          <td class="paramtype">DataItemFormat&nbsp;</td>
          <td class="paramname"> <em>form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>dSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts from an IEEE-754 double-precision floating-point value to the packed bits for a VRT floating-point. </p>
<p><br/>
 <br/>
 Although VRT floating-point values can express many values in multiple ways within the binary form (e.g. 1/4 or 2/8) this function outputs the values in a "normalized form" where the output value will have a 1 in the most-significant-(non-sign-)bit of the mantissa, excepting for small values close to zero where the exponent is zero. This mirrors the behavior of IEEE-754 floating-point values, excepting that the highest bit is always present (not just for "denormal" values). <br/>
 <br/>
 Since the range of VRT floating-point numbers is [0,1) (signed) or [-1,1) (unsigned) any values below/above that range will be converted to the smallest/largest value possible in that range. Any NaN values passed in will be converted to zero. </p>
<pre>
    References:
      [1] ANSI/VITA 49.0, Appendix D
      [2] IEEE-754
  </pre> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>form</em>&nbsp;</td><td>The data item format. This must be one of the VRT floating-point formats. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dSize</em>&nbsp;</td><td>The data size in bits (2..63). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The packed bits for the VRT floating-point number. </dd></dl>

</div>
</div>
<a class="anchor" id="a148e111a58dbb1f246e2e3e406761132"></a><!-- doxytag: member="vrt::VRTMath::toVRTFloat32" ref="a148e111a58dbb1f246e2e3e406761132" args="(bool sign, int32_t eSize, int32_t dSize, double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::toVRTFloat32 </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>eSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>dSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Converts from an IEEE-754 double-precision floating-point value to the packed bits for a VRT floating-point <b>without normal safety checks</b>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sign</em>&nbsp;</td><td>Is output signed? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eSize</em>&nbsp;</td><td>The number of exponent bits (1 to 6). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dSize</em>&nbsp;</td><td>The data size in bits (2..63). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The value to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd63dd135e0208eaa7a958d875d17541"></a><!-- doxytag: member="vrt::VRTMath::toVRTFloat64" ref="abd63dd135e0208eaa7a958d875d17541" args="(bool sign, int32_t eSize, int32_t dSize, double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vrt::VRTMath::toVRTFloat64 </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>eSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>dSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Converts from an IEEE-754 double-precision floating-point value to the packed bits for a VRT floating-point <b>without normal safety checks</b>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sign</em>&nbsp;</td><td>Is output signed? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eSize</em>&nbsp;</td><td>The number of exponent bits (1 to 6). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dSize</em>&nbsp;</td><td>The data size in bits (2..63). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The value to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1887b011e4b9e34055e8aa4fac1f2edc"></a><!-- doxytag: member="vrt::VRTMath::unpackAscii" ref="a1887b011e4b9e34055e8aa4fac1f2edc" args="(const vector&lt; char &gt; &amp;buf, int32_t off, int32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vrt::VRTMath::unpackAscii </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack a ASCII string from a buffer. </p>
<p>The string is assumed to be null-terminated in the event that the string is shorter than the allowable length. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>length of the string in the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The unpacked value </dd></dl>

<p>References <a class="el" href="namespacevrt_1_1VRTMath.html#a8a61c533c98f77c4943a309bb1de9256">unpackAscii()</a>.</p>

</div>
</div>
<a class="anchor" id="a8a61c533c98f77c4943a309bb1de9256"></a><!-- doxytag: member="vrt::VRTMath::unpackAscii" ref="a8a61c533c98f77c4943a309bb1de9256" args="(const void *ptr, int32_t off, int32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vrt::VRTMath::unpackAscii </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack a ASCII string from a buffer. </p>
<p>The string is assumed to be null-terminated in the event that the string is shorter than the allowable length. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>length of the string in the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The unpacked value </dd></dl>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l01071">unpackAscii()</a>, and <a class="el" href="BasicVRTPacket_8h_source.html#l01039">vrt::BasicVRTPacket::unpackPayloadAscii()</a>.</p>

</div>
</div>
<a class="anchor" id="ab0964b5106e2564ec1fcdf5e584e4f52"></a><!-- doxytag: member="vrt::VRTMath::unpackBits32" ref="ab0964b5106e2564ec1fcdf5e584e4f52" args="(const void *ptr, int32_t bitOffset, int32_t bitCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::unpackBits32 </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bitOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bitCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Reads bits from a buffer without safety checks. </p>

</div>
</div>
<a class="anchor" id="a152343c94e81e4599939cc706465e87f"></a><!-- doxytag: member="vrt::VRTMath::unpackBits64" ref="a152343c94e81e4599939cc706465e87f" args="(const void *ptr, int32_t bitOffset, int32_t bitCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vrt::VRTMath::unpackBits64 </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bitOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>bitCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Reads bits from a buffer without safety checks. </p>

</div>
</div>
<a class="anchor" id="a51cb541743703f32dad387848d8661f2"></a><!-- doxytag: member="vrt::VRTMath::unpackBoolean" ref="a51cb541743703f32dad387848d8661f2" args="(const vector&lt; char &gt; &amp;buf, int32_t off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::VRTMath::unpackBoolean </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack a boolean from a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The unpacked value </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If <a class="el" href="namespacevrt_1_1VRTConfig.html#a4f2126f87455d5cfaca262f308331dc2">VRTConfig#getStrict()</a> is <code>true</code> and the stored value is something other than <code>-1</code>, <code>0</code> or <code>1</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacevrt_1_1VRTMath.html#a5af1b4911b0d0103fa04ee5cca5d8c92">unpackBoolean()</a>.</p>

</div>
</div>
<a class="anchor" id="a5af1b4911b0d0103fa04ee5cca5d8c92"></a><!-- doxytag: member="vrt::VRTMath::unpackBoolean" ref="a5af1b4911b0d0103fa04ee5cca5d8c92" args="(const void *ptr, int32_t off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrt::VRTMath::unpackBoolean </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack a boolean from a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The unpacked value </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If <a class="el" href="namespacevrt_1_1VRTConfig.html#a4f2126f87455d5cfaca262f308331dc2">VRTConfig#getStrict()</a> is <code>true</code> and the stored value is something other than <code>-1</code>, <code>0</code> or <code>1</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l01051">unpackBoolean()</a>, and <a class="el" href="BasicVRTPacket_8h_source.html#l01035">vrt::BasicVRTPacket::unpackPayloadBoolean()</a>.</p>

</div>
</div>
<a class="anchor" id="abf00115fe69ec308c79c3aabe16ae21e"></a><!-- doxytag: member="vrt::VRTMath::unpackBoolNull" ref="abf00115fe69ec308c79c3aabe16ae21e" args="(const vector&lt; char &gt; &amp;buf, int32_t off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolNull vrt::VRTMath::unpackBoolNull </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack a boolean from a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The unpacked value </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If <a class="el" href="namespacevrt_1_1VRTConfig.html#a4f2126f87455d5cfaca262f308331dc2">VRTConfig#getStrict()</a> is <code>true</code> and the stored value is something other than <code>-1</code>, <code>0</code> or <code>1</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacevrt_1_1VRTMath.html#ad724d3ff607ef08f13338e3f70cbdd88">unpackBoolNull()</a>.</p>

</div>
</div>
<a class="anchor" id="ad724d3ff607ef08f13338e3f70cbdd88"></a><!-- doxytag: member="vrt::VRTMath::unpackBoolNull" ref="ad724d3ff607ef08f13338e3f70cbdd88" args="(const void *ptr, int32_t off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolNull vrt::VRTMath::unpackBoolNull </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack a boolean from a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The unpacked value </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If <a class="el" href="namespacevrt_1_1VRTConfig.html#a4f2126f87455d5cfaca262f308331dc2">VRTConfig#getStrict()</a> is <code>true</code> and the stored value is something other than <code>-1</code>, <code>0</code> or <code>1</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l01031">unpackBoolNull()</a>, and <a class="el" href="BasicVRTPacket_8h_source.html#l01033">vrt::BasicVRTPacket::unpackPayloadBoolNull()</a>.</p>

</div>
</div>
<a class="anchor" id="a70b29888a678452a463ab33242bbea7e"></a><!-- doxytag: member="vrt::VRTMath::unpackByte" ref="a70b29888a678452a463ab33242bbea7e" args="(const vector&lt; char &gt; &amp;buf, int32_t off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char vrt::VRTMath::unpackByte </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack byte data from a byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>short value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00747">unpackByte()</a>.</p>

</div>
</div>
<a class="anchor" id="aeb55aaee77f65011a8d0577e06cf03b1"></a><!-- doxytag: member="vrt::VRTMath::unpackByte" ref="aeb55aaee77f65011a8d0577e06cf03b1" args="(const void *ptr, int32_t off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char vrt::VRTMath::unpackByte </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack byte data from a byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>short value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00747">unpackByte()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00747">unpackByte()</a>, and <a class="el" href="BasicVRTPacket_8h_source.html#l01021">vrt::BasicVRTPacket::unpackPayloadByte()</a>.</p>

</div>
</div>
<a class="anchor" id="a85530f02ecde8bf8f4a1384cb5b020b7"></a><!-- doxytag: member="vrt::VRTMath::unpackBytes" ref="a85530f02ecde8bf8f4a1384cb5b020b7" args="(const vector&lt; char &gt; &amp;buf, int32_t off, void *buffer, int32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* vrt::VRTMath::unpackBytes </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack an array of bytes from a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data [INPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>the output buffer [OUTPUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>length of the array in the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The output buffer. </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01133">unpackBytes()</a>.</p>

</div>
</div>
<a class="anchor" id="ae6d94aa2c4846211481fbd42955bc63c"></a><!-- doxytag: member="vrt::VRTMath::unpackBytes" ref="ae6d94aa2c4846211481fbd42955bc63c" args="(const vector&lt; char &gt; &amp;buf, int32_t off, int32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;char&gt; vrt::VRTMath::unpackBytes </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack an array of bytes from a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>length of the array in the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The unpacked value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l01133">unpackBytes()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l01133">unpackBytes()</a>, and <a class="el" href="BasicVRTPacket_8h_source.html#l01045">vrt::BasicVRTPacket::unpackPayloadBytes()</a>.</p>

</div>
</div>
<a class="anchor" id="a1c52c26d8fa09f18562f937b2c6cac90"></a><!-- doxytag: member="vrt::VRTMath::unpackDouble" ref="a1c52c26d8fa09f18562f937b2c6cac90" args="(const vector&lt; char &gt; &amp;buf, int32_t off, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vrt::VRTMath::unpackDouble </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack double data from a byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>double value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00990">unpackDouble()</a>.</p>

</div>
</div>
<a class="anchor" id="a83c714efccb03423bf8357813bc08f35"></a><!-- doxytag: member="vrt::VRTMath::unpackDouble" ref="a83c714efccb03423bf8357813bc08f35" args="(const void *ptr, int32_t off, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vrt::VRTMath::unpackDouble </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack double data from a byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>double value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00990">unpackDouble()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00990">unpackDouble()</a>, and <a class="el" href="BasicVRTPacket_8h_source.html#l01031">vrt::BasicVRTPacket::unpackPayloadDouble()</a>.</p>

</div>
</div>
<a class="anchor" id="aafefc4c9041eb868d16727f4da900faa"></a><!-- doxytag: member="vrt::VRTMath::unpackFloat" ref="aafefc4c9041eb868d16727f4da900faa" args="(const vector&lt; char &gt; &amp;buf, int32_t off, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float vrt::VRTMath::unpackFloat </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack float data from a byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>float value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00962">unpackFloat()</a>.</p>

</div>
</div>
<a class="anchor" id="a31268efa9a769ed7842c1ecc656a0e36"></a><!-- doxytag: member="vrt::VRTMath::unpackFloat" ref="a31268efa9a769ed7842c1ecc656a0e36" args="(const void *ptr, int32_t off, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float vrt::VRTMath::unpackFloat </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack float data from a byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>float value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00962">unpackFloat()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00962">unpackFloat()</a>, and <a class="el" href="BasicVRTPacket_8h_source.html#l01029">vrt::BasicVRTPacket::unpackPayloadFloat()</a>.</p>

</div>
</div>
<a class="anchor" id="aee75c62c9dc18373008c80bcfbdb7f17"></a><!-- doxytag: member="vrt::VRTMath::unpackInetAddr" ref="aee75c62c9dc18373008c80bcfbdb7f17" args="(const vector&lt; char &gt; &amp;buf, int32_t off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrt_1_1InetAddress.html">InetAddress</a> vrt::VRTMath::unpackInetAddr </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack a 16-byte IPv6 address from a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The unpacked value </dd></dl>

</div>
</div>
<a class="anchor" id="af33991d7efb59e7ed0cabb1d8b935439"></a><!-- doxytag: member="vrt::VRTMath::unpackInetAddr" ref="af33991d7efb59e7ed0cabb1d8b935439" args="(const void *ptr, int32_t off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrt_1_1InetAddress.html">InetAddress</a> vrt::VRTMath::unpackInetAddr </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack a 16-byte IPv6 address from a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The unpacked value </dd></dl>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l01051">vrt::BasicVRTPacket::unpackPayloadInetAddr()</a>.</p>

</div>
</div>
<a class="anchor" id="ab644c651177bd2c3f81085f7f1beeb07"></a><!-- doxytag: member="vrt::VRTMath::unpackInt" ref="ab644c651177bd2c3f81085f7f1beeb07" args="(const vector&lt; char &gt; &amp;buf, int32_t off, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::unpackInt </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack int data from a byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>int value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00813">unpackInt()</a>.</p>

</div>
</div>
<a class="anchor" id="ad5bf9b32f28078eab2d733c2318fa1d1"></a><!-- doxytag: member="vrt::VRTMath::unpackInt" ref="ad5bf9b32f28078eab2d733c2318fa1d1" args="(const void *ptr, int32_t off, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::unpackInt </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack int data from a byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>int value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00813">unpackInt()</a>.</p>

<p>Referenced by <a class="el" href="BasicContextPacket_8h_source.html#l00316">vrt::BasicContextPacket::getContextIndicatorField0()</a>, <a class="el" href="BasicVRLFrame_8h_source.html#l00492">vrt::BasicVRLFrame::getFrameLength()</a>, <a class="el" href="VRTMath_8h_source.html#l00813">unpackInt()</a>, <a class="el" href="BasicVRTPacket_8h_source.html#l01025">vrt::BasicVRTPacket::unpackPayloadInt()</a>, and <a class="el" href="VRTMath_8h_source.html#l00930">unpackUInt()</a>.</p>

</div>
</div>
<a class="anchor" id="ac40fcd1efc24876703aaa328c662bac0"></a><!-- doxytag: member="vrt::VRTMath::unpackInt24" ref="ac40fcd1efc24876703aaa328c662bac0" args="(const vector&lt; char &gt; &amp;buf, int32_t off, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::unpackInt24 </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Unpack a 24-bit integer value as an int data from a byte buffer </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>int value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00789">unpackInt24()</a>.</p>

</div>
</div>
<a class="anchor" id="ae84b2606228c76a229343a34aaff8244"></a><!-- doxytag: member="vrt::VRTMath::unpackInt24" ref="ae84b2606228c76a229343a34aaff8244" args="(const void *ptr, int32_t off, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vrt::VRTMath::unpackInt24 </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Unpack a 24-bit integer value as an int data from a byte buffer </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>int value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00789">unpackInt24()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00789">unpackInt24()</a>, and <a class="el" href="VRTMath_8h_source.html#l00898">unpackUInt24()</a>.</p>

</div>
</div>
<a class="anchor" id="ac8196945ee3c93169ee200d612a74b3b"></a><!-- doxytag: member="vrt::VRTMath::unpackLong" ref="ac8196945ee3c93169ee200d612a74b3b" args="(const vector&lt; char &gt; &amp;buf, int32_t off, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vrt::VRTMath::unpackLong </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack long data from a byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>long value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00835">unpackLong()</a>.</p>

</div>
</div>
<a class="anchor" id="a7672d15d90aff779434ca999995b38b7"></a><!-- doxytag: member="vrt::VRTMath::unpackLong" ref="a7672d15d90aff779434ca999995b38b7" args="(const void *ptr, int32_t off, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vrt::VRTMath::unpackLong </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack long data from a byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>long value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00835">unpackLong()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00835">unpackLong()</a>, and <a class="el" href="BasicVRTPacket_8h_source.html#l01027">vrt::BasicVRTPacket::unpackPayloadLong()</a>.</p>

</div>
</div>
<a class="anchor" id="a6cc65757d0e95057485375a6907703be"></a><!-- doxytag: member="vrt::VRTMath::unpackMetadata" ref="a6cc65757d0e95057485375a6907703be" args="(const vector&lt; char &gt; &amp;buf, int32_t off, int32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrt_1_1MetadataBlock.html">MetadataBlock</a> vrt::VRTMath::unpackMetadata </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack a metadata block into a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the block </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l01043">vrt::BasicVRTPacket::unpackPayloadMetadata()</a>.</p>

</div>
</div>
<a class="anchor" id="a381a914b6e2172aa2715869569074ef5"></a><!-- doxytag: member="vrt::VRTMath::unpackRecord" ref="a381a914b6e2172aa2715869569074ef5" args="(const vector&lt; char &gt; &amp;buf, int32_t off, Record &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrt::VRTMath::unpackRecord </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Record &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a record into a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The record to pack </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l01037">vrt::BasicVRTPacket::unpackPayloadRecord()</a>.</p>

</div>
</div>
<a class="anchor" id="afb9d13c6454cb5815dc3fb642cc6866d"></a><!-- doxytag: member="vrt::VRTMath::unpackShort" ref="afb9d13c6454cb5815dc3fb642cc6866d" args="(const vector&lt; char &gt; &amp;buf, int32_t off, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t vrt::VRTMath::unpackShort </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack short data from a byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>short value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00767">unpackShort()</a>.</p>

</div>
</div>
<a class="anchor" id="a264fbdb80810f4db5f85096fdfe59c36"></a><!-- doxytag: member="vrt::VRTMath::unpackShort" ref="a264fbdb80810f4db5f85096fdfe59c36" args="(const void *ptr, int32_t off, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t vrt::VRTMath::unpackShort </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack short data from a byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>short value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00767">unpackShort()</a>.</p>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l01023">vrt::BasicVRTPacket::unpackPayloadShort()</a>, <a class="el" href="VRTMath_8h_source.html#l00767">unpackShort()</a>, and <a class="el" href="VRTMath_8h_source.html#l00888">unpackUShort()</a>.</p>

</div>
</div>
<a class="anchor" id="ac53dfa251acf1887213518bca6fca93e"></a><!-- doxytag: member="vrt::VRTMath::unpackTimeStamp" ref="ac53dfa251acf1887213518bca6fca93e" args="(const vector&lt; char &gt; &amp;buf, int32_t off, IntegerMode epoch, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> vrt::VRTMath::unpackTimeStamp </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerMode&nbsp;</td>
          <td class="paramname"> <em>epoch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack an VITA 49.0 time stamp from a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>epoch</em>&nbsp;</td><td>The epoch to use (must be either <code>IntegerMode_UTC</code> or <code>IntegerMode_GPS</code>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The unpacked value </dd></dl>

<p>References <a class="el" href="TimeStamp_8h_source.html#l01180">unpackTimeStamp()</a>.</p>

</div>
</div>
<a class="anchor" id="a8ebad613b55ad53a76ce530dc6726cfa"></a><!-- doxytag: member="vrt::VRTMath::unpackTimeStamp" ref="a8ebad613b55ad53a76ce530dc6726cfa" args="(const void *ptr, int32_t off, IntegerMode epoch, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrt_1_1TimeStamp.html">TimeStamp</a> vrt::VRTMath::unpackTimeStamp </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerMode&nbsp;</td>
          <td class="paramname"> <em>epoch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack an VITA 49.0 time stamp from a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>epoch</em>&nbsp;</td><td>The epoch to use (must be either <code>IntegerMode_UTC</code> or <code>IntegerMode_GPS</code>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The unpacked value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00918">unpackUInt()</a>, and <a class="el" href="VRTMath_8h_source.html#l00940">unpackULong()</a>.</p>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l01049">vrt::BasicVRTPacket::unpackPayloadTimeStamp()</a>, and <a class="el" href="TimeStamp_8h_source.html#l01193">unpackTimeStamp()</a>.</p>

</div>
</div>
<a class="anchor" id="abe4dbc7887c1fb5269bd2de5301bd355"></a><!-- doxytag: member="vrt::VRTMath::unpackUByte" ref="abe4dbc7887c1fb5269bd2de5301bd355" args="(const vector&lt; char &gt; &amp;buf, int32_t off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char vrt::VRTMath::unpackUByte </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack unsigned byte data from a byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>short value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00856">unpackUByte()</a>.</p>

</div>
</div>
<a class="anchor" id="a2b3a973f0cd00ebfae95fee5c64486aa"></a><!-- doxytag: member="vrt::VRTMath::unpackUByte" ref="a2b3a973f0cd00ebfae95fee5c64486aa" args="(const void *ptr, int32_t off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char vrt::VRTMath::unpackUByte </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack unsigned byte data from a byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>short value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00856">unpackUByte()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00856">unpackUByte()</a>.</p>

</div>
</div>
<a class="anchor" id="a093290796e219d44aa4d3aff4f5d8a1e"></a><!-- doxytag: member="vrt::VRTMath::unpackUInt" ref="a093290796e219d44aa4d3aff4f5d8a1e" args="(const vector&lt; char &gt; &amp;buf, int32_t off, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vrt::VRTMath::unpackUInt </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack unsigned int data from a byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>int value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00813">unpackInt()</a>, and <a class="el" href="VRTMath_8h_source.html#l00918">unpackUInt()</a>.</p>

</div>
</div>
<a class="anchor" id="ae199a445f6393f76e87b76ba26ff0c4b"></a><!-- doxytag: member="vrt::VRTMath::unpackUInt" ref="ae199a445f6393f76e87b76ba26ff0c4b" args="(const void *ptr, int32_t off, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vrt::VRTMath::unpackUInt </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack unsigned int data from a byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>int value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00918">unpackUInt()</a>.</p>

<p>Referenced by <a class="el" href="TimeStamp_8h_source.html#l01180">unpackTimeStamp()</a>, and <a class="el" href="VRTMath_8h_source.html#l00918">unpackUInt()</a>.</p>

</div>
</div>
<a class="anchor" id="a05d058ea4e35e8211b46536e6f7ef602"></a><!-- doxytag: member="vrt::VRTMath::unpackUInt24" ref="a05d058ea4e35e8211b46536e6f7ef602" args="(const vector&lt; char &gt; &amp;buf, int32_t off, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vrt::VRTMath::unpackUInt24 </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Unpack an unsigned 24-bit integer value as an int data from a byte buffer </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>int value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00898">unpackUInt24()</a>.</p>

</div>
</div>
<a class="anchor" id="a5364224e826a0f9ffd1885cd42c9a14b"></a><!-- doxytag: member="vrt::VRTMath::unpackUInt24" ref="a5364224e826a0f9ffd1885cd42c9a14b" args="(const void *ptr, int32_t off, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vrt::VRTMath::unpackUInt24 </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Internal Use Only:</b> Unpack an unsigned 24-bit integer value as an int data from a byte buffer </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>int value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00789">unpackInt24()</a>, and <a class="el" href="VRTMath_8h_source.html#l00898">unpackUInt24()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00898">unpackUInt24()</a>.</p>

</div>
</div>
<a class="anchor" id="aece17a32b84e416d01ec650be6fa5c44"></a><!-- doxytag: member="vrt::VRTMath::unpackULong" ref="aece17a32b84e416d01ec650be6fa5c44" args="(const vector&lt; char &gt; &amp;buf, int32_t off, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vrt::VRTMath::unpackULong </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack unsigned long data from a byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>long value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00940">unpackULong()</a>.</p>

</div>
</div>
<a class="anchor" id="a40a76b7acab976cd87c1dc73f725f5cd"></a><!-- doxytag: member="vrt::VRTMath::unpackULong" ref="a40a76b7acab976cd87c1dc73f725f5cd" args="(const void *ptr, int32_t off, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vrt::VRTMath::unpackULong </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack unsigned long data from a byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>long value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00940">unpackULong()</a>.</p>

<p>Referenced by <a class="el" href="TimeStamp_8h_source.html#l01180">unpackTimeStamp()</a>, and <a class="el" href="VRTMath_8h_source.html#l00940">unpackULong()</a>.</p>

</div>
</div>
<a class="anchor" id="a83ddd4d364b9a4271d09aa546e5bbc69"></a><!-- doxytag: member="vrt::VRTMath::unpackUShort" ref="a83ddd4d364b9a4271d09aa546e5bbc69" args="(const vector&lt; char &gt; &amp;buf, int32_t off, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t vrt::VRTMath::unpackUShort </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack unsigned short data from a byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>short value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00767">unpackShort()</a>, and <a class="el" href="VRTMath_8h_source.html#l00876">unpackUShort()</a>.</p>

</div>
</div>
<a class="anchor" id="a029d8638649d515c09bddcbf59aecc38"></a><!-- doxytag: member="vrt::VRTMath::unpackUShort" ref="a029d8638649d515c09bddcbf59aecc38" args="(const void *ptr, int32_t off, ByteOrder rep=BIG_ENDIAN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t vrt::VRTMath::unpackUShort </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&nbsp;</td>
          <td class="paramname"> <em>rep</em> = <code>BIG_ENDIAN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack unsigned short data from a byte buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rep</em>&nbsp;</td><td>The byte representation to use (BIG_ENDIAN or LITTLE_ENDIAN) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>short value </dd></dl>

<p>References <a class="el" href="VRTMath_8h_source.html#l00876">unpackUShort()</a>.</p>

<p>Referenced by <a class="el" href="VRTMath_8h_source.html#l00876">unpackUShort()</a>.</p>

</div>
</div>
<a class="anchor" id="ad9ff76ee1537464c6139198b4a45ff13"></a><!-- doxytag: member="vrt::VRTMath::unpackUTF8" ref="ad9ff76ee1537464c6139198b4a45ff13" args="(const vector&lt; char &gt; &amp;buf, int32_t off, int32_t len, wchar_t replacement='?')" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wstring vrt::VRTMath::unpackUTF8 </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&nbsp;</td>
          <td class="paramname"> <em>replacement</em> = <code>'?'</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack a modified UTF-8 string from a buffer. </p>
<p>See the version of this method that takes in a void* for more details. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length of the string in the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>replacement</em>&nbsp;</td><td>The replacement character to use whenever a non UTF-8 character is encountered (typically '?'), if null an exception is thrown rather than replacing erroneous characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The unpacked value. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the string found is not proper UTF-8 and replacement is null. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacevrt_1_1VRTMath.html#a887aa55d34bfb4e224a7766e897796d4">unpackUTF8()</a>.</p>

</div>
</div>
<a class="anchor" id="a887aa55d34bfb4e224a7766e897796d4"></a><!-- doxytag: member="vrt::VRTMath::unpackUTF8" ref="a887aa55d34bfb4e224a7766e897796d4" args="(const void *ptr, int32_t off, int32_t len, wchar_t replacement='?')" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wstring vrt::VRTMath::unpackUTF8 </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&nbsp;</td>
          <td class="paramname"> <em>replacement</em> = <code>'?'</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack a modified UTF-8 string from a buffer. </p>
<p>The string is assumed to be null-terminated in the event that the string is shorter than the allowable length. <br/>
 <br/>
 The modified UTF-8 format is identical to "normal" UTF-8 except that any embedded NUL values within the string are encoded as two-byte values (similar to what is done in the Java VM). Note that unlike the Java VM and some other 16-bit UTF representations in C++ this does NOT rely on "surrogate pairs" and supports the 1-/2-/3-/4-octet forms of UTF-8: </p>
<pre>
    Values in the 0x0001 to 0x007F range (ASCII, except NUL):
      Octet 1: [ 0 x x x x x x x ]</pre><pre>    Values in the 0x0080 to 0x07FF range and 0x0000 (ASCII NUL):
      Octet 1: [ 1 1 0 x x x x x ]
      Octet 2: [ 1 0 x x x x x x ]</pre><pre>    Values in the 0x0800 to 0xFFFF range:
      Octet 1: [ 1 1 1 0 x x x x ]
      Octet 2: [ 1 0 x x x x x x ]
      Octet 3: [ 1 0 x x x x x x ]</pre><pre>    Values in the 0x10000 to 0x10FFFF range:
      Octet 1: [ 1 1 1 1 0 x x x ]
      Octet 2: [ 1 0 x x x x x x ]
      Octet 3: [ 1 0 x x x x x x ]
      Octet 4: [ 1 0 x x x x x x ]
  </pre> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length of the string in the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>replacement</em>&nbsp;</td><td>The replacement character to use whenever a non UTF-8 character is encountered (typically '?'), if null an exception is thrown rather than replacing erroneous characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The unpacked value. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classvrt_1_1VRTException.html" title="A basic exception definition.">VRTException</a></em>&nbsp;</td><td>If the string found is not proper UTF-8 and replacement is null. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l01041">vrt::BasicVRTPacket::unpackPayloadUTF8()</a>, and <a class="el" href="VRTMath_8h_source.html#l01123">unpackUTF8()</a>.</p>

</div>
</div>
<a class="anchor" id="abd1bdc2a7ab31312cb3d58e7af21ec86"></a><!-- doxytag: member="vrt::VRTMath::unpackUUID" ref="abd1bdc2a7ab31312cb3d58e7af21ec86" args="(const vector&lt; char &gt; &amp;buf, int32_t off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrt_1_1UUID.html">UUID</a> vrt::VRTMath::unpackUUID </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack a 16-byte <a class="el" href="classvrt_1_1UUID.html" title="A 128-bit universally unique identifier (UUID).">UUID</a> from a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The unpacked value </dd></dl>

<p>References <a class="el" href="UUID_8h_source.html#l00109">vrt::UUID::setValue()</a>.</p>

</div>
</div>
<a class="anchor" id="aa2587a0037e96b2a8629dccff49258de"></a><!-- doxytag: member="vrt::VRTMath::unpackUUID" ref="aa2587a0037e96b2a8629dccff49258de" args="(const void *ptr, int32_t off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrt_1_1UUID.html">UUID</a> vrt::VRTMath::unpackUUID </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpack a 16-byte <a class="el" href="classvrt_1_1UUID.html" title="A 128-bit universally unique identifier (UUID).">UUID</a> from a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to byte array of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>Offset into array </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The unpacked value </dd></dl>

<p>References <a class="el" href="UUID_8h_source.html#l00109">vrt::UUID::setValue()</a>.</p>

<p>Referenced by <a class="el" href="BasicVRTPacket_8h_source.html#l01053">vrt::BasicVRTPacket::unpackPayloadUUID()</a>.</p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 29 Jun 2018 for VRT by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>

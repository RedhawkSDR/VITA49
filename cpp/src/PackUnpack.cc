//
//  THIS FILE IS AUTO-GENERATED, DO NOT MODIFY
//
#include "PackUnpack.h"

using namespace std;
using namespace vrt;
using namespace vrt::VRTMath;
using namespace vrt::Utilities;

/** <b>Internal Use Only:</b> Fast unpack method for double data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 64)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void unpackDoubles (const void *ptr, int32_t off, double *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  // When using Double data, it is required that dSize=64 and fSize=64 so we can
  // skip some of the normal checks we would otherwise do here.
  for (int32_t i = 0; i < length; i++,off+=8) {
    array[offset++] = (double)unpackDouble(buf, off);
  }
}
/** <b>Internal Use Only:</b>
 *  Fast pack method for double data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 64)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void packDoubles (void *ptr, int32_t off, const double *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  // When using Double data, it is required that dSize=64 and fSize=64 so we can
  // skip some of the normal checks we would otherwise do here.
  for (int32_t i = 0; i < length; i++,off+=8) {
    packDouble(buf, off, (double)array[offset++]);
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for float data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 32)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void unpackFloats (const void *ptr, int32_t off, double *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  int32_t delta; // int8_t offset delta
  if (align) delta = (fSize <= 32)? 4 : 8;
  else       delta = fSize / 8;
  for (int32_t i = 0; i < length; i++,off+=delta) {
    array[offset++] = (double)unpackFloat(buf, off);
  }
}
/** <b>Internal Use Only:</b>
 *  Fast pack method for float data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 32)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void packFloats (void *ptr, int32_t off, const double *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  int32_t delta; // int8_t offset delta
  if (align) delta = (fSize <= 32)? 4 : 8;
  else       delta = fSize / 8;
  if (delta == 4) {
    for (int32_t i = 0; i < length; i++,off+=4) {
      packFloat(buf, off, (float)array[offset++]);
    }
  }
  else {
    for (int32_t i = 0; i < length; i++) {
      packFloat(buf, off, (float)array[offset++]);
      off += 4;
      _Intel_Pragma("loop_count min=1, max=4")
      for (int32_t j = 4; j < delta; j++) {
        buf[off++] = 0; // set unused bits to zero
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int64_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackLongs (const void *ptr, int32_t off, double *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  if (sign) {
    if (dSize == 64) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (double)unpackLong(buf, off);
      }
    }
    else {
      int32_t shift  = 64 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (double)(unpackLong(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 64) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (double)(unpackLong(buf, off) & __INT64_C(0xFFFFFFFFFFFFFFFF));
      }
    }
    else {
      int32_t shift  = 64 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (double)((unpackLong(buf, off) & __INT64_C(0xFFFFFFFFFFFFFFFF)) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int64_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packLongs (void *ptr, int32_t off, const double *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  int64_t valMask = (sign)? ((int64_t)-1) : ((int64_t)__INT64_C(0xFFFFFFFFFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 64) {
    if (delta == 8) {
      for (int32_t i = 0; i < length; i++,off+=8) {
        int64_t val = (int64_t)(((int64_t)(int64_t)array[offset++]) & valMask);
        packLong(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int64_t val = (int64_t)(((int64_t)(int64_t)array[offset++]) & valMask);
        packLong(buf, off, val);
        off += 8;
        _Intel_Pragma("loop_count min=1, max=0")
        for (int32_t j = 8; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 64 - dSize;
    if (delta == 8) {
      for (int32_t i = 0; i < length; i++,off+=8) {
        int64_t val = (int64_t)(((int64_t)(int64_t)array[offset++]) & valMask);
        packLong(buf, off, (int64_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int64_t val = (int64_t)(((int64_t)(int64_t)array[offset++]) & valMask);
        packLong(buf, off, (int64_t)(val << shift));
        off += 8;
        _Intel_Pragma("loop_count min=1, max=0")
        for (int32_t j = 8; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int32_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackInts (const void *ptr, int32_t off, double *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  if (sign) {
    if (dSize == 32) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (double)unpackInt(buf, off);
      }
    }
    else {
      int32_t shift  = 32 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (double)(unpackInt(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 32) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (double)(unpackInt(buf, off) & __INT64_C(0xFFFFFFFF));
      }
    }
    else {
      int32_t shift  = 32 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (double)((unpackInt(buf, off) & __INT64_C(0xFFFFFFFF)) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int32_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packInts (void *ptr, int32_t off, const double *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  int32_t valMask = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFFFFFFFFFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 32) {
    if (delta == 4) {
      for (int32_t i = 0; i < length; i++,off+=4) {
        int32_t val = (int32_t)(((int32_t)(int64_t)array[offset++]) & valMask);
        packInt(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)(int64_t)array[offset++]) & valMask);
        packInt(buf, off, val);
        off += 4;
        _Intel_Pragma("loop_count min=1, max=4")
        for (int32_t j = 4; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 32 - dSize;
    if (delta == 4) {
      for (int32_t i = 0; i < length; i++,off+=4) {
        int32_t val = (int32_t)(((int32_t)(int64_t)array[offset++]) & valMask);
        packInt(buf, off, (int32_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)(int64_t)array[offset++]) & valMask);
        packInt(buf, off, (int32_t)(val << shift));
        off += 4;
        _Intel_Pragma("loop_count min=1, max=4")
        for (int32_t j = 4; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int32_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackInt24s (const void *ptr, int32_t off, double *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  if (sign) {
    if (dSize == 24) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (double)unpackInt24(buf, off);
      }
    }
    else {
      int32_t shift  = 24 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (double)(unpackInt24(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 24) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (double)(unpackInt24(buf, off) & __INT64_C(0xFFFFFF));
      }
    }
    else {
      int32_t shift  = 24 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (double)((unpackInt24(buf, off) & __INT64_C(0xFFFFFF)) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int32_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packInt24s (void *ptr, int32_t off, const double *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  int32_t valMask = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFFFFFFFFFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 24) {
    if (delta == 3) {
      for (int32_t i = 0; i < length; i++,off+=3) {
        int32_t val = (int32_t)(((int32_t)(int64_t)array[offset++]) & valMask);
        packInt24(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)(int64_t)array[offset++]) & valMask);
        packInt24(buf, off, val);
        off += 3;
        _Intel_Pragma("loop_count min=1, max=5")
        for (int32_t j = 3; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 24 - dSize;
    if (delta == 3) {
      for (int32_t i = 0; i < length; i++,off+=3) {
        int32_t val = (int32_t)(((int32_t)(int64_t)array[offset++]) & valMask);
        packInt24(buf, off, (int32_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)(int64_t)array[offset++]) & valMask);
        packInt24(buf, off, (int32_t)(val << shift));
        off += 3;
        _Intel_Pragma("loop_count min=1, max=5")
        for (int32_t j = 3; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int16_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackShorts (const void *ptr, int32_t off, double *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = fSize / 8; // int8_t offset delta
  if (sign) {
    if (dSize == 16) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (double)unpackShort(buf, off);
      }
    }
    else {
      int32_t shift  = 16 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (double)(unpackShort(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 16) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (double)(unpackShort(buf, off) & __INT64_C(0xFFFF));
      }
    }
    else {
      int32_t shift  = 16 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (double)((unpackShort(buf, off) & __INT64_C(0xFFFF)) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int16_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packShorts (void *ptr, int32_t off, const double *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = fSize / 8; // int8_t offset delta
  int16_t valMask = (sign)? ((int16_t)-1) : ((int16_t)__INT64_C(0xFFFFFFFFFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 16) {
    if (delta == 2) {
      for (int32_t i = 0; i < length; i++,off+=2) {
        int16_t val = (int16_t)(((int16_t)(int64_t)array[offset++]) & valMask);
        packShort(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int16_t val = (int16_t)(((int16_t)(int64_t)array[offset++]) & valMask);
        packShort(buf, off, val);
        off += 2;
        _Intel_Pragma("loop_count min=1, max=6")
        for (int32_t j = 2; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 16 - dSize;
    if (delta == 2) {
      for (int32_t i = 0; i < length; i++,off+=2) {
        int16_t val = (int16_t)(((int16_t)(int64_t)array[offset++]) & valMask);
        packShort(buf, off, (int16_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int16_t val = (int16_t)(((int16_t)(int64_t)array[offset++]) & valMask);
        packShort(buf, off, (int16_t)(val << shift));
        off += 2;
        _Intel_Pragma("loop_count min=1, max=6")
        for (int32_t j = 2; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed Int12 data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 12)
 *  @param dSize  (IN)  Data item size in bits (must be 12)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackInt12s (const void *ptr, int32_t off, double *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t skip = (align)? 1 : 0;
  if (sign) {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t a = (int32_t)buf[off++];
      int32_t b = (int32_t)buf[off++];
      int32_t c = (int32_t)buf[off++];
      int32_t x = (a << 4) | ((b >> 4) & 0x000F);
      int32_t y = (b << 8) | ((c     ) & 0x00FF);
      array[offset++] = (double)((x << 20) >> 20); // sign extend
      array[offset++] = (double)((y << 20) >> 20); // sign extend
      off += skip; // skip extra int8_t in processing-efficient mode
    }
  }
  else {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t a = (int32_t)buf[off++];
      int32_t b = (int32_t)buf[off++];
      int32_t c = (int32_t)buf[off++];
      int32_t x = (a << 4) | ((b >> 4) & 0x000F);
      int32_t y = (b << 8) | ((c     ) & 0x00FF);
      array[offset++] = (double)(x & 0x0FFF); // clear high-order bits
      array[offset++] = (double)(y & 0x0FFF); // clear high-order bits
      off += skip; // skip extra int8_t in processing-efficient mode
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for signed Int12 data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 12)
 *  @param dSize  (IN)  Data item size in bits (must be 12)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packInt12s (void *ptr, int32_t off, const double *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t skip = (align)?  1 : 0;
  int32_t mask = (sign )? -1 : ((int32_t)__INT64_C(0xFFFFFFFFFFFFFFFF));
  for (int32_t i = 0; i < length; i+=2) {
    int32_t first  = ((int32_t)(int64_t)array[offset++]) & mask;
    int32_t second = ((int32_t)(int64_t)array[offset++]) & mask;
    buf[off++] = (int8_t)(first >> 4);
    buf[off++] = (int8_t)((first << 4) | ((second >> 8) & 0x0F));
    buf[off++] = (int8_t)(second);
    off += skip; // skip extra int8_t in processing-efficient mode
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int8_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackBytes (const void *ptr, int32_t off, double *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = fSize / 8; // int8_t offset delta
  if (sign) {
    if (dSize == 8) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (double)unpackByte(buf, off);
      }
    }
    else {
      int32_t shift  = 8 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (double)(unpackByte(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 8) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (double)(unpackByte(buf, off) & __INT64_C(0xFF));
      }
    }
    else {
      int32_t shift  = 8 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (double)((unpackByte(buf, off) & __INT64_C(0xFF)) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int8_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packBytes (void *ptr, int32_t off, const double *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = fSize / 8; // int8_t offset delta
  int8_t valMask = (sign)? ((int8_t)-1) : ((int8_t)__INT64_C(0xFFFFFFFFFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 8) {
    if (delta == 1) {
      for (int32_t i = 0; i < length; i++,off+=1) {
        int8_t val = (int8_t)(((int8_t)(int64_t)array[offset++]) & valMask);
        packByte(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int8_t val = (int8_t)(((int8_t)(int64_t)array[offset++]) & valMask);
        packByte(buf, off, val);
        off += 1;
        _Intel_Pragma("loop_count min=1, max=7")
        for (int32_t j = 1; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 8 - dSize;
    if (delta == 1) {
      for (int32_t i = 0; i < length; i++,off+=1) {
        int8_t val = (int8_t)(((int8_t)(int64_t)array[offset++]) & valMask);
        packByte(buf, off, (int8_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int8_t val = (int8_t)(((int8_t)(int64_t)array[offset++]) & valMask);
        packByte(buf, off, (int8_t)(val << shift));
        off += 1;
        _Intel_Pragma("loop_count min=1, max=7")
        for (int32_t j = 1; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed Int4 (nibble) data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 4)
 *  @param dSize  (IN)  Data item size in bits (must be 4)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackNibbles (const void *ptr, int32_t off, double *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  if (sign) {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (double)((b << 24) >> 28); // shift & sign extend
      array[offset++] = (double)((b << 28) >> 28); // shift & sign extend
    }
  }
  else {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (double)((b >> 4) & 0xF);
      array[offset++] = (double)((b     ) & 0xF);
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for signed Int4 (nibble) data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 4)
 *  @param dSize  (IN)  Data item size in bits (must be 4)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packNibbles (void *ptr, int32_t off, const double *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Pack function for signed and unsigned are identical for nibble data, hence
  // 'sign' is unused here, but included in function definition for consistency.
  for (int32_t i = 0; i < length; i+=2) {
    int32_t first  = (int32_t)(int64_t)array[offset++];
    int32_t second = (int32_t)(int64_t)array[offset++];
    buf[off++] = (int8_t)((first << 4) | (second & 0xF));
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for bit data. Each bit in the
 *  input buffer will be checked, a 0 bit will correspond to the value 0 and a
 *  1 bit will correspond to the value 1.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
 *  @param fSize  (IN)  Item packing field size in bits (must be 1)
 *  @param dSize  (IN)  Data item size in bits (must be 1)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackBits (const void *ptr, int32_t off, double *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  if (sign) {
    // This uses sign-extending principles to get each bit as 0 or -1 which reflects
    // the fact that 0/-1 and not 0/+1 are the available values in a one-bit use of
    // twos-complement.
    for (int32_t i = 0; i < length; i+=8) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (double)((b << 24) >> 31);
      array[offset++] = (double)((b << 25) >> 31);
      array[offset++] = (double)((b << 26) >> 31);
      array[offset++] = (double)((b << 27) >> 31);
      array[offset++] = (double)((b << 28) >> 31);
      array[offset++] = (double)((b << 29) >> 31);
      array[offset++] = (double)((b << 30) >> 31);
      array[offset++] = (double)((b << 31) >> 31);
    }
  }
  else {
    for (int32_t i = 0; i < length; i+=8) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (double)((b >> 7) & 0x1);
      array[offset++] = (double)((b >> 6) & 0x1);
      array[offset++] = (double)((b >> 5) & 0x1);
      array[offset++] = (double)((b >> 4) & 0x1);
      array[offset++] = (double)((b >> 3) & 0x1);
      array[offset++] = (double)((b >> 2) & 0x1);
      array[offset++] = (double)((b >> 1) & 0x1);
      array[offset++] = (double)((b     ) & 0x1);
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for bit data. Each value in the
 *  input array will be checked, a zero value will correspond to the bit 0 and
 *  any non-zero value will correspond to the bit 1.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
 *  @param fSize  (IN)  Item packing field size in bits (must be 1)
 *  @param dSize  (IN)  Data item size in bits (must be 1)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packBits (void *ptr, int32_t off, const double *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Pack function for signed and unsigned are identical for bit data, hence
  // 'sign' is unused here, but included in function definition for consistency.
  for (int32_t i = 0; i < length; i+=8) {
    int32_t b = 0;
    b |= (((int64_t)array[offset++]) << 7) & 0x80;
    b |= (((int64_t)array[offset++]) << 6) & 0x40;
    b |= (((int64_t)array[offset++]) << 5) & 0x20;
    b |= (((int64_t)array[offset++]) << 4) & 0x10;
    b |= (((int64_t)array[offset++]) << 3) & 0x08;
    b |= (((int64_t)array[offset++]) << 2) & 0x04;
    b |= (((int64_t)array[offset++]) << 1) & 0x02;
    b |= (((int64_t)array[offset++])     ) & 0x01;
    buf[off++] = (int8_t)b;
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array, where the data is
 *  aligned to 32-bit word boundaries.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array  (OUT) Output value array (not null)
 *  @param chan   (OUT) Output channel tag array (null if n/a)
 *  @param evt    (OUT) Output event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntWord32 (const void *ptr, int32_t off, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 32 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int32_t valMask  = (sign)? ((int32_t)-1) : (~(((int32_t)-1) << dSize));
  for (int32_t i = 0; i < length; i++,off+=4) {
    int32_t value = unpackInt(buf, off);
    array[i] = (double)((value >> (32-dSize)) & valMask);
    if (chan != NULL) chan[i] = (value >> (pSize      )) & chanMask;
    if (evt  != NULL) evt[i]  = (value >> (pSize+cSize)) & evtMask;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array, where the data is
 *  aligned to 32-bit word boundaries.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input value array
 *  @param chan   (IN)  Input channel tag array (null if n/a)
 *  @param evt    (IN)  Input event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntWord32 (void *ptr, int32_t off, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 32 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int32_t valMask  = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFFFFFFFFFFFFFFFF));
  for (int32_t i = 0; i < length; i++,off+=4) {
    int32_t val   = (int32_t)(((int32_t)(int64_t)array[i]) & valMask);
    int32_t value = val << (32-dSize);
    if (chan != NULL) value |= (chan[i] & chanMask) << (pSize);
    if (evt  != NULL) value |= (evt[i]  & evtMask ) << (pSize+cSize);
    packInt(buf, off, value);
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array  (OUT) Output value array (not null)
 *  @param chan   (OUT) Output channel tag array (null if n/a)
 *  @param evt    (OUT) Output event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntWord64 (const void *ptr, int32_t off, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int64_t valMask  = (sign)? ((int64_t)-1) : (~(((int64_t)-1) << dSize));
  if (dSize == 32) {
    // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
    // value, so use 32-bit operations to improve performance
    for (int32_t i = 0; i < length; i++,off+=8) {
      int32_t val   = unpackInt(buf, off);
      int32_t value = unpackInt(buf, off+4);
      array[i] = (double)(val & valMask);
      if (chan != NULL) chan[i] = ((int32_t)(value >> (pSize      ))) & chanMask;
      if (evt  != NULL) evt[i]  = ((int32_t)(value >> (pSize+cSize))) & evtMask;
    }
  }
  else {
    for (int32_t i = 0; i < length; i++,off+=8) {
      int64_t value = unpackLong(buf, off);
      array[i] = (double)((value >> (64-dSize)) & valMask);
      if (chan != NULL) chan[i] = ((int32_t)(value >> (pSize      ))) & chanMask;
      if (evt  != NULL) evt[i]  = ((int32_t)(value >> (pSize+cSize))) & evtMask;
    }
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input value array
 *  @param chan   (IN)  Input channel tag array (null if n/a)
 *  @param evt    (IN)  Input event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntWord64 (void *ptr, int32_t off, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int64_t valMask  = (sign)? ((int64_t)-1) : ((int64_t)__INT64_C(0xFFFFFFFFFFFFFFFF));
  if (dSize == 32) {
    // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
    // value, so use 32-bit operations to improve performance
    for (int32_t i = 0; i < length; i++,off+=8) {
      int32_t val   = (int32_t)(((int64_t)(int64_t)array[i]) & valMask);
      int32_t value = 0;
      if (chan != NULL) value  = (chan[i] & chanMask) << (pSize);
      if (evt  != NULL) value |= (evt[i]  & evtMask ) << (pSize+cSize);
      packInt(buf, off,   val);
      packInt(buf, off+4, value);
    }
  }
  else {
    for (int32_t i = 0; i < length; i++,off+=8) {
      int64_t val   = (int64_t)(((int64_t)(int64_t)array[i]) & valMask);
      int64_t value = val << (64-dSize);
      if (chan != NULL) value |= ((int64_t)(chan[i] & chanMask)) << (pSize);
      if (evt  != NULL) value |= ((int64_t)(evt[i]  & evtMask )) << (pSize+cSize);
      packLong(buf, off, value);
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array  (OUT) Output value array (not null)
 *  @param chan   (OUT) Output channel tag array (null if n/a)
 *  @param evt    (OUT) Output event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackFloatWord64 (const void *ptr, int32_t off, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  // When using Float32 the first 32-bits will always the the Float32 value, so
  // use 32-bit operations to improve performance
  for (int32_t i = 0; i < length; i++,off+=8) {
    array[i] = (double)unpackFloat(buf, off);
    int32_t value = unpackInt(buf, off+4);
    if (chan != NULL) chan[i] = (value >> (pSize      )) & chanMask;
    if (evt  != NULL) evt[i]  = (value >> (pSize+cSize)) & evtMask;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input value array
 *  @param chan   (IN)  Input channel tag array (null if n/a)
 *  @param evt    (IN)  Input event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packFloatWord64 (void *ptr, int32_t off, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  // When using Float32 the first 32-bits will always the the Float32 value, so
  // use 32-bit operations to improve performance
  for (int32_t i = 0; i < length; i++,off+=8) {
    float val   = (float)array[i];
    int32_t   value = 0;
    if (chan != NULL) value  = (chan[i] & chanMask) << (pSize);
    if (evt  != NULL) value |= (evt[i]  & evtMask ) << (pSize+cSize);
    packFloat(buf, off,   val);
    packInt(  buf, off+4, value);
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntBuffer32 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_dSize  = 32 - dSize;    // pre-compute "32 - dSize" for efficiency
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      if (sign) {
        // sign extend
        array[offset] = (double)((value << _bits_dSize) >>  _bits_dSize);
      }
      else {
        // leave top bits (which default to 0) as 0
        array[offset] = (double)value;
      }
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntBuffer32 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  int32_t valMask      = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFFFFFFFFFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t arrayValue = ((int32_t)(int64_t)array[offset]) & valMask;
      int32_t value      = (int32_t)((arrayValue) << (32 - dSize));
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntBuffer64 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_dSize  = 64 - dSize;    // pre-compute "64 - dSize" for efficiency
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      if (sign) {
        // sign extend
        array[offset] = (double)((value << _bits_dSize) >>  _bits_dSize);
      }
      else {
        // leave top bits (which default to 0) as 0
        array[offset] = (double)value;
      }
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntBuffer64 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  int64_t valMask      = (sign)? ((int64_t)-1) : ((int64_t)__INT64_C(0xFFFFFFFFFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t arrayValue = ((int64_t)(int64_t)array[offset]) & valMask;
      int64_t value      = (int64_t)((arrayValue) << (64 - dSize));
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackFloatBuffer64 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)intBitsToFloat((int32_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packFloatBuffer64 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      float  arrayValue = (float)array[offset];
      int64_t   value      = ((int64_t)floatToRawIntBits(arrayValue)) << 32;
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT1Buffer32 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_SignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT1Buffer32 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT1, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT1Buffer64 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_SignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT1Buffer64 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT1, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT2Buffer32 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_SignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT2Buffer32 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT2, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT2Buffer64 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_SignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT2Buffer64 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT2, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT3Buffer32 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_SignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT3Buffer32 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT3, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT3Buffer64 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_SignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT3Buffer64 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT3, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT4Buffer32 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_SignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT4Buffer32 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT4, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT4Buffer64 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_SignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT4Buffer64 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT4, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT5Buffer32 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_SignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT5Buffer32 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT5, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT5Buffer64 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_SignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT5Buffer64 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT5, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT6Buffer32 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_SignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT6Buffer32 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT6, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT6Buffer64 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_SignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT6Buffer64 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT6, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT1Buffer32 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_UnsignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT1Buffer32 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT1, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT1Buffer64 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_UnsignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT1Buffer64 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT1, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT2Buffer32 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_UnsignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT2Buffer32 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT2, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT2Buffer64 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_UnsignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT2Buffer64 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT2, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT3Buffer32 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_UnsignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT3Buffer32 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT3, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT3Buffer64 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_UnsignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT3Buffer64 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT3, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT4Buffer32 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_UnsignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT4Buffer32 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT4, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT4Buffer64 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_UnsignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT4Buffer64 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT4, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT5Buffer32 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_UnsignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT5Buffer32 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT5, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT5Buffer64 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_UnsignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT5Buffer64 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT5, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT6Buffer32 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_UnsignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT6Buffer32 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT6, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT6Buffer64 (const void *ptr, int32_t bitOffset, double *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (double)fromVRTFloat(DataItemFormat_UnsignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT6Buffer64 (void *ptr, int32_t bitOffset, const double *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT6, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
double* vrt::PackUnpack::unpackAsDouble (PayloadFormat pf, const void *ptr, int32_t off, double *array, int32_t *chan, int32_t *evt, int32_t length) {
  const char *buf = (const char*)ptr;
  if (!pf.isValid()) {
    throw VRTException(pf.getValid());
  }
  int32_t            fSize  = pf.getItemPackingFieldSize();
  int32_t            dSize  = pf.getDataItemSize();
  int32_t            eSize  = pf.getEventTagSize();
  int32_t            cSize  = pf.getChannelTagSize();
  bool        proc   = pf.isProcessingEfficient();
  bool        sign   = pf.isSigned();
  DataItemFormat format = pf.getDataItemFormat();
  bool        noTags;
  if (eSize == 0) evt  = NULL; // no event tags, ignore any array passed in
  if (cSize == 0) chan = NULL; // no channel tags, ignore any array passed in
  noTags = (chan == NULL) && (evt == NULL);
  if (proc && noTags && (fSize >= 17)) {
    // Use faster "effective field size" when ignoring Event & Channel Tags
    fSize = (fSize <= 32)? 32 : 64;
  }
  switch (format) {
    case DataItemFormat_SignedInt:   // FALLTHROUGH
    case DataItemFormat_UnsignedInt:
      // ---- Try fast methods -------------------------------------------------
      if (noTags) {
        switch (fSize) {
          case  8: unpackBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 16: unpackShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 24: unpackInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 32: unpackInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 64: unpackLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
        }
      }
      if (fSize == dSize) { // implicit noTags=true in this case
        switch (fSize) {
          case  1: if ((length % 8) == 0) { unpackBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          case  4: if ((length % 2) == 0) { unpackNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          case 12: if ((length % 2) == 0) { unpackInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
        }
      }
      if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
        if (fSize <= 32) {
          unpackIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      }
      // ---- Fall back to slow method -----------------------------------------
      if (fSize <= 32) {
        unpackIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_Float:
      // ---- Try fast methods -------------------------------------------------
      if (fSize == dSize) { // implicit noTags=true in this case
        unpackFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
      }
      if ((proc && (fSize >= 33)) || (fSize == 64)) {
        unpackFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      // ---- Fall back to slow method -----------------------------------------
      unpackFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
    case DataItemFormat_Double:
      // ---- Only fast method for double (yea!) -------------------------------
      unpackDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
    case DataItemFormat_SignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    default:
      throw VRTException("Unpacking of VRT float types not supported yet");
  }
}
void vrt::PackUnpack::packAsDouble (PayloadFormat pf, void *ptr, int32_t off, const double *array, const int32_t *chan, const int32_t *evt, int32_t length) {
  char *buf = (char*)ptr;
  if (!pf.isValid()) {
    throw VRTException(pf.getValid());
  }
  int32_t            fSize  = pf.getItemPackingFieldSize();
  int32_t            dSize  = pf.getDataItemSize();
  int32_t            eSize  = pf.getEventTagSize();
  int32_t            cSize  = pf.getChannelTagSize();
  bool        proc   = pf.isProcessingEfficient();
  bool        sign   = pf.isSigned();
  DataItemFormat format = pf.getDataItemFormat();
  bool        noTags;
  if (eSize == 0) evt  = NULL; // no event tags, ignore any array passed in
  if (cSize == 0) chan = NULL; // no channel tags, ignore any array passed in
  noTags = (chan == NULL) && (evt == NULL);
  if (proc && noTags && (fSize >= 17)) {
    // Use faster "effective field size" when ignoring Event & Channel Tags
    fSize = (fSize <= 32)? 32 : 64;
  }
  switch (format) {
    case DataItemFormat_SignedInt:   // FALLTHROUGH
    case DataItemFormat_UnsignedInt:
      // ---- Try fast methods -------------------------------------------------
      if (noTags) {
        switch (fSize) {
          case  8: packBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 16: packShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 24: packInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 32: packInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 64: packLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
        }
      }
      if (fSize == dSize) { // implicit noTags=true in this case
        switch (fSize) {
          case  1: if ((length % 8) == 0) { packBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          case  4: if ((length % 2) == 0) { packNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          case 12: if ((length % 2) == 0) { packInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
        }
      }
      if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
        if (fSize <= 32) {
          packIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      }
      // ---- Fall back to slow method -----------------------------------------
      if (fSize <= 32) {
        packIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_Float:
      // ---- Try fast methods -------------------------------------------------
      if (fSize == dSize) { // implicit noTags=true in this case
        packFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
      }
      if ((proc && (fSize >= 33)) || (fSize == 64)) {
        packFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      // ---- Fall back to slow method -----------------------------------------
      packFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
    case DataItemFormat_Double:
      // ---- Only fast method for double (yea!) -------------------------------
      packDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
    case DataItemFormat_SignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    default:
      throw VRTException("Packing of VRT float types not supported yet");
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for double data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 64)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void unpackDoubles (const void *ptr, int32_t off, float *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  // When using Double data, it is required that dSize=64 and fSize=64 so we can
  // skip some of the normal checks we would otherwise do here.
  for (int32_t i = 0; i < length; i++,off+=8) {
    array[offset++] = (float)unpackDouble(buf, off);
  }
}
/** <b>Internal Use Only:</b>
 *  Fast pack method for double data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 64)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void packDoubles (void *ptr, int32_t off, const float *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  // When using Double data, it is required that dSize=64 and fSize=64 so we can
  // skip some of the normal checks we would otherwise do here.
  for (int32_t i = 0; i < length; i++,off+=8) {
    packDouble(buf, off, (double)array[offset++]);
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for float data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 32)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void unpackFloats (const void *ptr, int32_t off, float *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  int32_t delta; // int8_t offset delta
  if (align) delta = (fSize <= 32)? 4 : 8;
  else       delta = fSize / 8;
  for (int32_t i = 0; i < length; i++,off+=delta) {
    array[offset++] = (float)unpackFloat(buf, off);
  }
}
/** <b>Internal Use Only:</b>
 *  Fast pack method for float data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 32)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void packFloats (void *ptr, int32_t off, const float *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  int32_t delta; // int8_t offset delta
  if (align) delta = (fSize <= 32)? 4 : 8;
  else       delta = fSize / 8;
  if (delta == 4) {
    for (int32_t i = 0; i < length; i++,off+=4) {
      packFloat(buf, off, (float)array[offset++]);
    }
  }
  else {
    for (int32_t i = 0; i < length; i++) {
      packFloat(buf, off, (float)array[offset++]);
      off += 4;
      _Intel_Pragma("loop_count min=1, max=4")
      for (int32_t j = 4; j < delta; j++) {
        buf[off++] = 0; // set unused bits to zero
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int64_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackLongs (const void *ptr, int32_t off, float *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  if (sign) {
    if (dSize == 64) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (float)unpackLong(buf, off);
      }
    }
    else {
      int32_t shift  = 64 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (float)(unpackLong(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 64) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (float)(unpackLong(buf, off) & __INT64_C(0xFFFFFFFFFFFFFFFF));
      }
    }
    else {
      int32_t shift  = 64 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (float)((unpackLong(buf, off) & __INT64_C(0xFFFFFFFFFFFFFFFF)) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int64_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packLongs (void *ptr, int32_t off, const float *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  int64_t valMask = (sign)? ((int64_t)-1) : ((int64_t)__INT64_C(0xFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 64) {
    if (delta == 8) {
      for (int32_t i = 0; i < length; i++,off+=8) {
        int64_t val = (int64_t)(((int64_t)(int64_t)array[offset++]) & valMask);
        packLong(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int64_t val = (int64_t)(((int64_t)(int64_t)array[offset++]) & valMask);
        packLong(buf, off, val);
        off += 8;
        _Intel_Pragma("loop_count min=1, max=0")
        for (int32_t j = 8; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 64 - dSize;
    if (delta == 8) {
      for (int32_t i = 0; i < length; i++,off+=8) {
        int64_t val = (int64_t)(((int64_t)(int64_t)array[offset++]) & valMask);
        packLong(buf, off, (int64_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int64_t val = (int64_t)(((int64_t)(int64_t)array[offset++]) & valMask);
        packLong(buf, off, (int64_t)(val << shift));
        off += 8;
        _Intel_Pragma("loop_count min=1, max=0")
        for (int32_t j = 8; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int32_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackInts (const void *ptr, int32_t off, float *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  if (sign) {
    if (dSize == 32) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (float)unpackInt(buf, off);
      }
    }
    else {
      int32_t shift  = 32 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (float)(unpackInt(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 32) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (float)(unpackInt(buf, off) & __INT64_C(0xFFFFFFFF));
      }
    }
    else {
      int32_t shift  = 32 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (float)((unpackInt(buf, off) & __INT64_C(0xFFFFFFFF)) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int32_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packInts (void *ptr, int32_t off, const float *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  int32_t valMask = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 32) {
    if (delta == 4) {
      for (int32_t i = 0; i < length; i++,off+=4) {
        int32_t val = (int32_t)(((int32_t)(int64_t)array[offset++]) & valMask);
        packInt(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)(int64_t)array[offset++]) & valMask);
        packInt(buf, off, val);
        off += 4;
        _Intel_Pragma("loop_count min=1, max=4")
        for (int32_t j = 4; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 32 - dSize;
    if (delta == 4) {
      for (int32_t i = 0; i < length; i++,off+=4) {
        int32_t val = (int32_t)(((int32_t)(int64_t)array[offset++]) & valMask);
        packInt(buf, off, (int32_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)(int64_t)array[offset++]) & valMask);
        packInt(buf, off, (int32_t)(val << shift));
        off += 4;
        _Intel_Pragma("loop_count min=1, max=4")
        for (int32_t j = 4; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int32_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackInt24s (const void *ptr, int32_t off, float *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  if (sign) {
    if (dSize == 24) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (float)unpackInt24(buf, off);
      }
    }
    else {
      int32_t shift  = 24 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (float)(unpackInt24(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 24) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (float)(unpackInt24(buf, off) & __INT64_C(0xFFFFFF));
      }
    }
    else {
      int32_t shift  = 24 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (float)((unpackInt24(buf, off) & __INT64_C(0xFFFFFF)) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int32_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packInt24s (void *ptr, int32_t off, const float *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  int32_t valMask = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 24) {
    if (delta == 3) {
      for (int32_t i = 0; i < length; i++,off+=3) {
        int32_t val = (int32_t)(((int32_t)(int64_t)array[offset++]) & valMask);
        packInt24(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)(int64_t)array[offset++]) & valMask);
        packInt24(buf, off, val);
        off += 3;
        _Intel_Pragma("loop_count min=1, max=5")
        for (int32_t j = 3; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 24 - dSize;
    if (delta == 3) {
      for (int32_t i = 0; i < length; i++,off+=3) {
        int32_t val = (int32_t)(((int32_t)(int64_t)array[offset++]) & valMask);
        packInt24(buf, off, (int32_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)(int64_t)array[offset++]) & valMask);
        packInt24(buf, off, (int32_t)(val << shift));
        off += 3;
        _Intel_Pragma("loop_count min=1, max=5")
        for (int32_t j = 3; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int16_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackShorts (const void *ptr, int32_t off, float *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = fSize / 8; // int8_t offset delta
  if (sign) {
    if (dSize == 16) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (float)unpackShort(buf, off);
      }
    }
    else {
      int32_t shift  = 16 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (float)(unpackShort(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 16) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (float)(unpackShort(buf, off) & __INT64_C(0xFFFF));
      }
    }
    else {
      int32_t shift  = 16 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (float)((unpackShort(buf, off) & __INT64_C(0xFFFF)) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int16_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packShorts (void *ptr, int32_t off, const float *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = fSize / 8; // int8_t offset delta
  int16_t valMask = (sign)? ((int16_t)-1) : ((int16_t)__INT64_C(0xFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 16) {
    if (delta == 2) {
      for (int32_t i = 0; i < length; i++,off+=2) {
        int16_t val = (int16_t)(((int16_t)(int64_t)array[offset++]) & valMask);
        packShort(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int16_t val = (int16_t)(((int16_t)(int64_t)array[offset++]) & valMask);
        packShort(buf, off, val);
        off += 2;
        _Intel_Pragma("loop_count min=1, max=6")
        for (int32_t j = 2; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 16 - dSize;
    if (delta == 2) {
      for (int32_t i = 0; i < length; i++,off+=2) {
        int16_t val = (int16_t)(((int16_t)(int64_t)array[offset++]) & valMask);
        packShort(buf, off, (int16_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int16_t val = (int16_t)(((int16_t)(int64_t)array[offset++]) & valMask);
        packShort(buf, off, (int16_t)(val << shift));
        off += 2;
        _Intel_Pragma("loop_count min=1, max=6")
        for (int32_t j = 2; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed Int12 data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 12)
 *  @param dSize  (IN)  Data item size in bits (must be 12)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackInt12s (const void *ptr, int32_t off, float *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t skip = (align)? 1 : 0;
  if (sign) {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t a = (int32_t)buf[off++];
      int32_t b = (int32_t)buf[off++];
      int32_t c = (int32_t)buf[off++];
      int32_t x = (a << 4) | ((b >> 4) & 0x000F);
      int32_t y = (b << 8) | ((c     ) & 0x00FF);
      array[offset++] = (float)((x << 20) >> 20); // sign extend
      array[offset++] = (float)((y << 20) >> 20); // sign extend
      off += skip; // skip extra int8_t in processing-efficient mode
    }
  }
  else {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t a = (int32_t)buf[off++];
      int32_t b = (int32_t)buf[off++];
      int32_t c = (int32_t)buf[off++];
      int32_t x = (a << 4) | ((b >> 4) & 0x000F);
      int32_t y = (b << 8) | ((c     ) & 0x00FF);
      array[offset++] = (float)(x & 0x0FFF); // clear high-order bits
      array[offset++] = (float)(y & 0x0FFF); // clear high-order bits
      off += skip; // skip extra int8_t in processing-efficient mode
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for signed Int12 data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 12)
 *  @param dSize  (IN)  Data item size in bits (must be 12)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packInt12s (void *ptr, int32_t off, const float *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t skip = (align)?  1 : 0;
  int32_t mask = (sign )? -1 : ((int32_t)__INT64_C(0xFFFFFFFF));
  for (int32_t i = 0; i < length; i+=2) {
    int32_t first  = ((int32_t)(int64_t)array[offset++]) & mask;
    int32_t second = ((int32_t)(int64_t)array[offset++]) & mask;
    buf[off++] = (int8_t)(first >> 4);
    buf[off++] = (int8_t)((first << 4) | ((second >> 8) & 0x0F));
    buf[off++] = (int8_t)(second);
    off += skip; // skip extra int8_t in processing-efficient mode
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int8_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackBytes (const void *ptr, int32_t off, float *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = fSize / 8; // int8_t offset delta
  if (sign) {
    if (dSize == 8) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (float)unpackByte(buf, off);
      }
    }
    else {
      int32_t shift  = 8 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (float)(unpackByte(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 8) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (float)(unpackByte(buf, off) & __INT64_C(0xFF));
      }
    }
    else {
      int32_t shift  = 8 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (float)((unpackByte(buf, off) & __INT64_C(0xFF)) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int8_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packBytes (void *ptr, int32_t off, const float *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = fSize / 8; // int8_t offset delta
  int8_t valMask = (sign)? ((int8_t)-1) : ((int8_t)__INT64_C(0xFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 8) {
    if (delta == 1) {
      for (int32_t i = 0; i < length; i++,off+=1) {
        int8_t val = (int8_t)(((int8_t)(int64_t)array[offset++]) & valMask);
        packByte(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int8_t val = (int8_t)(((int8_t)(int64_t)array[offset++]) & valMask);
        packByte(buf, off, val);
        off += 1;
        _Intel_Pragma("loop_count min=1, max=7")
        for (int32_t j = 1; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 8 - dSize;
    if (delta == 1) {
      for (int32_t i = 0; i < length; i++,off+=1) {
        int8_t val = (int8_t)(((int8_t)(int64_t)array[offset++]) & valMask);
        packByte(buf, off, (int8_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int8_t val = (int8_t)(((int8_t)(int64_t)array[offset++]) & valMask);
        packByte(buf, off, (int8_t)(val << shift));
        off += 1;
        _Intel_Pragma("loop_count min=1, max=7")
        for (int32_t j = 1; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed Int4 (nibble) data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 4)
 *  @param dSize  (IN)  Data item size in bits (must be 4)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackNibbles (const void *ptr, int32_t off, float *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  if (sign) {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (float)((b << 24) >> 28); // shift & sign extend
      array[offset++] = (float)((b << 28) >> 28); // shift & sign extend
    }
  }
  else {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (float)((b >> 4) & 0xF);
      array[offset++] = (float)((b     ) & 0xF);
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for signed Int4 (nibble) data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 4)
 *  @param dSize  (IN)  Data item size in bits (must be 4)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packNibbles (void *ptr, int32_t off, const float *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Pack function for signed and unsigned are identical for nibble data, hence
  // 'sign' is unused here, but included in function definition for consistency.
  for (int32_t i = 0; i < length; i+=2) {
    int32_t first  = (int32_t)(int64_t)array[offset++];
    int32_t second = (int32_t)(int64_t)array[offset++];
    buf[off++] = (int8_t)((first << 4) | (second & 0xF));
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for bit data. Each bit in the
 *  input buffer will be checked, a 0 bit will correspond to the value 0 and a
 *  1 bit will correspond to the value 1.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
 *  @param fSize  (IN)  Item packing field size in bits (must be 1)
 *  @param dSize  (IN)  Data item size in bits (must be 1)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackBits (const void *ptr, int32_t off, float *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  if (sign) {
    // This uses sign-extending principles to get each bit as 0 or -1 which reflects
    // the fact that 0/-1 and not 0/+1 are the available values in a one-bit use of
    // twos-complement.
    for (int32_t i = 0; i < length; i+=8) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (float)((b << 24) >> 31);
      array[offset++] = (float)((b << 25) >> 31);
      array[offset++] = (float)((b << 26) >> 31);
      array[offset++] = (float)((b << 27) >> 31);
      array[offset++] = (float)((b << 28) >> 31);
      array[offset++] = (float)((b << 29) >> 31);
      array[offset++] = (float)((b << 30) >> 31);
      array[offset++] = (float)((b << 31) >> 31);
    }
  }
  else {
    for (int32_t i = 0; i < length; i+=8) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (float)((b >> 7) & 0x1);
      array[offset++] = (float)((b >> 6) & 0x1);
      array[offset++] = (float)((b >> 5) & 0x1);
      array[offset++] = (float)((b >> 4) & 0x1);
      array[offset++] = (float)((b >> 3) & 0x1);
      array[offset++] = (float)((b >> 2) & 0x1);
      array[offset++] = (float)((b >> 1) & 0x1);
      array[offset++] = (float)((b     ) & 0x1);
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for bit data. Each value in the
 *  input array will be checked, a zero value will correspond to the bit 0 and
 *  any non-zero value will correspond to the bit 1.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
 *  @param fSize  (IN)  Item packing field size in bits (must be 1)
 *  @param dSize  (IN)  Data item size in bits (must be 1)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packBits (void *ptr, int32_t off, const float *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Pack function for signed and unsigned are identical for bit data, hence
  // 'sign' is unused here, but included in function definition for consistency.
  for (int32_t i = 0; i < length; i+=8) {
    int32_t b = 0;
    b |= (((int64_t)array[offset++]) << 7) & 0x80;
    b |= (((int64_t)array[offset++]) << 6) & 0x40;
    b |= (((int64_t)array[offset++]) << 5) & 0x20;
    b |= (((int64_t)array[offset++]) << 4) & 0x10;
    b |= (((int64_t)array[offset++]) << 3) & 0x08;
    b |= (((int64_t)array[offset++]) << 2) & 0x04;
    b |= (((int64_t)array[offset++]) << 1) & 0x02;
    b |= (((int64_t)array[offset++])     ) & 0x01;
    buf[off++] = (int8_t)b;
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array, where the data is
 *  aligned to 32-bit word boundaries.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array  (OUT) Output value array (not null)
 *  @param chan   (OUT) Output channel tag array (null if n/a)
 *  @param evt    (OUT) Output event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntWord32 (const void *ptr, int32_t off, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 32 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int32_t valMask  = (sign)? ((int32_t)-1) : (~(((int32_t)-1) << dSize));
  for (int32_t i = 0; i < length; i++,off+=4) {
    int32_t value = unpackInt(buf, off);
    array[i] = (float)((value >> (32-dSize)) & valMask);
    if (chan != NULL) chan[i] = (value >> (pSize      )) & chanMask;
    if (evt  != NULL) evt[i]  = (value >> (pSize+cSize)) & evtMask;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array, where the data is
 *  aligned to 32-bit word boundaries.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input value array
 *  @param chan   (IN)  Input channel tag array (null if n/a)
 *  @param evt    (IN)  Input event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntWord32 (void *ptr, int32_t off, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 32 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int32_t valMask  = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFFFFFFFF));
  for (int32_t i = 0; i < length; i++,off+=4) {
    int32_t val   = (int32_t)(((int32_t)(int64_t)array[i]) & valMask);
    int32_t value = val << (32-dSize);
    if (chan != NULL) value |= (chan[i] & chanMask) << (pSize);
    if (evt  != NULL) value |= (evt[i]  & evtMask ) << (pSize+cSize);
    packInt(buf, off, value);
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array  (OUT) Output value array (not null)
 *  @param chan   (OUT) Output channel tag array (null if n/a)
 *  @param evt    (OUT) Output event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntWord64 (const void *ptr, int32_t off, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int64_t valMask  = (sign)? ((int64_t)-1) : (~(((int64_t)-1) << dSize));
  if (dSize == 32) {
    // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
    // value, so use 32-bit operations to improve performance
    for (int32_t i = 0; i < length; i++,off+=8) {
      int32_t val   = unpackInt(buf, off);
      int32_t value = unpackInt(buf, off+4);
      array[i] = (float)(val & valMask);
      if (chan != NULL) chan[i] = ((int32_t)(value >> (pSize      ))) & chanMask;
      if (evt  != NULL) evt[i]  = ((int32_t)(value >> (pSize+cSize))) & evtMask;
    }
  }
  else {
    for (int32_t i = 0; i < length; i++,off+=8) {
      int64_t value = unpackLong(buf, off);
      array[i] = (float)((value >> (64-dSize)) & valMask);
      if (chan != NULL) chan[i] = ((int32_t)(value >> (pSize      ))) & chanMask;
      if (evt  != NULL) evt[i]  = ((int32_t)(value >> (pSize+cSize))) & evtMask;
    }
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input value array
 *  @param chan   (IN)  Input channel tag array (null if n/a)
 *  @param evt    (IN)  Input event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntWord64 (void *ptr, int32_t off, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int64_t valMask  = (sign)? ((int64_t)-1) : ((int64_t)__INT64_C(0xFFFFFFFF));
  if (dSize == 32) {
    // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
    // value, so use 32-bit operations to improve performance
    for (int32_t i = 0; i < length; i++,off+=8) {
      int32_t val   = (int32_t)(((int64_t)(int64_t)array[i]) & valMask);
      int32_t value = 0;
      if (chan != NULL) value  = (chan[i] & chanMask) << (pSize);
      if (evt  != NULL) value |= (evt[i]  & evtMask ) << (pSize+cSize);
      packInt(buf, off,   val);
      packInt(buf, off+4, value);
    }
  }
  else {
    for (int32_t i = 0; i < length; i++,off+=8) {
      int64_t val   = (int64_t)(((int64_t)(int64_t)array[i]) & valMask);
      int64_t value = val << (64-dSize);
      if (chan != NULL) value |= ((int64_t)(chan[i] & chanMask)) << (pSize);
      if (evt  != NULL) value |= ((int64_t)(evt[i]  & evtMask )) << (pSize+cSize);
      packLong(buf, off, value);
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array  (OUT) Output value array (not null)
 *  @param chan   (OUT) Output channel tag array (null if n/a)
 *  @param evt    (OUT) Output event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackFloatWord64 (const void *ptr, int32_t off, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  // When using Float32 the first 32-bits will always the the Float32 value, so
  // use 32-bit operations to improve performance
  for (int32_t i = 0; i < length; i++,off+=8) {
    array[i] = (float)unpackFloat(buf, off);
    int32_t value = unpackInt(buf, off+4);
    if (chan != NULL) chan[i] = (value >> (pSize      )) & chanMask;
    if (evt  != NULL) evt[i]  = (value >> (pSize+cSize)) & evtMask;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input value array
 *  @param chan   (IN)  Input channel tag array (null if n/a)
 *  @param evt    (IN)  Input event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packFloatWord64 (void *ptr, int32_t off, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  // When using Float32 the first 32-bits will always the the Float32 value, so
  // use 32-bit operations to improve performance
  for (int32_t i = 0; i < length; i++,off+=8) {
    float val   = (float)array[i];
    int32_t   value = 0;
    if (chan != NULL) value  = (chan[i] & chanMask) << (pSize);
    if (evt  != NULL) value |= (evt[i]  & evtMask ) << (pSize+cSize);
    packFloat(buf, off,   val);
    packInt(  buf, off+4, value);
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntBuffer32 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_dSize  = 32 - dSize;    // pre-compute "32 - dSize" for efficiency
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      if (sign) {
        // sign extend
        array[offset] = (float)((value << _bits_dSize) >>  _bits_dSize);
      }
      else {
        // leave top bits (which default to 0) as 0
        array[offset] = (float)value;
      }
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntBuffer32 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  int32_t valMask      = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t arrayValue = ((int32_t)(int64_t)array[offset]) & valMask;
      int32_t value      = (int32_t)((arrayValue) << (32 - dSize));
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntBuffer64 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_dSize  = 64 - dSize;    // pre-compute "64 - dSize" for efficiency
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      if (sign) {
        // sign extend
        array[offset] = (float)((value << _bits_dSize) >>  _bits_dSize);
      }
      else {
        // leave top bits (which default to 0) as 0
        array[offset] = (float)value;
      }
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntBuffer64 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  int64_t valMask      = (sign)? ((int64_t)-1) : ((int64_t)__INT64_C(0xFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t arrayValue = ((int64_t)(int64_t)array[offset]) & valMask;
      int64_t value      = (int64_t)((arrayValue) << (64 - dSize));
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackFloatBuffer64 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)intBitsToFloat((int32_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packFloatBuffer64 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      float  arrayValue = (float)array[offset];
      int64_t   value      = ((int64_t)floatToRawIntBits(arrayValue)) << 32;
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT1Buffer32 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_SignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT1Buffer32 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT1, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT1Buffer64 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_SignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT1Buffer64 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT1, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT2Buffer32 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_SignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT2Buffer32 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT2, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT2Buffer64 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_SignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT2Buffer64 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT2, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT3Buffer32 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_SignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT3Buffer32 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT3, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT3Buffer64 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_SignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT3Buffer64 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT3, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT4Buffer32 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_SignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT4Buffer32 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT4, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT4Buffer64 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_SignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT4Buffer64 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT4, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT5Buffer32 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_SignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT5Buffer32 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT5, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT5Buffer64 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_SignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT5Buffer64 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT5, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT6Buffer32 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_SignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT6Buffer32 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT6, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT6Buffer64 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_SignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT6Buffer64 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT6, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT1Buffer32 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_UnsignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT1Buffer32 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT1, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT1Buffer64 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_UnsignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT1Buffer64 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT1, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT2Buffer32 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_UnsignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT2Buffer32 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT2, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT2Buffer64 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_UnsignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT2Buffer64 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT2, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT3Buffer32 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_UnsignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT3Buffer32 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT3, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT3Buffer64 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_UnsignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT3Buffer64 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT3, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT4Buffer32 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_UnsignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT4Buffer32 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT4, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT4Buffer64 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_UnsignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT4Buffer64 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT4, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT5Buffer32 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_UnsignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT5Buffer32 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT5, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT5Buffer64 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_UnsignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT5Buffer64 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT5, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT6Buffer32 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_UnsignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT6Buffer32 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT6, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT6Buffer64 (const void *ptr, int32_t bitOffset, float *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (float)fromVRTFloat(DataItemFormat_UnsignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT6Buffer64 (void *ptr, int32_t bitOffset, const float *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT6, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
float* vrt::PackUnpack::unpackAsFloat (PayloadFormat pf, const void *ptr, int32_t off, float *array, int32_t *chan, int32_t *evt, int32_t length) {
  const char *buf = (const char*)ptr;
  if (!pf.isValid()) {
    throw VRTException(pf.getValid());
  }
  int32_t            fSize  = pf.getItemPackingFieldSize();
  int32_t            dSize  = pf.getDataItemSize();
  int32_t            eSize  = pf.getEventTagSize();
  int32_t            cSize  = pf.getChannelTagSize();
  bool        proc   = pf.isProcessingEfficient();
  bool        sign   = pf.isSigned();
  DataItemFormat format = pf.getDataItemFormat();
  bool        noTags;
  if (eSize == 0) evt  = NULL; // no event tags, ignore any array passed in
  if (cSize == 0) chan = NULL; // no channel tags, ignore any array passed in
  noTags = (chan == NULL) && (evt == NULL);
  if (proc && noTags && (fSize >= 17)) {
    // Use faster "effective field size" when ignoring Event & Channel Tags
    fSize = (fSize <= 32)? 32 : 64;
  }
  switch (format) {
    case DataItemFormat_SignedInt:   // FALLTHROUGH
    case DataItemFormat_UnsignedInt:
      // ---- Try fast methods -------------------------------------------------
      if (noTags) {
        switch (fSize) {
          case  8: unpackBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 16: unpackShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 24: unpackInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 32: unpackInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 64: unpackLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
        }
      }
      if (fSize == dSize) { // implicit noTags=true in this case
        switch (fSize) {
          case  1: if ((length % 8) == 0) { unpackBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          case  4: if ((length % 2) == 0) { unpackNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          case 12: if ((length % 2) == 0) { unpackInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
        }
      }
      if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
        if (fSize <= 32) {
          unpackIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      }
      // ---- Fall back to slow method -----------------------------------------
      if (fSize <= 32) {
        unpackIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_Float:
      // ---- Try fast methods -------------------------------------------------
      if (fSize == dSize) { // implicit noTags=true in this case
        unpackFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
      }
      if ((proc && (fSize >= 33)) || (fSize == 64)) {
        unpackFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      // ---- Fall back to slow method -----------------------------------------
      unpackFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
    case DataItemFormat_Double:
      // ---- Only fast method for double (yea!) -------------------------------
      unpackDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
    case DataItemFormat_SignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    default:
      throw VRTException("Unpacking of VRT float types not supported yet");
  }
}
void vrt::PackUnpack::packAsFloat (PayloadFormat pf, void *ptr, int32_t off, const float *array, const int32_t *chan, const int32_t *evt, int32_t length) {
  char *buf = (char*)ptr;
  if (!pf.isValid()) {
    throw VRTException(pf.getValid());
  }
  int32_t            fSize  = pf.getItemPackingFieldSize();
  int32_t            dSize  = pf.getDataItemSize();
  int32_t            eSize  = pf.getEventTagSize();
  int32_t            cSize  = pf.getChannelTagSize();
  bool        proc   = pf.isProcessingEfficient();
  bool        sign   = pf.isSigned();
  DataItemFormat format = pf.getDataItemFormat();
  bool        noTags;
  if (eSize == 0) evt  = NULL; // no event tags, ignore any array passed in
  if (cSize == 0) chan = NULL; // no channel tags, ignore any array passed in
  noTags = (chan == NULL) && (evt == NULL);
  if (proc && noTags && (fSize >= 17)) {
    // Use faster "effective field size" when ignoring Event & Channel Tags
    fSize = (fSize <= 32)? 32 : 64;
  }
  switch (format) {
    case DataItemFormat_SignedInt:   // FALLTHROUGH
    case DataItemFormat_UnsignedInt:
      // ---- Try fast methods -------------------------------------------------
      if (noTags) {
        switch (fSize) {
          case  8: packBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 16: packShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 24: packInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 32: packInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 64: packLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
        }
      }
      if (fSize == dSize) { // implicit noTags=true in this case
        switch (fSize) {
          case  1: if ((length % 8) == 0) { packBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          case  4: if ((length % 2) == 0) { packNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          case 12: if ((length % 2) == 0) { packInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
        }
      }
      if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
        if (fSize <= 32) {
          packIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      }
      // ---- Fall back to slow method -----------------------------------------
      if (fSize <= 32) {
        packIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_Float:
      // ---- Try fast methods -------------------------------------------------
      if (fSize == dSize) { // implicit noTags=true in this case
        packFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
      }
      if ((proc && (fSize >= 33)) || (fSize == 64)) {
        packFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      // ---- Fall back to slow method -----------------------------------------
      packFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
    case DataItemFormat_Double:
      // ---- Only fast method for double (yea!) -------------------------------
      packDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
    case DataItemFormat_SignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    default:
      throw VRTException("Packing of VRT float types not supported yet");
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for double data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 64)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void unpackDoubles (const void *ptr, int32_t off, int64_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  // When using Double data, it is required that dSize=64 and fSize=64 so we can
  // skip some of the normal checks we would otherwise do here.
  for (int32_t i = 0; i < length; i++,off+=8) {
    array[offset++] = (int64_t)unpackDouble(buf, off);
  }
}
/** <b>Internal Use Only:</b>
 *  Fast pack method for double data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 64)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void packDoubles (void *ptr, int32_t off, const int64_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  // When using Double data, it is required that dSize=64 and fSize=64 so we can
  // skip some of the normal checks we would otherwise do here.
  for (int32_t i = 0; i < length; i++,off+=8) {
    packDouble(buf, off, (double)array[offset++]);
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for float data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 32)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void unpackFloats (const void *ptr, int32_t off, int64_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  int32_t delta; // int8_t offset delta
  if (align) delta = (fSize <= 32)? 4 : 8;
  else       delta = fSize / 8;
  for (int32_t i = 0; i < length; i++,off+=delta) {
    array[offset++] = (int64_t)unpackFloat(buf, off);
  }
}
/** <b>Internal Use Only:</b>
 *  Fast pack method for float data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 32)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void packFloats (void *ptr, int32_t off, const int64_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  int32_t delta; // int8_t offset delta
  if (align) delta = (fSize <= 32)? 4 : 8;
  else       delta = fSize / 8;
  if (delta == 4) {
    for (int32_t i = 0; i < length; i++,off+=4) {
      packFloat(buf, off, (float)array[offset++]);
    }
  }
  else {
    for (int32_t i = 0; i < length; i++) {
      packFloat(buf, off, (float)array[offset++]);
      off += 4;
      _Intel_Pragma("loop_count min=1, max=4")
      for (int32_t j = 4; j < delta; j++) {
        buf[off++] = 0; // set unused bits to zero
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int64_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackLongs (const void *ptr, int32_t off, int64_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
#if (8 == 1) || (BYTE_ORDER == BIG_ENDIAN)
  if ((fSize == 64) && (dSize == 64)) {
    // Fast array copy
    memcpy(&array[offset], &buf[off], length*8);
    return;
  }
#endif
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  if (sign) {
    if (dSize == 64) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int64_t)unpackLong(buf, off);
      }
    }
    else {
      int32_t shift  = 64 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int64_t)(unpackLong(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 64) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int64_t)(unpackLong(buf, off) & __INT64_C(0xFFFFFFFFFFFFFFFF));
      }
    }
    else {
      int32_t shift  = 64 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int64_t)((unpackLong(buf, off) & __INT64_C(0xFFFFFFFFFFFFFFFF)) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int64_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packLongs (void *ptr, int32_t off, const int64_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
#if (8 == 1) || (BYTE_ORDER == BIG_ENDIAN)
  if ((fSize == 64) && (dSize == 64)) {
    // Fast array copy
    memcpy(&buf[off], &array[offset], length*8);
    return;
  }
#endif
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  int64_t valMask = (sign)? ((int64_t)-1) : ((int64_t)__INT64_C(0xFFFFFFFFFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 64) {
    if (delta == 8) {
      for (int32_t i = 0; i < length; i++,off+=8) {
        int64_t val = (int64_t)(((int64_t)array[offset++]) & valMask);
        packLong(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int64_t val = (int64_t)(((int64_t)array[offset++]) & valMask);
        packLong(buf, off, val);
        off += 8;
        _Intel_Pragma("loop_count min=1, max=0")
        for (int32_t j = 8; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 64 - dSize;
    if (delta == 8) {
      for (int32_t i = 0; i < length; i++,off+=8) {
        int64_t val = (int64_t)(((int64_t)array[offset++]) & valMask);
        packLong(buf, off, (int64_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int64_t val = (int64_t)(((int64_t)array[offset++]) & valMask);
        packLong(buf, off, (int64_t)(val << shift));
        off += 8;
        _Intel_Pragma("loop_count min=1, max=0")
        for (int32_t j = 8; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int32_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackInts (const void *ptr, int32_t off, int64_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  if (sign) {
    if (dSize == 32) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int64_t)unpackInt(buf, off);
      }
    }
    else {
      int32_t shift  = 32 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int64_t)(unpackInt(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 32) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int64_t)(unpackInt(buf, off) & __INT64_C(0xFFFFFFFF));
      }
    }
    else {
      int32_t shift  = 32 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int64_t)((unpackInt(buf, off) & __INT64_C(0xFFFFFFFF)) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int32_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packInts (void *ptr, int32_t off, const int64_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  int32_t valMask = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFFFFFFFFFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 32) {
    if (delta == 4) {
      for (int32_t i = 0; i < length; i++,off+=4) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt(buf, off, val);
        off += 4;
        _Intel_Pragma("loop_count min=1, max=4")
        for (int32_t j = 4; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 32 - dSize;
    if (delta == 4) {
      for (int32_t i = 0; i < length; i++,off+=4) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt(buf, off, (int32_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt(buf, off, (int32_t)(val << shift));
        off += 4;
        _Intel_Pragma("loop_count min=1, max=4")
        for (int32_t j = 4; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int32_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackInt24s (const void *ptr, int32_t off, int64_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  if (sign) {
    if (dSize == 24) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int64_t)unpackInt24(buf, off);
      }
    }
    else {
      int32_t shift  = 24 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int64_t)(unpackInt24(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 24) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int64_t)(unpackInt24(buf, off) & __INT64_C(0xFFFFFF));
      }
    }
    else {
      int32_t shift  = 24 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int64_t)((unpackInt24(buf, off) & __INT64_C(0xFFFFFF)) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int32_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packInt24s (void *ptr, int32_t off, const int64_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  int32_t valMask = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFFFFFFFFFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 24) {
    if (delta == 3) {
      for (int32_t i = 0; i < length; i++,off+=3) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt24(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt24(buf, off, val);
        off += 3;
        _Intel_Pragma("loop_count min=1, max=5")
        for (int32_t j = 3; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 24 - dSize;
    if (delta == 3) {
      for (int32_t i = 0; i < length; i++,off+=3) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt24(buf, off, (int32_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt24(buf, off, (int32_t)(val << shift));
        off += 3;
        _Intel_Pragma("loop_count min=1, max=5")
        for (int32_t j = 3; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int16_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackShorts (const void *ptr, int32_t off, int64_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = fSize / 8; // int8_t offset delta
  if (sign) {
    if (dSize == 16) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int64_t)unpackShort(buf, off);
      }
    }
    else {
      int32_t shift  = 16 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int64_t)(unpackShort(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 16) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int64_t)(unpackShort(buf, off) & __INT64_C(0xFFFF));
      }
    }
    else {
      int32_t shift  = 16 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int64_t)((unpackShort(buf, off) & __INT64_C(0xFFFF)) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int16_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packShorts (void *ptr, int32_t off, const int64_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = fSize / 8; // int8_t offset delta
  int16_t valMask = (sign)? ((int16_t)-1) : ((int16_t)__INT64_C(0xFFFFFFFFFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 16) {
    if (delta == 2) {
      for (int32_t i = 0; i < length; i++,off+=2) {
        int16_t val = (int16_t)(((int16_t)array[offset++]) & valMask);
        packShort(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int16_t val = (int16_t)(((int16_t)array[offset++]) & valMask);
        packShort(buf, off, val);
        off += 2;
        _Intel_Pragma("loop_count min=1, max=6")
        for (int32_t j = 2; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 16 - dSize;
    if (delta == 2) {
      for (int32_t i = 0; i < length; i++,off+=2) {
        int16_t val = (int16_t)(((int16_t)array[offset++]) & valMask);
        packShort(buf, off, (int16_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int16_t val = (int16_t)(((int16_t)array[offset++]) & valMask);
        packShort(buf, off, (int16_t)(val << shift));
        off += 2;
        _Intel_Pragma("loop_count min=1, max=6")
        for (int32_t j = 2; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed Int12 data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 12)
 *  @param dSize  (IN)  Data item size in bits (must be 12)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackInt12s (const void *ptr, int32_t off, int64_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t skip = (align)? 1 : 0;
  if (sign) {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t a = (int32_t)buf[off++];
      int32_t b = (int32_t)buf[off++];
      int32_t c = (int32_t)buf[off++];
      int32_t x = (a << 4) | ((b >> 4) & 0x000F);
      int32_t y = (b << 8) | ((c     ) & 0x00FF);
      array[offset++] = (int64_t)((x << 20) >> 20); // sign extend
      array[offset++] = (int64_t)((y << 20) >> 20); // sign extend
      off += skip; // skip extra int8_t in processing-efficient mode
    }
  }
  else {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t a = (int32_t)buf[off++];
      int32_t b = (int32_t)buf[off++];
      int32_t c = (int32_t)buf[off++];
      int32_t x = (a << 4) | ((b >> 4) & 0x000F);
      int32_t y = (b << 8) | ((c     ) & 0x00FF);
      array[offset++] = (int64_t)(x & 0x0FFF); // clear high-order bits
      array[offset++] = (int64_t)(y & 0x0FFF); // clear high-order bits
      off += skip; // skip extra int8_t in processing-efficient mode
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for signed Int12 data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 12)
 *  @param dSize  (IN)  Data item size in bits (must be 12)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packInt12s (void *ptr, int32_t off, const int64_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t skip = (align)?  1 : 0;
  int32_t mask = (sign )? -1 : ((int32_t)__INT64_C(0xFFFFFFFFFFFFFFFF));
  for (int32_t i = 0; i < length; i+=2) {
    int32_t first  = ((int32_t)array[offset++]) & mask;
    int32_t second = ((int32_t)array[offset++]) & mask;
    buf[off++] = (int8_t)(first >> 4);
    buf[off++] = (int8_t)((first << 4) | ((second >> 8) & 0x0F));
    buf[off++] = (int8_t)(second);
    off += skip; // skip extra int8_t in processing-efficient mode
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int8_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackBytes (const void *ptr, int32_t off, int64_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = fSize / 8; // int8_t offset delta
  if (sign) {
    if (dSize == 8) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int64_t)unpackByte(buf, off);
      }
    }
    else {
      int32_t shift  = 8 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int64_t)(unpackByte(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 8) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int64_t)(unpackByte(buf, off) & __INT64_C(0xFF));
      }
    }
    else {
      int32_t shift  = 8 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int64_t)((unpackByte(buf, off) & __INT64_C(0xFF)) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int8_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packBytes (void *ptr, int32_t off, const int64_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = fSize / 8; // int8_t offset delta
  int8_t valMask = (sign)? ((int8_t)-1) : ((int8_t)__INT64_C(0xFFFFFFFFFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 8) {
    if (delta == 1) {
      for (int32_t i = 0; i < length; i++,off+=1) {
        int8_t val = (int8_t)(((int8_t)array[offset++]) & valMask);
        packByte(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int8_t val = (int8_t)(((int8_t)array[offset++]) & valMask);
        packByte(buf, off, val);
        off += 1;
        _Intel_Pragma("loop_count min=1, max=7")
        for (int32_t j = 1; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 8 - dSize;
    if (delta == 1) {
      for (int32_t i = 0; i < length; i++,off+=1) {
        int8_t val = (int8_t)(((int8_t)array[offset++]) & valMask);
        packByte(buf, off, (int8_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int8_t val = (int8_t)(((int8_t)array[offset++]) & valMask);
        packByte(buf, off, (int8_t)(val << shift));
        off += 1;
        _Intel_Pragma("loop_count min=1, max=7")
        for (int32_t j = 1; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed Int4 (nibble) data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 4)
 *  @param dSize  (IN)  Data item size in bits (must be 4)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackNibbles (const void *ptr, int32_t off, int64_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  if (sign) {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (int64_t)((b << 24) >> 28); // shift & sign extend
      array[offset++] = (int64_t)((b << 28) >> 28); // shift & sign extend
    }
  }
  else {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (int64_t)((b >> 4) & 0xF);
      array[offset++] = (int64_t)((b     ) & 0xF);
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for signed Int4 (nibble) data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 4)
 *  @param dSize  (IN)  Data item size in bits (must be 4)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packNibbles (void *ptr, int32_t off, const int64_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Pack function for signed and unsigned are identical for nibble data, hence
  // 'sign' is unused here, but included in function definition for consistency.
  for (int32_t i = 0; i < length; i+=2) {
    int32_t first  = (int32_t)array[offset++];
    int32_t second = (int32_t)array[offset++];
    buf[off++] = (int8_t)((first << 4) | (second & 0xF));
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for bit data. Each bit in the
 *  input buffer will be checked, a 0 bit will correspond to the value 0 and a
 *  1 bit will correspond to the value 1.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
 *  @param fSize  (IN)  Item packing field size in bits (must be 1)
 *  @param dSize  (IN)  Data item size in bits (must be 1)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackBits (const void *ptr, int32_t off, int64_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  if (sign) {
    // This uses sign-extending principles to get each bit as 0 or -1 which reflects
    // the fact that 0/-1 and not 0/+1 are the available values in a one-bit use of
    // twos-complement.
    for (int32_t i = 0; i < length; i+=8) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (int64_t)((b << 24) >> 31);
      array[offset++] = (int64_t)((b << 25) >> 31);
      array[offset++] = (int64_t)((b << 26) >> 31);
      array[offset++] = (int64_t)((b << 27) >> 31);
      array[offset++] = (int64_t)((b << 28) >> 31);
      array[offset++] = (int64_t)((b << 29) >> 31);
      array[offset++] = (int64_t)((b << 30) >> 31);
      array[offset++] = (int64_t)((b << 31) >> 31);
    }
  }
  else {
    for (int32_t i = 0; i < length; i+=8) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (int64_t)((b >> 7) & 0x1);
      array[offset++] = (int64_t)((b >> 6) & 0x1);
      array[offset++] = (int64_t)((b >> 5) & 0x1);
      array[offset++] = (int64_t)((b >> 4) & 0x1);
      array[offset++] = (int64_t)((b >> 3) & 0x1);
      array[offset++] = (int64_t)((b >> 2) & 0x1);
      array[offset++] = (int64_t)((b >> 1) & 0x1);
      array[offset++] = (int64_t)((b     ) & 0x1);
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for bit data. Each value in the
 *  input array will be checked, a zero value will correspond to the bit 0 and
 *  any non-zero value will correspond to the bit 1.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
 *  @param fSize  (IN)  Item packing field size in bits (must be 1)
 *  @param dSize  (IN)  Data item size in bits (must be 1)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packBits (void *ptr, int32_t off, const int64_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Pack function for signed and unsigned are identical for bit data, hence
  // 'sign' is unused here, but included in function definition for consistency.
  for (int32_t i = 0; i < length; i+=8) {
    int32_t b = 0;
    b |= (((int64_t)array[offset++]) << 7) & 0x80;
    b |= (((int64_t)array[offset++]) << 6) & 0x40;
    b |= (((int64_t)array[offset++]) << 5) & 0x20;
    b |= (((int64_t)array[offset++]) << 4) & 0x10;
    b |= (((int64_t)array[offset++]) << 3) & 0x08;
    b |= (((int64_t)array[offset++]) << 2) & 0x04;
    b |= (((int64_t)array[offset++]) << 1) & 0x02;
    b |= (((int64_t)array[offset++])     ) & 0x01;
    buf[off++] = (int8_t)b;
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array, where the data is
 *  aligned to 32-bit word boundaries.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array  (OUT) Output value array (not null)
 *  @param chan   (OUT) Output channel tag array (null if n/a)
 *  @param evt    (OUT) Output event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntWord32 (const void *ptr, int32_t off, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 32 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int32_t valMask  = (sign)? ((int32_t)-1) : (~(((int32_t)-1) << dSize));
  for (int32_t i = 0; i < length; i++,off+=4) {
    int32_t value = unpackInt(buf, off);
    array[i] = (int64_t)((value >> (32-dSize)) & valMask);
    if (chan != NULL) chan[i] = (value >> (pSize      )) & chanMask;
    if (evt  != NULL) evt[i]  = (value >> (pSize+cSize)) & evtMask;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array, where the data is
 *  aligned to 32-bit word boundaries.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input value array
 *  @param chan   (IN)  Input channel tag array (null if n/a)
 *  @param evt    (IN)  Input event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntWord32 (void *ptr, int32_t off, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 32 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int32_t valMask  = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFFFFFFFFFFFFFFFF));
  for (int32_t i = 0; i < length; i++,off+=4) {
    int32_t val   = (int32_t)(((int32_t)array[i]) & valMask);
    int32_t value = val << (32-dSize);
    if (chan != NULL) value |= (chan[i] & chanMask) << (pSize);
    if (evt  != NULL) value |= (evt[i]  & evtMask ) << (pSize+cSize);
    packInt(buf, off, value);
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array  (OUT) Output value array (not null)
 *  @param chan   (OUT) Output channel tag array (null if n/a)
 *  @param evt    (OUT) Output event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntWord64 (const void *ptr, int32_t off, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int64_t valMask  = (sign)? ((int64_t)-1) : (~(((int64_t)-1) << dSize));
  if (dSize == 32) {
    // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
    // value, so use 32-bit operations to improve performance
    for (int32_t i = 0; i < length; i++,off+=8) {
      int32_t val   = unpackInt(buf, off);
      int32_t value = unpackInt(buf, off+4);
      array[i] = (int64_t)(val & valMask);
      if (chan != NULL) chan[i] = ((int32_t)(value >> (pSize      ))) & chanMask;
      if (evt  != NULL) evt[i]  = ((int32_t)(value >> (pSize+cSize))) & evtMask;
    }
  }
  else {
    for (int32_t i = 0; i < length; i++,off+=8) {
      int64_t value = unpackLong(buf, off);
      array[i] = (int64_t)((value >> (64-dSize)) & valMask);
      if (chan != NULL) chan[i] = ((int32_t)(value >> (pSize      ))) & chanMask;
      if (evt  != NULL) evt[i]  = ((int32_t)(value >> (pSize+cSize))) & evtMask;
    }
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input value array
 *  @param chan   (IN)  Input channel tag array (null if n/a)
 *  @param evt    (IN)  Input event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntWord64 (void *ptr, int32_t off, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int64_t valMask  = (sign)? ((int64_t)-1) : ((int64_t)__INT64_C(0xFFFFFFFFFFFFFFFF));
  if (dSize == 32) {
    // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
    // value, so use 32-bit operations to improve performance
    for (int32_t i = 0; i < length; i++,off+=8) {
      int32_t val   = (int32_t)(((int64_t)array[i]) & valMask);
      int32_t value = 0;
      if (chan != NULL) value  = (chan[i] & chanMask) << (pSize);
      if (evt  != NULL) value |= (evt[i]  & evtMask ) << (pSize+cSize);
      packInt(buf, off,   val);
      packInt(buf, off+4, value);
    }
  }
  else {
    for (int32_t i = 0; i < length; i++,off+=8) {
      int64_t val   = (int64_t)(((int64_t)array[i]) & valMask);
      int64_t value = val << (64-dSize);
      if (chan != NULL) value |= ((int64_t)(chan[i] & chanMask)) << (pSize);
      if (evt  != NULL) value |= ((int64_t)(evt[i]  & evtMask )) << (pSize+cSize);
      packLong(buf, off, value);
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array  (OUT) Output value array (not null)
 *  @param chan   (OUT) Output channel tag array (null if n/a)
 *  @param evt    (OUT) Output event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackFloatWord64 (const void *ptr, int32_t off, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  // When using Float32 the first 32-bits will always the the Float32 value, so
  // use 32-bit operations to improve performance
  for (int32_t i = 0; i < length; i++,off+=8) {
    array[i] = (int64_t)unpackFloat(buf, off);
    int32_t value = unpackInt(buf, off+4);
    if (chan != NULL) chan[i] = (value >> (pSize      )) & chanMask;
    if (evt  != NULL) evt[i]  = (value >> (pSize+cSize)) & evtMask;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input value array
 *  @param chan   (IN)  Input channel tag array (null if n/a)
 *  @param evt    (IN)  Input event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packFloatWord64 (void *ptr, int32_t off, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  // When using Float32 the first 32-bits will always the the Float32 value, so
  // use 32-bit operations to improve performance
  for (int32_t i = 0; i < length; i++,off+=8) {
    float val   = (float)array[i];
    int32_t   value = 0;
    if (chan != NULL) value  = (chan[i] & chanMask) << (pSize);
    if (evt  != NULL) value |= (evt[i]  & evtMask ) << (pSize+cSize);
    packFloat(buf, off,   val);
    packInt(  buf, off+4, value);
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntBuffer32 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_dSize  = 32 - dSize;    // pre-compute "32 - dSize" for efficiency
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      if (sign) {
        // sign extend
        array[offset] = (int64_t)((value << _bits_dSize) >>  _bits_dSize);
      }
      else {
        // leave top bits (which default to 0) as 0
        array[offset] = (int64_t)value;
      }
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntBuffer32 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  int32_t valMask      = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFFFFFFFFFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t arrayValue = ((int32_t)array[offset]) & valMask;
      int32_t value      = (int32_t)((arrayValue) << (32 - dSize));
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntBuffer64 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_dSize  = 64 - dSize;    // pre-compute "64 - dSize" for efficiency
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      if (sign) {
        // sign extend
        array[offset] = (int64_t)((value << _bits_dSize) >>  _bits_dSize);
      }
      else {
        // leave top bits (which default to 0) as 0
        array[offset] = (int64_t)value;
      }
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntBuffer64 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  int64_t valMask      = (sign)? ((int64_t)-1) : ((int64_t)__INT64_C(0xFFFFFFFFFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t arrayValue = ((int64_t)array[offset]) & valMask;
      int64_t value      = (int64_t)((arrayValue) << (64 - dSize));
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackFloatBuffer64 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)intBitsToFloat((int32_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packFloatBuffer64 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      float  arrayValue = (float)array[offset];
      int64_t   value      = ((int64_t)floatToRawIntBits(arrayValue)) << 32;
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT1Buffer32 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_SignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT1Buffer32 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT1, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT1Buffer64 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_SignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT1Buffer64 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT1, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT2Buffer32 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_SignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT2Buffer32 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT2, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT2Buffer64 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_SignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT2Buffer64 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT2, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT3Buffer32 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_SignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT3Buffer32 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT3, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT3Buffer64 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_SignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT3Buffer64 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT3, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT4Buffer32 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_SignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT4Buffer32 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT4, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT4Buffer64 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_SignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT4Buffer64 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT4, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT5Buffer32 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_SignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT5Buffer32 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT5, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT5Buffer64 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_SignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT5Buffer64 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT5, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT6Buffer32 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_SignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT6Buffer32 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT6, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT6Buffer64 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_SignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT6Buffer64 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT6, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT1Buffer32 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_UnsignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT1Buffer32 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT1, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT1Buffer64 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_UnsignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT1Buffer64 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT1, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT2Buffer32 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_UnsignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT2Buffer32 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT2, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT2Buffer64 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_UnsignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT2Buffer64 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT2, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT3Buffer32 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_UnsignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT3Buffer32 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT3, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT3Buffer64 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_UnsignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT3Buffer64 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT3, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT4Buffer32 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_UnsignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT4Buffer32 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT4, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT4Buffer64 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_UnsignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT4Buffer64 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT4, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT5Buffer32 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_UnsignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT5Buffer32 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT5, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT5Buffer64 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_UnsignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT5Buffer64 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT5, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT6Buffer32 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_UnsignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT6Buffer32 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT6, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT6Buffer64 (const void *ptr, int32_t bitOffset, int64_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int64_t)fromVRTFloat(DataItemFormat_UnsignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT6Buffer64 (void *ptr, int32_t bitOffset, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT6, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
int64_t* vrt::PackUnpack::unpackAsLong (PayloadFormat pf, const void *ptr, int32_t off, int64_t *array, int32_t *chan, int32_t *evt, int32_t length) {
  const char *buf = (const char*)ptr;
  if (!pf.isValid()) {
    throw VRTException(pf.getValid());
  }
  int32_t            fSize  = pf.getItemPackingFieldSize();
  int32_t            dSize  = pf.getDataItemSize();
  int32_t            eSize  = pf.getEventTagSize();
  int32_t            cSize  = pf.getChannelTagSize();
  bool        proc   = pf.isProcessingEfficient();
  bool        sign   = pf.isSigned();
  DataItemFormat format = pf.getDataItemFormat();
  bool        noTags;
  if (eSize == 0) evt  = NULL; // no event tags, ignore any array passed in
  if (cSize == 0) chan = NULL; // no channel tags, ignore any array passed in
  noTags = (chan == NULL) && (evt == NULL);
  if (proc && noTags && (fSize >= 17)) {
    // Use faster "effective field size" when ignoring Event & Channel Tags
    fSize = (fSize <= 32)? 32 : 64;
  }
  switch (format) {
    case DataItemFormat_SignedInt:   // FALLTHROUGH
    case DataItemFormat_UnsignedInt:
      // ---- Try fast methods -------------------------------------------------
      if (noTags) {
        switch (fSize) {
          case  8: unpackBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 16: unpackShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 24: unpackInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 32: unpackInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 64: unpackLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
        }
      }
      if (fSize == dSize) { // implicit noTags=true in this case
        switch (fSize) {
          case  1: if ((length % 8) == 0) { unpackBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          case  4: if ((length % 2) == 0) { unpackNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          case 12: if ((length % 2) == 0) { unpackInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
        }
      }
      if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
        if (fSize <= 32) {
          unpackIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      }
      // ---- Fall back to slow method -----------------------------------------
      if (fSize <= 32) {
        unpackIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_Float:
      // ---- Try fast methods -------------------------------------------------
      if (fSize == dSize) { // implicit noTags=true in this case
        unpackFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
      }
      if ((proc && (fSize >= 33)) || (fSize == 64)) {
        unpackFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      // ---- Fall back to slow method -----------------------------------------
      unpackFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
    case DataItemFormat_Double:
      // ---- Only fast method for double (yea!) -------------------------------
      unpackDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
    case DataItemFormat_SignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    default:
      throw VRTException("Unpacking of VRT float types not supported yet");
  }
}
void vrt::PackUnpack::packAsLong (PayloadFormat pf, void *ptr, int32_t off, const int64_t *array, const int32_t *chan, const int32_t *evt, int32_t length) {
  char *buf = (char*)ptr;
  if (!pf.isValid()) {
    throw VRTException(pf.getValid());
  }
  int32_t            fSize  = pf.getItemPackingFieldSize();
  int32_t            dSize  = pf.getDataItemSize();
  int32_t            eSize  = pf.getEventTagSize();
  int32_t            cSize  = pf.getChannelTagSize();
  bool        proc   = pf.isProcessingEfficient();
  bool        sign   = pf.isSigned();
  DataItemFormat format = pf.getDataItemFormat();
  bool        noTags;
  if (eSize == 0) evt  = NULL; // no event tags, ignore any array passed in
  if (cSize == 0) chan = NULL; // no channel tags, ignore any array passed in
  noTags = (chan == NULL) && (evt == NULL);
  if (proc && noTags && (fSize >= 17)) {
    // Use faster "effective field size" when ignoring Event & Channel Tags
    fSize = (fSize <= 32)? 32 : 64;
  }
  switch (format) {
    case DataItemFormat_SignedInt:   // FALLTHROUGH
    case DataItemFormat_UnsignedInt:
      // ---- Try fast methods -------------------------------------------------
      if (noTags) {
        switch (fSize) {
          case  8: packBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 16: packShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 24: packInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 32: packInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 64: packLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
        }
      }
      if (fSize == dSize) { // implicit noTags=true in this case
        switch (fSize) {
          case  1: if ((length % 8) == 0) { packBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          case  4: if ((length % 2) == 0) { packNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          case 12: if ((length % 2) == 0) { packInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
        }
      }
      if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
        if (fSize <= 32) {
          packIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      }
      // ---- Fall back to slow method -----------------------------------------
      if (fSize <= 32) {
        packIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_Float:
      // ---- Try fast methods -------------------------------------------------
      if (fSize == dSize) { // implicit noTags=true in this case
        packFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
      }
      if ((proc && (fSize >= 33)) || (fSize == 64)) {
        packFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      // ---- Fall back to slow method -----------------------------------------
      packFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
    case DataItemFormat_Double:
      // ---- Only fast method for double (yea!) -------------------------------
      packDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
    case DataItemFormat_SignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    default:
      throw VRTException("Packing of VRT float types not supported yet");
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for double data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 64)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void unpackDoubles (const void *ptr, int32_t off, int32_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  // When using Double data, it is required that dSize=64 and fSize=64 so we can
  // skip some of the normal checks we would otherwise do here.
  for (int32_t i = 0; i < length; i++,off+=8) {
    array[offset++] = (int32_t)unpackDouble(buf, off);
  }
}
/** <b>Internal Use Only:</b>
 *  Fast pack method for double data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 64)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void packDoubles (void *ptr, int32_t off, const int32_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  // When using Double data, it is required that dSize=64 and fSize=64 so we can
  // skip some of the normal checks we would otherwise do here.
  for (int32_t i = 0; i < length; i++,off+=8) {
    packDouble(buf, off, (double)array[offset++]);
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for float data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 32)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void unpackFloats (const void *ptr, int32_t off, int32_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  int32_t delta; // int8_t offset delta
  if (align) delta = (fSize <= 32)? 4 : 8;
  else       delta = fSize / 8;
  for (int32_t i = 0; i < length; i++,off+=delta) {
    array[offset++] = (int32_t)unpackFloat(buf, off);
  }
}
/** <b>Internal Use Only:</b>
 *  Fast pack method for float data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 32)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void packFloats (void *ptr, int32_t off, const int32_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  int32_t delta; // int8_t offset delta
  if (align) delta = (fSize <= 32)? 4 : 8;
  else       delta = fSize / 8;
  if (delta == 4) {
    for (int32_t i = 0; i < length; i++,off+=4) {
      packFloat(buf, off, (float)array[offset++]);
    }
  }
  else {
    for (int32_t i = 0; i < length; i++) {
      packFloat(buf, off, (float)array[offset++]);
      off += 4;
      _Intel_Pragma("loop_count min=1, max=4")
      for (int32_t j = 4; j < delta; j++) {
        buf[off++] = 0; // set unused bits to zero
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int64_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackLongs (const void *ptr, int32_t off, int32_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  if (sign) {
    if (dSize == 64) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int32_t)unpackLong(buf, off);
      }
    }
    else {
      int32_t shift  = 64 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int32_t)(unpackLong(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 64) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int32_t)(unpackLong(buf, off) & __INT64_C(0xFFFFFFFFFFFFFFFF));
      }
    }
    else {
      int32_t shift  = 64 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int32_t)((unpackLong(buf, off) & __INT64_C(0xFFFFFFFFFFFFFFFF)) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int64_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packLongs (void *ptr, int32_t off, const int32_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  int64_t valMask = (sign)? ((int64_t)-1) : ((int64_t)__INT64_C(0xFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 64) {
    if (delta == 8) {
      for (int32_t i = 0; i < length; i++,off+=8) {
        int64_t val = (int64_t)(((int64_t)array[offset++]) & valMask);
        packLong(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int64_t val = (int64_t)(((int64_t)array[offset++]) & valMask);
        packLong(buf, off, val);
        off += 8;
        _Intel_Pragma("loop_count min=1, max=0")
        for (int32_t j = 8; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 64 - dSize;
    if (delta == 8) {
      for (int32_t i = 0; i < length; i++,off+=8) {
        int64_t val = (int64_t)(((int64_t)array[offset++]) & valMask);
        packLong(buf, off, (int64_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int64_t val = (int64_t)(((int64_t)array[offset++]) & valMask);
        packLong(buf, off, (int64_t)(val << shift));
        off += 8;
        _Intel_Pragma("loop_count min=1, max=0")
        for (int32_t j = 8; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int32_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackInts (const void *ptr, int32_t off, int32_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
#if (4 == 1) || (BYTE_ORDER == BIG_ENDIAN)
  if ((fSize == 32) && (dSize == 32)) {
    // Fast array copy
    memcpy(&array[offset], &buf[off], length*4);
    return;
  }
#endif
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  if (sign) {
    if (dSize == 32) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int32_t)unpackInt(buf, off);
      }
    }
    else {
      int32_t shift  = 32 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int32_t)(unpackInt(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 32) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int32_t)(unpackInt(buf, off) & 0xFFFFFFFF);
      }
    }
    else {
      int32_t shift  = 32 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int32_t)((unpackInt(buf, off) & 0xFFFFFFFF) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int32_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packInts (void *ptr, int32_t off, const int32_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
#if (4 == 1) || (BYTE_ORDER == BIG_ENDIAN)
  if ((fSize == 32) && (dSize == 32)) {
    // Fast array copy
    memcpy(&buf[off], &array[offset], length*4);
    return;
  }
#endif
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  int32_t valMask = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 32) {
    if (delta == 4) {
      for (int32_t i = 0; i < length; i++,off+=4) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt(buf, off, val);
        off += 4;
        _Intel_Pragma("loop_count min=1, max=4")
        for (int32_t j = 4; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 32 - dSize;
    if (delta == 4) {
      for (int32_t i = 0; i < length; i++,off+=4) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt(buf, off, (int32_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt(buf, off, (int32_t)(val << shift));
        off += 4;
        _Intel_Pragma("loop_count min=1, max=4")
        for (int32_t j = 4; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int32_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackInt24s (const void *ptr, int32_t off, int32_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  if (sign) {
    if (dSize == 24) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int32_t)unpackInt24(buf, off);
      }
    }
    else {
      int32_t shift  = 24 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int32_t)(unpackInt24(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 24) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int32_t)(unpackInt24(buf, off) & 0xFFFFFF);
      }
    }
    else {
      int32_t shift  = 24 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int32_t)((unpackInt24(buf, off) & 0xFFFFFF) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int32_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packInt24s (void *ptr, int32_t off, const int32_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  int32_t valMask = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 24) {
    if (delta == 3) {
      for (int32_t i = 0; i < length; i++,off+=3) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt24(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt24(buf, off, val);
        off += 3;
        _Intel_Pragma("loop_count min=1, max=5")
        for (int32_t j = 3; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 24 - dSize;
    if (delta == 3) {
      for (int32_t i = 0; i < length; i++,off+=3) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt24(buf, off, (int32_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt24(buf, off, (int32_t)(val << shift));
        off += 3;
        _Intel_Pragma("loop_count min=1, max=5")
        for (int32_t j = 3; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int16_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackShorts (const void *ptr, int32_t off, int32_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = fSize / 8; // int8_t offset delta
  if (sign) {
    if (dSize == 16) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int32_t)unpackShort(buf, off);
      }
    }
    else {
      int32_t shift  = 16 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int32_t)(unpackShort(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 16) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int32_t)(unpackShort(buf, off) & 0xFFFF);
      }
    }
    else {
      int32_t shift  = 16 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int32_t)((unpackShort(buf, off) & 0xFFFF) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int16_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packShorts (void *ptr, int32_t off, const int32_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = fSize / 8; // int8_t offset delta
  int16_t valMask = (sign)? ((int16_t)-1) : ((int16_t)__INT64_C(0xFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 16) {
    if (delta == 2) {
      for (int32_t i = 0; i < length; i++,off+=2) {
        int16_t val = (int16_t)(((int16_t)array[offset++]) & valMask);
        packShort(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int16_t val = (int16_t)(((int16_t)array[offset++]) & valMask);
        packShort(buf, off, val);
        off += 2;
        _Intel_Pragma("loop_count min=1, max=6")
        for (int32_t j = 2; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 16 - dSize;
    if (delta == 2) {
      for (int32_t i = 0; i < length; i++,off+=2) {
        int16_t val = (int16_t)(((int16_t)array[offset++]) & valMask);
        packShort(buf, off, (int16_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int16_t val = (int16_t)(((int16_t)array[offset++]) & valMask);
        packShort(buf, off, (int16_t)(val << shift));
        off += 2;
        _Intel_Pragma("loop_count min=1, max=6")
        for (int32_t j = 2; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed Int12 data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 12)
 *  @param dSize  (IN)  Data item size in bits (must be 12)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackInt12s (const void *ptr, int32_t off, int32_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t skip = (align)? 1 : 0;
  if (sign) {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t a = (int32_t)buf[off++];
      int32_t b = (int32_t)buf[off++];
      int32_t c = (int32_t)buf[off++];
      int32_t x = (a << 4) | ((b >> 4) & 0x000F);
      int32_t y = (b << 8) | ((c     ) & 0x00FF);
      array[offset++] = (int32_t)((x << 20) >> 20); // sign extend
      array[offset++] = (int32_t)((y << 20) >> 20); // sign extend
      off += skip; // skip extra int8_t in processing-efficient mode
    }
  }
  else {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t a = (int32_t)buf[off++];
      int32_t b = (int32_t)buf[off++];
      int32_t c = (int32_t)buf[off++];
      int32_t x = (a << 4) | ((b >> 4) & 0x000F);
      int32_t y = (b << 8) | ((c     ) & 0x00FF);
      array[offset++] = (int32_t)(x & 0x0FFF); // clear high-order bits
      array[offset++] = (int32_t)(y & 0x0FFF); // clear high-order bits
      off += skip; // skip extra int8_t in processing-efficient mode
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for signed Int12 data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 12)
 *  @param dSize  (IN)  Data item size in bits (must be 12)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packInt12s (void *ptr, int32_t off, const int32_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t skip = (align)?  1 : 0;
  int32_t mask = (sign )? -1 : ((int32_t)__INT64_C(0xFFFFFFFF));
  for (int32_t i = 0; i < length; i+=2) {
    int32_t first  = ((int32_t)array[offset++]) & mask;
    int32_t second = ((int32_t)array[offset++]) & mask;
    buf[off++] = (int8_t)(first >> 4);
    buf[off++] = (int8_t)((first << 4) | ((second >> 8) & 0x0F));
    buf[off++] = (int8_t)(second);
    off += skip; // skip extra int8_t in processing-efficient mode
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int8_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackBytes (const void *ptr, int32_t off, int32_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = fSize / 8; // int8_t offset delta
  if (sign) {
    if (dSize == 8) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int32_t)unpackByte(buf, off);
      }
    }
    else {
      int32_t shift  = 8 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int32_t)(unpackByte(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 8) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int32_t)(unpackByte(buf, off) & 0xFF);
      }
    }
    else {
      int32_t shift  = 8 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int32_t)((unpackByte(buf, off) & 0xFF) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int8_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packBytes (void *ptr, int32_t off, const int32_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = fSize / 8; // int8_t offset delta
  int8_t valMask = (sign)? ((int8_t)-1) : ((int8_t)__INT64_C(0xFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 8) {
    if (delta == 1) {
      for (int32_t i = 0; i < length; i++,off+=1) {
        int8_t val = (int8_t)(((int8_t)array[offset++]) & valMask);
        packByte(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int8_t val = (int8_t)(((int8_t)array[offset++]) & valMask);
        packByte(buf, off, val);
        off += 1;
        _Intel_Pragma("loop_count min=1, max=7")
        for (int32_t j = 1; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 8 - dSize;
    if (delta == 1) {
      for (int32_t i = 0; i < length; i++,off+=1) {
        int8_t val = (int8_t)(((int8_t)array[offset++]) & valMask);
        packByte(buf, off, (int8_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int8_t val = (int8_t)(((int8_t)array[offset++]) & valMask);
        packByte(buf, off, (int8_t)(val << shift));
        off += 1;
        _Intel_Pragma("loop_count min=1, max=7")
        for (int32_t j = 1; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed Int4 (nibble) data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 4)
 *  @param dSize  (IN)  Data item size in bits (must be 4)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackNibbles (const void *ptr, int32_t off, int32_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  if (sign) {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (int32_t)((b << 24) >> 28); // shift & sign extend
      array[offset++] = (int32_t)((b << 28) >> 28); // shift & sign extend
    }
  }
  else {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (int32_t)((b >> 4) & 0xF);
      array[offset++] = (int32_t)((b     ) & 0xF);
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for signed Int4 (nibble) data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 4)
 *  @param dSize  (IN)  Data item size in bits (must be 4)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packNibbles (void *ptr, int32_t off, const int32_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Pack function for signed and unsigned are identical for nibble data, hence
  // 'sign' is unused here, but included in function definition for consistency.
  for (int32_t i = 0; i < length; i+=2) {
    int32_t first  = (int32_t)array[offset++];
    int32_t second = (int32_t)array[offset++];
    buf[off++] = (int8_t)((first << 4) | (second & 0xF));
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for bit data. Each bit in the
 *  input buffer will be checked, a 0 bit will correspond to the value 0 and a
 *  1 bit will correspond to the value 1.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
 *  @param fSize  (IN)  Item packing field size in bits (must be 1)
 *  @param dSize  (IN)  Data item size in bits (must be 1)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackBits (const void *ptr, int32_t off, int32_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  if (sign) {
    // This uses sign-extending principles to get each bit as 0 or -1 which reflects
    // the fact that 0/-1 and not 0/+1 are the available values in a one-bit use of
    // twos-complement.
    for (int32_t i = 0; i < length; i+=8) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (int32_t)((b << 24) >> 31);
      array[offset++] = (int32_t)((b << 25) >> 31);
      array[offset++] = (int32_t)((b << 26) >> 31);
      array[offset++] = (int32_t)((b << 27) >> 31);
      array[offset++] = (int32_t)((b << 28) >> 31);
      array[offset++] = (int32_t)((b << 29) >> 31);
      array[offset++] = (int32_t)((b << 30) >> 31);
      array[offset++] = (int32_t)((b << 31) >> 31);
    }
  }
  else {
    for (int32_t i = 0; i < length; i+=8) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (int32_t)((b >> 7) & 0x1);
      array[offset++] = (int32_t)((b >> 6) & 0x1);
      array[offset++] = (int32_t)((b >> 5) & 0x1);
      array[offset++] = (int32_t)((b >> 4) & 0x1);
      array[offset++] = (int32_t)((b >> 3) & 0x1);
      array[offset++] = (int32_t)((b >> 2) & 0x1);
      array[offset++] = (int32_t)((b >> 1) & 0x1);
      array[offset++] = (int32_t)((b     ) & 0x1);
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for bit data. Each value in the
 *  input array will be checked, a zero value will correspond to the bit 0 and
 *  any non-zero value will correspond to the bit 1.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
 *  @param fSize  (IN)  Item packing field size in bits (must be 1)
 *  @param dSize  (IN)  Data item size in bits (must be 1)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packBits (void *ptr, int32_t off, const int32_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Pack function for signed and unsigned are identical for bit data, hence
  // 'sign' is unused here, but included in function definition for consistency.
  for (int32_t i = 0; i < length; i+=8) {
    int32_t b = 0;
    b |= (((int32_t)array[offset++]) << 7) & 0x80;
    b |= (((int32_t)array[offset++]) << 6) & 0x40;
    b |= (((int32_t)array[offset++]) << 5) & 0x20;
    b |= (((int32_t)array[offset++]) << 4) & 0x10;
    b |= (((int32_t)array[offset++]) << 3) & 0x08;
    b |= (((int32_t)array[offset++]) << 2) & 0x04;
    b |= (((int32_t)array[offset++]) << 1) & 0x02;
    b |= (((int32_t)array[offset++])     ) & 0x01;
    buf[off++] = (int8_t)b;
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array, where the data is
 *  aligned to 32-bit word boundaries.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array  (OUT) Output value array (not null)
 *  @param chan   (OUT) Output channel tag array (null if n/a)
 *  @param evt    (OUT) Output event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntWord32 (const void *ptr, int32_t off, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 32 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int32_t valMask  = (sign)? ((int32_t)-1) : (~(((int32_t)-1) << dSize));
  for (int32_t i = 0; i < length; i++,off+=4) {
    int32_t value = unpackInt(buf, off);
    array[i] = (int32_t)((value >> (32-dSize)) & valMask);
    if (chan != NULL) chan[i] = (value >> (pSize      )) & chanMask;
    if (evt  != NULL) evt[i]  = (value >> (pSize+cSize)) & evtMask;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array, where the data is
 *  aligned to 32-bit word boundaries.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input value array
 *  @param chan   (IN)  Input channel tag array (null if n/a)
 *  @param evt    (IN)  Input event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntWord32 (void *ptr, int32_t off, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 32 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int32_t valMask  = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFFFFFFFF));
  for (int32_t i = 0; i < length; i++,off+=4) {
    int32_t val   = (int32_t)(((int32_t)array[i]) & valMask);
    int32_t value = val << (32-dSize);
    if (chan != NULL) value |= (chan[i] & chanMask) << (pSize);
    if (evt  != NULL) value |= (evt[i]  & evtMask ) << (pSize+cSize);
    packInt(buf, off, value);
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array  (OUT) Output value array (not null)
 *  @param chan   (OUT) Output channel tag array (null if n/a)
 *  @param evt    (OUT) Output event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntWord64 (const void *ptr, int32_t off, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int64_t valMask  = (sign)? ((int64_t)-1) : (~(((int64_t)-1) << dSize));
  if (dSize == 32) {
    // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
    // value, so use 32-bit operations to improve performance
    for (int32_t i = 0; i < length; i++,off+=8) {
      int32_t val   = unpackInt(buf, off);
      int32_t value = unpackInt(buf, off+4);
      array[i] = (int32_t)(val & valMask);
      if (chan != NULL) chan[i] = ((int32_t)(value >> (pSize      ))) & chanMask;
      if (evt  != NULL) evt[i]  = ((int32_t)(value >> (pSize+cSize))) & evtMask;
    }
  }
  else {
    for (int32_t i = 0; i < length; i++,off+=8) {
      int64_t value = unpackLong(buf, off);
      array[i] = (int32_t)((value >> (64-dSize)) & valMask);
      if (chan != NULL) chan[i] = ((int32_t)(value >> (pSize      ))) & chanMask;
      if (evt  != NULL) evt[i]  = ((int32_t)(value >> (pSize+cSize))) & evtMask;
    }
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input value array
 *  @param chan   (IN)  Input channel tag array (null if n/a)
 *  @param evt    (IN)  Input event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntWord64 (void *ptr, int32_t off, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int64_t valMask  = (sign)? ((int64_t)-1) : ((int64_t)__INT64_C(0xFFFFFFFF));
  if (dSize == 32) {
    // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
    // value, so use 32-bit operations to improve performance
    for (int32_t i = 0; i < length; i++,off+=8) {
      int32_t val   = (int32_t)(((int64_t)array[i]) & valMask);
      int32_t value = 0;
      if (chan != NULL) value  = (chan[i] & chanMask) << (pSize);
      if (evt  != NULL) value |= (evt[i]  & evtMask ) << (pSize+cSize);
      packInt(buf, off,   val);
      packInt(buf, off+4, value);
    }
  }
  else {
    for (int32_t i = 0; i < length; i++,off+=8) {
      int64_t val   = (int64_t)(((int64_t)array[i]) & valMask);
      int64_t value = val << (64-dSize);
      if (chan != NULL) value |= ((int64_t)(chan[i] & chanMask)) << (pSize);
      if (evt  != NULL) value |= ((int64_t)(evt[i]  & evtMask )) << (pSize+cSize);
      packLong(buf, off, value);
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array  (OUT) Output value array (not null)
 *  @param chan   (OUT) Output channel tag array (null if n/a)
 *  @param evt    (OUT) Output event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackFloatWord64 (const void *ptr, int32_t off, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  // When using Float32 the first 32-bits will always the the Float32 value, so
  // use 32-bit operations to improve performance
  for (int32_t i = 0; i < length; i++,off+=8) {
    array[i] = (int32_t)unpackFloat(buf, off);
    int32_t value = unpackInt(buf, off+4);
    if (chan != NULL) chan[i] = (value >> (pSize      )) & chanMask;
    if (evt  != NULL) evt[i]  = (value >> (pSize+cSize)) & evtMask;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input value array
 *  @param chan   (IN)  Input channel tag array (null if n/a)
 *  @param evt    (IN)  Input event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packFloatWord64 (void *ptr, int32_t off, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  // When using Float32 the first 32-bits will always the the Float32 value, so
  // use 32-bit operations to improve performance
  for (int32_t i = 0; i < length; i++,off+=8) {
    float val   = (float)array[i];
    int32_t   value = 0;
    if (chan != NULL) value  = (chan[i] & chanMask) << (pSize);
    if (evt  != NULL) value |= (evt[i]  & evtMask ) << (pSize+cSize);
    packFloat(buf, off,   val);
    packInt(  buf, off+4, value);
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntBuffer32 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_dSize  = 32 - dSize;    // pre-compute "32 - dSize" for efficiency
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      if (sign) {
        // sign extend
        array[offset] = (int32_t)((value << _bits_dSize) >>  _bits_dSize);
      }
      else {
        // leave top bits (which default to 0) as 0
        array[offset] = (int32_t)value;
      }
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntBuffer32 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  int32_t valMask      = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t arrayValue = ((int32_t)array[offset]) & valMask;
      int32_t value      = (int32_t)((arrayValue) << (32 - dSize));
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntBuffer64 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_dSize  = 64 - dSize;    // pre-compute "64 - dSize" for efficiency
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      if (sign) {
        // sign extend
        array[offset] = (int32_t)((value << _bits_dSize) >>  _bits_dSize);
      }
      else {
        // leave top bits (which default to 0) as 0
        array[offset] = (int32_t)value;
      }
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntBuffer64 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  int64_t valMask      = (sign)? ((int64_t)-1) : ((int64_t)__INT64_C(0xFFFFFFFF)); // Bit mask for input value (controls sign-extend)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t arrayValue = ((int64_t)array[offset]) & valMask;
      int64_t value      = (int64_t)((arrayValue) << (64 - dSize));
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackFloatBuffer64 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)intBitsToFloat((int32_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packFloatBuffer64 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      float  arrayValue = (float)array[offset];
      int64_t   value      = ((int64_t)floatToRawIntBits(arrayValue)) << 32;
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT1Buffer32 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_SignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT1Buffer32 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT1, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT1Buffer64 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_SignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT1Buffer64 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT1, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT2Buffer32 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_SignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT2Buffer32 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT2, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT2Buffer64 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_SignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT2Buffer64 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT2, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT3Buffer32 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_SignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT3Buffer32 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT3, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT3Buffer64 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_SignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT3Buffer64 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT3, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT4Buffer32 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_SignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT4Buffer32 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT4, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT4Buffer64 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_SignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT4Buffer64 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT4, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT5Buffer32 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_SignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT5Buffer32 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT5, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT5Buffer64 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_SignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT5Buffer64 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT5, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT6Buffer32 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_SignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT6Buffer32 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT6, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT6Buffer64 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_SignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT6Buffer64 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT6, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT1Buffer32 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_UnsignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT1Buffer32 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT1, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT1Buffer64 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_UnsignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT1Buffer64 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT1, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT2Buffer32 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_UnsignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT2Buffer32 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT2, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT2Buffer64 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_UnsignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT2Buffer64 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT2, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT3Buffer32 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_UnsignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT3Buffer32 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT3, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT3Buffer64 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_UnsignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT3Buffer64 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT3, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT4Buffer32 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_UnsignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT4Buffer32 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT4, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT4Buffer64 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_UnsignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT4Buffer64 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT4, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT5Buffer32 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_UnsignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT5Buffer32 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT5, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT5Buffer64 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_UnsignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT5Buffer64 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT5, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT6Buffer32 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_UnsignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT6Buffer32 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT6, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT6Buffer64 (const void *ptr, int32_t bitOffset, int32_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int32_t)fromVRTFloat(DataItemFormat_UnsignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT6Buffer64 (void *ptr, int32_t bitOffset, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT6, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
int32_t* vrt::PackUnpack::unpackAsInt (PayloadFormat pf, const void *ptr, int32_t off, int32_t *array, int32_t *chan, int32_t *evt, int32_t length) {
  const char *buf = (const char*)ptr;
  if (!pf.isValid()) {
    throw VRTException(pf.getValid());
  }
  int32_t            fSize  = pf.getItemPackingFieldSize();
  int32_t            dSize  = pf.getDataItemSize();
  int32_t            eSize  = pf.getEventTagSize();
  int32_t            cSize  = pf.getChannelTagSize();
  bool        proc   = pf.isProcessingEfficient();
  bool        sign   = pf.isSigned();
  DataItemFormat format = pf.getDataItemFormat();
  bool        noTags;
  if (eSize == 0) evt  = NULL; // no event tags, ignore any array passed in
  if (cSize == 0) chan = NULL; // no channel tags, ignore any array passed in
  noTags = (chan == NULL) && (evt == NULL);
  if (proc && noTags && (fSize >= 17)) {
    // Use faster "effective field size" when ignoring Event & Channel Tags
    fSize = (fSize <= 32)? 32 : 64;
  }
  switch (format) {
    case DataItemFormat_SignedInt:   // FALLTHROUGH
    case DataItemFormat_UnsignedInt:
      // ---- Try fast methods -------------------------------------------------
      if (noTags) {
        switch (fSize) {
          case  8: unpackBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 16: unpackShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 24: unpackInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 32: unpackInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 64: unpackLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
        }
      }
      if (fSize == dSize) { // implicit noTags=true in this case
        switch (fSize) {
          case  1: if ((length % 8) == 0) { unpackBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          case  4: if ((length % 2) == 0) { unpackNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          case 12: if ((length % 2) == 0) { unpackInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
        }
      }
      if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
        if (fSize <= 32) {
          unpackIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      }
      // ---- Fall back to slow method -----------------------------------------
      if (fSize <= 32) {
        unpackIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_Float:
      // ---- Try fast methods -------------------------------------------------
      if (fSize == dSize) { // implicit noTags=true in this case
        unpackFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
      }
      if ((proc && (fSize >= 33)) || (fSize == 64)) {
        unpackFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      // ---- Fall back to slow method -----------------------------------------
      unpackFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
    case DataItemFormat_Double:
      // ---- Only fast method for double (yea!) -------------------------------
      unpackDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
    case DataItemFormat_SignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    default:
      throw VRTException("Unpacking of VRT float types not supported yet");
  }
}
void vrt::PackUnpack::packAsInt (PayloadFormat pf, void *ptr, int32_t off, const int32_t *array, const int32_t *chan, const int32_t *evt, int32_t length) {
  char *buf = (char*)ptr;
  if (!pf.isValid()) {
    throw VRTException(pf.getValid());
  }
  int32_t            fSize  = pf.getItemPackingFieldSize();
  int32_t            dSize  = pf.getDataItemSize();
  int32_t            eSize  = pf.getEventTagSize();
  int32_t            cSize  = pf.getChannelTagSize();
  bool        proc   = pf.isProcessingEfficient();
  bool        sign   = pf.isSigned();
  DataItemFormat format = pf.getDataItemFormat();
  bool        noTags;
  if (eSize == 0) evt  = NULL; // no event tags, ignore any array passed in
  if (cSize == 0) chan = NULL; // no channel tags, ignore any array passed in
  noTags = (chan == NULL) && (evt == NULL);
  if (proc && noTags && (fSize >= 17)) {
    // Use faster "effective field size" when ignoring Event & Channel Tags
    fSize = (fSize <= 32)? 32 : 64;
  }
  switch (format) {
    case DataItemFormat_SignedInt:   // FALLTHROUGH
    case DataItemFormat_UnsignedInt:
      // ---- Try fast methods -------------------------------------------------
      if (noTags) {
        switch (fSize) {
          case  8: packBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 16: packShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 24: packInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 32: packInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 64: packLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
        }
      }
      if (fSize == dSize) { // implicit noTags=true in this case
        switch (fSize) {
          case  1: if ((length % 8) == 0) { packBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          case  4: if ((length % 2) == 0) { packNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          case 12: if ((length % 2) == 0) { packInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
        }
      }
      if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
        if (fSize <= 32) {
          packIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      }
      // ---- Fall back to slow method -----------------------------------------
      if (fSize <= 32) {
        packIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_Float:
      // ---- Try fast methods -------------------------------------------------
      if (fSize == dSize) { // implicit noTags=true in this case
        packFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
      }
      if ((proc && (fSize >= 33)) || (fSize == 64)) {
        packFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      // ---- Fall back to slow method -----------------------------------------
      packFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
    case DataItemFormat_Double:
      // ---- Only fast method for double (yea!) -------------------------------
      packDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
    case DataItemFormat_SignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    default:
      throw VRTException("Packing of VRT float types not supported yet");
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for double data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 64)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void unpackDoubles (const void *ptr, int32_t off, int16_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  // When using Double data, it is required that dSize=64 and fSize=64 so we can
  // skip some of the normal checks we would otherwise do here.
  for (int32_t i = 0; i < length; i++,off+=8) {
    array[offset++] = (int16_t)unpackDouble(buf, off);
  }
}
/** <b>Internal Use Only:</b>
 *  Fast pack method for double data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 64)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void packDoubles (void *ptr, int32_t off, const int16_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  // When using Double data, it is required that dSize=64 and fSize=64 so we can
  // skip some of the normal checks we would otherwise do here.
  for (int32_t i = 0; i < length; i++,off+=8) {
    packDouble(buf, off, (double)array[offset++]);
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for float data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 32)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void unpackFloats (const void *ptr, int32_t off, int16_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  int32_t delta; // int8_t offset delta
  if (align) delta = (fSize <= 32)? 4 : 8;
  else       delta = fSize / 8;
  for (int32_t i = 0; i < length; i++,off+=delta) {
    array[offset++] = (int16_t)unpackFloat(buf, off);
  }
}
/** <b>Internal Use Only:</b>
 *  Fast pack method for float data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 32)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void packFloats (void *ptr, int32_t off, const int16_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  int32_t delta; // int8_t offset delta
  if (align) delta = (fSize <= 32)? 4 : 8;
  else       delta = fSize / 8;
  if (delta == 4) {
    for (int32_t i = 0; i < length; i++,off+=4) {
      packFloat(buf, off, (float)array[offset++]);
    }
  }
  else {
    for (int32_t i = 0; i < length; i++) {
      packFloat(buf, off, (float)array[offset++]);
      off += 4;
      _Intel_Pragma("loop_count min=1, max=4")
      for (int32_t j = 4; j < delta; j++) {
        buf[off++] = 0; // set unused bits to zero
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int64_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackLongs (const void *ptr, int32_t off, int16_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  if (sign) {
    if (dSize == 64) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int16_t)unpackLong(buf, off);
      }
    }
    else {
      int32_t shift  = 64 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int16_t)(unpackLong(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 64) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int16_t)(unpackLong(buf, off) & __INT64_C(0xFFFFFFFFFFFFFFFF));
      }
    }
    else {
      int32_t shift  = 64 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int16_t)((unpackLong(buf, off) & __INT64_C(0xFFFFFFFFFFFFFFFF)) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int64_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packLongs (void *ptr, int32_t off, const int16_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  int64_t valMask = (sign)? ((int64_t)-1) : ((int64_t)__INT64_C(0xFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 64) {
    if (delta == 8) {
      for (int32_t i = 0; i < length; i++,off+=8) {
        int64_t val = (int64_t)(((int64_t)array[offset++]) & valMask);
        packLong(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int64_t val = (int64_t)(((int64_t)array[offset++]) & valMask);
        packLong(buf, off, val);
        off += 8;
        _Intel_Pragma("loop_count min=1, max=0")
        for (int32_t j = 8; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 64 - dSize;
    if (delta == 8) {
      for (int32_t i = 0; i < length; i++,off+=8) {
        int64_t val = (int64_t)(((int64_t)array[offset++]) & valMask);
        packLong(buf, off, (int64_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int64_t val = (int64_t)(((int64_t)array[offset++]) & valMask);
        packLong(buf, off, (int64_t)(val << shift));
        off += 8;
        _Intel_Pragma("loop_count min=1, max=0")
        for (int32_t j = 8; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int32_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackInts (const void *ptr, int32_t off, int16_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  if (sign) {
    if (dSize == 32) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int16_t)unpackInt(buf, off);
      }
    }
    else {
      int32_t shift  = 32 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int16_t)(unpackInt(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 32) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int16_t)(unpackInt(buf, off) & 0xFFFFFFFF);
      }
    }
    else {
      int32_t shift  = 32 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int16_t)((unpackInt(buf, off) & 0xFFFFFFFF) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int32_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packInts (void *ptr, int32_t off, const int16_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  int32_t valMask = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 32) {
    if (delta == 4) {
      for (int32_t i = 0; i < length; i++,off+=4) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt(buf, off, val);
        off += 4;
        _Intel_Pragma("loop_count min=1, max=4")
        for (int32_t j = 4; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 32 - dSize;
    if (delta == 4) {
      for (int32_t i = 0; i < length; i++,off+=4) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt(buf, off, (int32_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt(buf, off, (int32_t)(val << shift));
        off += 4;
        _Intel_Pragma("loop_count min=1, max=4")
        for (int32_t j = 4; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int32_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackInt24s (const void *ptr, int32_t off, int16_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  if (sign) {
    if (dSize == 24) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int16_t)unpackInt24(buf, off);
      }
    }
    else {
      int32_t shift  = 24 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int16_t)(unpackInt24(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 24) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int16_t)(unpackInt24(buf, off) & 0xFFFFFF);
      }
    }
    else {
      int32_t shift  = 24 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int16_t)((unpackInt24(buf, off) & 0xFFFFFF) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int32_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packInt24s (void *ptr, int32_t off, const int16_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  int32_t valMask = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 24) {
    if (delta == 3) {
      for (int32_t i = 0; i < length; i++,off+=3) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt24(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt24(buf, off, val);
        off += 3;
        _Intel_Pragma("loop_count min=1, max=5")
        for (int32_t j = 3; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 24 - dSize;
    if (delta == 3) {
      for (int32_t i = 0; i < length; i++,off+=3) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt24(buf, off, (int32_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt24(buf, off, (int32_t)(val << shift));
        off += 3;
        _Intel_Pragma("loop_count min=1, max=5")
        for (int32_t j = 3; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int16_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackShorts (const void *ptr, int32_t off, int16_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
#if (2 == 1) || (BYTE_ORDER == BIG_ENDIAN)
  if ((fSize == 16) && (dSize == 16)) {
    // Fast array copy
    memcpy(&array[offset], &buf[off], length*2);
    return;
  }
#endif
  int32_t delta = fSize / 8; // int8_t offset delta
  if (sign) {
    if (dSize == 16) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int16_t)unpackShort(buf, off);
      }
    }
    else {
      int32_t shift  = 16 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int16_t)(unpackShort(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 16) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int16_t)(unpackShort(buf, off) & 0xFFFF);
      }
    }
    else {
      int32_t shift  = 16 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int16_t)((unpackShort(buf, off) & 0xFFFF) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int16_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packShorts (void *ptr, int32_t off, const int16_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
#if (2 == 1) || (BYTE_ORDER == BIG_ENDIAN)
  if ((fSize == 16) && (dSize == 16)) {
    // Fast array copy
    memcpy(&buf[off], &array[offset], length*2);
    return;
  }
#endif
  int32_t delta = fSize / 8; // int8_t offset delta
  int16_t valMask = (sign)? ((int16_t)-1) : ((int16_t)__INT64_C(0xFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 16) {
    if (delta == 2) {
      for (int32_t i = 0; i < length; i++,off+=2) {
        int16_t val = (int16_t)(((int16_t)array[offset++]) & valMask);
        packShort(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int16_t val = (int16_t)(((int16_t)array[offset++]) & valMask);
        packShort(buf, off, val);
        off += 2;
        _Intel_Pragma("loop_count min=1, max=6")
        for (int32_t j = 2; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 16 - dSize;
    if (delta == 2) {
      for (int32_t i = 0; i < length; i++,off+=2) {
        int16_t val = (int16_t)(((int16_t)array[offset++]) & valMask);
        packShort(buf, off, (int16_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int16_t val = (int16_t)(((int16_t)array[offset++]) & valMask);
        packShort(buf, off, (int16_t)(val << shift));
        off += 2;
        _Intel_Pragma("loop_count min=1, max=6")
        for (int32_t j = 2; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed Int12 data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 12)
 *  @param dSize  (IN)  Data item size in bits (must be 12)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackInt12s (const void *ptr, int32_t off, int16_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t skip = (align)? 1 : 0;
  if (sign) {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t a = (int32_t)buf[off++];
      int32_t b = (int32_t)buf[off++];
      int32_t c = (int32_t)buf[off++];
      int32_t x = (a << 4) | ((b >> 4) & 0x000F);
      int32_t y = (b << 8) | ((c     ) & 0x00FF);
      array[offset++] = (int16_t)((x << 20) >> 20); // sign extend
      array[offset++] = (int16_t)((y << 20) >> 20); // sign extend
      off += skip; // skip extra int8_t in processing-efficient mode
    }
  }
  else {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t a = (int32_t)buf[off++];
      int32_t b = (int32_t)buf[off++];
      int32_t c = (int32_t)buf[off++];
      int32_t x = (a << 4) | ((b >> 4) & 0x000F);
      int32_t y = (b << 8) | ((c     ) & 0x00FF);
      array[offset++] = (int16_t)(x & 0x0FFF); // clear high-order bits
      array[offset++] = (int16_t)(y & 0x0FFF); // clear high-order bits
      off += skip; // skip extra int8_t in processing-efficient mode
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for signed Int12 data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 12)
 *  @param dSize  (IN)  Data item size in bits (must be 12)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packInt12s (void *ptr, int32_t off, const int16_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t skip = (align)?  1 : 0;
  int32_t mask = (sign )? -1 : ((int32_t)__INT64_C(0xFFFF));
  for (int32_t i = 0; i < length; i+=2) {
    int32_t first  = ((int32_t)array[offset++]) & mask;
    int32_t second = ((int32_t)array[offset++]) & mask;
    buf[off++] = (int8_t)(first >> 4);
    buf[off++] = (int8_t)((first << 4) | ((second >> 8) & 0x0F));
    buf[off++] = (int8_t)(second);
    off += skip; // skip extra int8_t in processing-efficient mode
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int8_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackBytes (const void *ptr, int32_t off, int16_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = fSize / 8; // int8_t offset delta
  if (sign) {
    if (dSize == 8) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int16_t)unpackByte(buf, off);
      }
    }
    else {
      int32_t shift  = 8 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int16_t)(unpackByte(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 8) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int16_t)(unpackByte(buf, off) & 0xFF);
      }
    }
    else {
      int32_t shift  = 8 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int16_t)((unpackByte(buf, off) & 0xFF) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int8_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packBytes (void *ptr, int32_t off, const int16_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = fSize / 8; // int8_t offset delta
  int8_t valMask = (sign)? ((int8_t)-1) : ((int8_t)__INT64_C(0xFFFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 8) {
    if (delta == 1) {
      for (int32_t i = 0; i < length; i++,off+=1) {
        int8_t val = (int8_t)(((int8_t)array[offset++]) & valMask);
        packByte(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int8_t val = (int8_t)(((int8_t)array[offset++]) & valMask);
        packByte(buf, off, val);
        off += 1;
        _Intel_Pragma("loop_count min=1, max=7")
        for (int32_t j = 1; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 8 - dSize;
    if (delta == 1) {
      for (int32_t i = 0; i < length; i++,off+=1) {
        int8_t val = (int8_t)(((int8_t)array[offset++]) & valMask);
        packByte(buf, off, (int8_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int8_t val = (int8_t)(((int8_t)array[offset++]) & valMask);
        packByte(buf, off, (int8_t)(val << shift));
        off += 1;
        _Intel_Pragma("loop_count min=1, max=7")
        for (int32_t j = 1; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed Int4 (nibble) data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 4)
 *  @param dSize  (IN)  Data item size in bits (must be 4)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackNibbles (const void *ptr, int32_t off, int16_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  if (sign) {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (int16_t)((b << 24) >> 28); // shift & sign extend
      array[offset++] = (int16_t)((b << 28) >> 28); // shift & sign extend
    }
  }
  else {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (int16_t)((b >> 4) & 0xF);
      array[offset++] = (int16_t)((b     ) & 0xF);
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for signed Int4 (nibble) data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 4)
 *  @param dSize  (IN)  Data item size in bits (must be 4)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packNibbles (void *ptr, int32_t off, const int16_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Pack function for signed and unsigned are identical for nibble data, hence
  // 'sign' is unused here, but included in function definition for consistency.
  for (int32_t i = 0; i < length; i+=2) {
    int32_t first  = (int32_t)array[offset++];
    int32_t second = (int32_t)array[offset++];
    buf[off++] = (int8_t)((first << 4) | (second & 0xF));
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for bit data. Each bit in the
 *  input buffer will be checked, a 0 bit will correspond to the value 0 and a
 *  1 bit will correspond to the value 1.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
 *  @param fSize  (IN)  Item packing field size in bits (must be 1)
 *  @param dSize  (IN)  Data item size in bits (must be 1)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackBits (const void *ptr, int32_t off, int16_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  if (sign) {
    // This uses sign-extending principles to get each bit as 0 or -1 which reflects
    // the fact that 0/-1 and not 0/+1 are the available values in a one-bit use of
    // twos-complement.
    for (int32_t i = 0; i < length; i+=8) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (int16_t)((b << 24) >> 31);
      array[offset++] = (int16_t)((b << 25) >> 31);
      array[offset++] = (int16_t)((b << 26) >> 31);
      array[offset++] = (int16_t)((b << 27) >> 31);
      array[offset++] = (int16_t)((b << 28) >> 31);
      array[offset++] = (int16_t)((b << 29) >> 31);
      array[offset++] = (int16_t)((b << 30) >> 31);
      array[offset++] = (int16_t)((b << 31) >> 31);
    }
  }
  else {
    for (int32_t i = 0; i < length; i+=8) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (int16_t)((b >> 7) & 0x1);
      array[offset++] = (int16_t)((b >> 6) & 0x1);
      array[offset++] = (int16_t)((b >> 5) & 0x1);
      array[offset++] = (int16_t)((b >> 4) & 0x1);
      array[offset++] = (int16_t)((b >> 3) & 0x1);
      array[offset++] = (int16_t)((b >> 2) & 0x1);
      array[offset++] = (int16_t)((b >> 1) & 0x1);
      array[offset++] = (int16_t)((b     ) & 0x1);
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for bit data. Each value in the
 *  input array will be checked, a zero value will correspond to the bit 0 and
 *  any non-zero value will correspond to the bit 1.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
 *  @param fSize  (IN)  Item packing field size in bits (must be 1)
 *  @param dSize  (IN)  Data item size in bits (must be 1)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packBits (void *ptr, int32_t off, const int16_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Pack function for signed and unsigned are identical for bit data, hence
  // 'sign' is unused here, but included in function definition for consistency.
  for (int32_t i = 0; i < length; i+=8) {
    int32_t b = 0;
    b |= (((int32_t)array[offset++]) << 7) & 0x80;
    b |= (((int32_t)array[offset++]) << 6) & 0x40;
    b |= (((int32_t)array[offset++]) << 5) & 0x20;
    b |= (((int32_t)array[offset++]) << 4) & 0x10;
    b |= (((int32_t)array[offset++]) << 3) & 0x08;
    b |= (((int32_t)array[offset++]) << 2) & 0x04;
    b |= (((int32_t)array[offset++]) << 1) & 0x02;
    b |= (((int32_t)array[offset++])     ) & 0x01;
    buf[off++] = (int8_t)b;
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array, where the data is
 *  aligned to 32-bit word boundaries.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array  (OUT) Output value array (not null)
 *  @param chan   (OUT) Output channel tag array (null if n/a)
 *  @param evt    (OUT) Output event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntWord32 (const void *ptr, int32_t off, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 32 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int32_t valMask  = (sign)? ((int32_t)-1) : (~(((int32_t)-1) << dSize));
  for (int32_t i = 0; i < length; i++,off+=4) {
    int32_t value = unpackInt(buf, off);
    array[i] = (int16_t)((value >> (32-dSize)) & valMask);
    if (chan != NULL) chan[i] = (value >> (pSize      )) & chanMask;
    if (evt  != NULL) evt[i]  = (value >> (pSize+cSize)) & evtMask;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array, where the data is
 *  aligned to 32-bit word boundaries.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input value array
 *  @param chan   (IN)  Input channel tag array (null if n/a)
 *  @param evt    (IN)  Input event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntWord32 (void *ptr, int32_t off, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 32 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int32_t valMask  = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFFFF));
  for (int32_t i = 0; i < length; i++,off+=4) {
    int32_t val   = (int32_t)(((int32_t)array[i]) & valMask);
    int32_t value = val << (32-dSize);
    if (chan != NULL) value |= (chan[i] & chanMask) << (pSize);
    if (evt  != NULL) value |= (evt[i]  & evtMask ) << (pSize+cSize);
    packInt(buf, off, value);
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array  (OUT) Output value array (not null)
 *  @param chan   (OUT) Output channel tag array (null if n/a)
 *  @param evt    (OUT) Output event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntWord64 (const void *ptr, int32_t off, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int64_t valMask  = (sign)? ((int64_t)-1) : (~(((int64_t)-1) << dSize));
  if (dSize == 32) {
    // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
    // value, so use 32-bit operations to improve performance
    for (int32_t i = 0; i < length; i++,off+=8) {
      int32_t val   = unpackInt(buf, off);
      int32_t value = unpackInt(buf, off+4);
      array[i] = (int16_t)(val & valMask);
      if (chan != NULL) chan[i] = ((int32_t)(value >> (pSize      ))) & chanMask;
      if (evt  != NULL) evt[i]  = ((int32_t)(value >> (pSize+cSize))) & evtMask;
    }
  }
  else {
    for (int32_t i = 0; i < length; i++,off+=8) {
      int64_t value = unpackLong(buf, off);
      array[i] = (int16_t)((value >> (64-dSize)) & valMask);
      if (chan != NULL) chan[i] = ((int32_t)(value >> (pSize      ))) & chanMask;
      if (evt  != NULL) evt[i]  = ((int32_t)(value >> (pSize+cSize))) & evtMask;
    }
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input value array
 *  @param chan   (IN)  Input channel tag array (null if n/a)
 *  @param evt    (IN)  Input event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntWord64 (void *ptr, int32_t off, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int64_t valMask  = (sign)? ((int64_t)-1) : ((int64_t)__INT64_C(0xFFFF));
  if (dSize == 32) {
    // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
    // value, so use 32-bit operations to improve performance
    for (int32_t i = 0; i < length; i++,off+=8) {
      int32_t val   = (int32_t)(((int64_t)array[i]) & valMask);
      int32_t value = 0;
      if (chan != NULL) value  = (chan[i] & chanMask) << (pSize);
      if (evt  != NULL) value |= (evt[i]  & evtMask ) << (pSize+cSize);
      packInt(buf, off,   val);
      packInt(buf, off+4, value);
    }
  }
  else {
    for (int32_t i = 0; i < length; i++,off+=8) {
      int64_t val   = (int64_t)(((int64_t)array[i]) & valMask);
      int64_t value = val << (64-dSize);
      if (chan != NULL) value |= ((int64_t)(chan[i] & chanMask)) << (pSize);
      if (evt  != NULL) value |= ((int64_t)(evt[i]  & evtMask )) << (pSize+cSize);
      packLong(buf, off, value);
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array  (OUT) Output value array (not null)
 *  @param chan   (OUT) Output channel tag array (null if n/a)
 *  @param evt    (OUT) Output event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackFloatWord64 (const void *ptr, int32_t off, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  // When using Float32 the first 32-bits will always the the Float32 value, so
  // use 32-bit operations to improve performance
  for (int32_t i = 0; i < length; i++,off+=8) {
    array[i] = (int16_t)unpackFloat(buf, off);
    int32_t value = unpackInt(buf, off+4);
    if (chan != NULL) chan[i] = (value >> (pSize      )) & chanMask;
    if (evt  != NULL) evt[i]  = (value >> (pSize+cSize)) & evtMask;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input value array
 *  @param chan   (IN)  Input channel tag array (null if n/a)
 *  @param evt    (IN)  Input event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packFloatWord64 (void *ptr, int32_t off, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  // When using Float32 the first 32-bits will always the the Float32 value, so
  // use 32-bit operations to improve performance
  for (int32_t i = 0; i < length; i++,off+=8) {
    float val   = (float)array[i];
    int32_t   value = 0;
    if (chan != NULL) value  = (chan[i] & chanMask) << (pSize);
    if (evt  != NULL) value |= (evt[i]  & evtMask ) << (pSize+cSize);
    packFloat(buf, off,   val);
    packInt(  buf, off+4, value);
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntBuffer32 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_dSize  = 32 - dSize;    // pre-compute "32 - dSize" for efficiency
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      if (sign) {
        // sign extend
        array[offset] = (int16_t)((value << _bits_dSize) >>  _bits_dSize);
      }
      else {
        // leave top bits (which default to 0) as 0
        array[offset] = (int16_t)value;
      }
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntBuffer32 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  int32_t valMask      = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFFFF)); // Bit mask for input value (controls sign-extend)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t arrayValue = ((int32_t)array[offset]) & valMask;
      int32_t value      = (int32_t)((arrayValue) << (32 - dSize));
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntBuffer64 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_dSize  = 64 - dSize;    // pre-compute "64 - dSize" for efficiency
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      if (sign) {
        // sign extend
        array[offset] = (int16_t)((value << _bits_dSize) >>  _bits_dSize);
      }
      else {
        // leave top bits (which default to 0) as 0
        array[offset] = (int16_t)value;
      }
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntBuffer64 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  int64_t valMask      = (sign)? ((int64_t)-1) : ((int64_t)__INT64_C(0xFFFF)); // Bit mask for input value (controls sign-extend)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t arrayValue = ((int64_t)array[offset]) & valMask;
      int64_t value      = (int64_t)((arrayValue) << (64 - dSize));
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackFloatBuffer64 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)intBitsToFloat((int32_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packFloatBuffer64 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      float  arrayValue = (float)array[offset];
      int64_t   value      = ((int64_t)floatToRawIntBits(arrayValue)) << 32;
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT1Buffer32 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_SignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT1Buffer32 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT1, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT1Buffer64 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_SignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT1Buffer64 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT1, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT2Buffer32 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_SignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT2Buffer32 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT2, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT2Buffer64 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_SignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT2Buffer64 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT2, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT3Buffer32 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_SignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT3Buffer32 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT3, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT3Buffer64 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_SignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT3Buffer64 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT3, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT4Buffer32 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_SignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT4Buffer32 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT4, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT4Buffer64 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_SignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT4Buffer64 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT4, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT5Buffer32 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_SignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT5Buffer32 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT5, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT5Buffer64 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_SignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT5Buffer64 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT5, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT6Buffer32 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_SignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT6Buffer32 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT6, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT6Buffer64 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_SignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT6Buffer64 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT6, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT1Buffer32 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_UnsignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT1Buffer32 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT1, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT1Buffer64 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_UnsignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT1Buffer64 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT1, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT2Buffer32 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_UnsignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT2Buffer32 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT2, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT2Buffer64 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_UnsignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT2Buffer64 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT2, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT3Buffer32 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_UnsignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT3Buffer32 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT3, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT3Buffer64 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_UnsignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT3Buffer64 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT3, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT4Buffer32 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_UnsignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT4Buffer32 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT4, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT4Buffer64 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_UnsignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT4Buffer64 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT4, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT5Buffer32 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_UnsignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT5Buffer32 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT5, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT5Buffer64 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_UnsignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT5Buffer64 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT5, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT6Buffer32 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_UnsignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT6Buffer32 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT6, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT6Buffer64 (const void *ptr, int32_t bitOffset, int16_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int16_t)fromVRTFloat(DataItemFormat_UnsignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT6Buffer64 (void *ptr, int32_t bitOffset, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT6, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
int16_t* vrt::PackUnpack::unpackAsShort (PayloadFormat pf, const void *ptr, int32_t off, int16_t *array, int32_t *chan, int32_t *evt, int32_t length) {
  const char *buf = (const char*)ptr;
  if (!pf.isValid()) {
    throw VRTException(pf.getValid());
  }
  int32_t            fSize  = pf.getItemPackingFieldSize();
  int32_t            dSize  = pf.getDataItemSize();
  int32_t            eSize  = pf.getEventTagSize();
  int32_t            cSize  = pf.getChannelTagSize();
  bool        proc   = pf.isProcessingEfficient();
  bool        sign   = pf.isSigned();
  DataItemFormat format = pf.getDataItemFormat();
  bool        noTags;
  if (eSize == 0) evt  = NULL; // no event tags, ignore any array passed in
  if (cSize == 0) chan = NULL; // no channel tags, ignore any array passed in
  noTags = (chan == NULL) && (evt == NULL);
  if (proc && noTags && (fSize >= 17)) {
    // Use faster "effective field size" when ignoring Event & Channel Tags
    fSize = (fSize <= 32)? 32 : 64;
  }
  switch (format) {
    case DataItemFormat_SignedInt:   // FALLTHROUGH
    case DataItemFormat_UnsignedInt:
      // ---- Try fast methods -------------------------------------------------
      if (noTags) {
        switch (fSize) {
          case  8: unpackBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 16: unpackShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 24: unpackInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 32: unpackInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 64: unpackLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
        }
      }
      if (fSize == dSize) { // implicit noTags=true in this case
        switch (fSize) {
          case  1: if ((length % 8) == 0) { unpackBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          case  4: if ((length % 2) == 0) { unpackNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          case 12: if ((length % 2) == 0) { unpackInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
        }
      }
      if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
        if (fSize <= 32) {
          unpackIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      }
      // ---- Fall back to slow method -----------------------------------------
      if (fSize <= 32) {
        unpackIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_Float:
      // ---- Try fast methods -------------------------------------------------
      if (fSize == dSize) { // implicit noTags=true in this case
        unpackFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
      }
      if ((proc && (fSize >= 33)) || (fSize == 64)) {
        unpackFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      // ---- Fall back to slow method -----------------------------------------
      unpackFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
    case DataItemFormat_Double:
      // ---- Only fast method for double (yea!) -------------------------------
      unpackDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
    case DataItemFormat_SignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    default:
      throw VRTException("Unpacking of VRT float types not supported yet");
  }
}
void vrt::PackUnpack::packAsShort (PayloadFormat pf, void *ptr, int32_t off, const int16_t *array, const int32_t *chan, const int32_t *evt, int32_t length) {
  char *buf = (char*)ptr;
  if (!pf.isValid()) {
    throw VRTException(pf.getValid());
  }
  int32_t            fSize  = pf.getItemPackingFieldSize();
  int32_t            dSize  = pf.getDataItemSize();
  int32_t            eSize  = pf.getEventTagSize();
  int32_t            cSize  = pf.getChannelTagSize();
  bool        proc   = pf.isProcessingEfficient();
  bool        sign   = pf.isSigned();
  DataItemFormat format = pf.getDataItemFormat();
  bool        noTags;
  if (eSize == 0) evt  = NULL; // no event tags, ignore any array passed in
  if (cSize == 0) chan = NULL; // no channel tags, ignore any array passed in
  noTags = (chan == NULL) && (evt == NULL);
  if (proc && noTags && (fSize >= 17)) {
    // Use faster "effective field size" when ignoring Event & Channel Tags
    fSize = (fSize <= 32)? 32 : 64;
  }
  switch (format) {
    case DataItemFormat_SignedInt:   // FALLTHROUGH
    case DataItemFormat_UnsignedInt:
      // ---- Try fast methods -------------------------------------------------
      if (noTags) {
        switch (fSize) {
          case  8: packBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 16: packShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 24: packInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 32: packInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 64: packLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
        }
      }
      if (fSize == dSize) { // implicit noTags=true in this case
        switch (fSize) {
          case  1: if ((length % 8) == 0) { packBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          case  4: if ((length % 2) == 0) { packNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          case 12: if ((length % 2) == 0) { packInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
        }
      }
      if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
        if (fSize <= 32) {
          packIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      }
      // ---- Fall back to slow method -----------------------------------------
      if (fSize <= 32) {
        packIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_Float:
      // ---- Try fast methods -------------------------------------------------
      if (fSize == dSize) { // implicit noTags=true in this case
        packFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
      }
      if ((proc && (fSize >= 33)) || (fSize == 64)) {
        packFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      // ---- Fall back to slow method -----------------------------------------
      packFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
    case DataItemFormat_Double:
      // ---- Only fast method for double (yea!) -------------------------------
      packDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
    case DataItemFormat_SignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    default:
      throw VRTException("Packing of VRT float types not supported yet");
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for double data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 64)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void unpackDoubles (const void *ptr, int32_t off, int8_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  // When using Double data, it is required that dSize=64 and fSize=64 so we can
  // skip some of the normal checks we would otherwise do here.
  for (int32_t i = 0; i < length; i++,off+=8) {
    array[offset++] = (int8_t)unpackDouble(buf, off);
  }
}
/** <b>Internal Use Only:</b>
 *  Fast pack method for double data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 64)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void packDoubles (void *ptr, int32_t off, const int8_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  // When using Double data, it is required that dSize=64 and fSize=64 so we can
  // skip some of the normal checks we would otherwise do here.
  for (int32_t i = 0; i < length; i++,off+=8) {
    packDouble(buf, off, (double)array[offset++]);
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for float data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 32)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void unpackFloats (const void *ptr, int32_t off, int8_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  int32_t delta; // int8_t offset delta
  if (align) delta = (fSize <= 32)? 4 : 8;
  else       delta = fSize / 8;
  for (int32_t i = 0; i < length; i++,off+=delta) {
    array[offset++] = (int8_t)unpackFloat(buf, off);
  }
}
/** <b>Internal Use Only:</b>
 *  Fast pack method for float data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be 32)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
static __attribute__((flatten)) void packFloats (void *ptr, int32_t off, const int8_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
  int32_t delta; // int8_t offset delta
  if (align) delta = (fSize <= 32)? 4 : 8;
  else       delta = fSize / 8;
  if (delta == 4) {
    for (int32_t i = 0; i < length; i++,off+=4) {
      packFloat(buf, off, (float)array[offset++]);
    }
  }
  else {
    for (int32_t i = 0; i < length; i++) {
      packFloat(buf, off, (float)array[offset++]);
      off += 4;
      _Intel_Pragma("loop_count min=1, max=4")
      for (int32_t j = 4; j < delta; j++) {
        buf[off++] = 0; // set unused bits to zero
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int64_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackLongs (const void *ptr, int32_t off, int8_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  if (sign) {
    if (dSize == 64) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int8_t)unpackLong(buf, off);
      }
    }
    else {
      int32_t shift  = 64 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int8_t)(unpackLong(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 64) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int8_t)(unpackLong(buf, off) & __INT64_C(0xFFFFFFFFFFFFFFFF));
      }
    }
    else {
      int32_t shift  = 64 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int8_t)((unpackLong(buf, off) & __INT64_C(0xFFFFFFFFFFFFFFFF)) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int64_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packLongs (void *ptr, int32_t off, const int8_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  int64_t valMask = (sign)? ((int64_t)-1) : ((int64_t)__INT64_C(0xFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 64) {
    if (delta == 8) {
      for (int32_t i = 0; i < length; i++,off+=8) {
        int64_t val = (int64_t)(((int64_t)array[offset++]) & valMask);
        packLong(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int64_t val = (int64_t)(((int64_t)array[offset++]) & valMask);
        packLong(buf, off, val);
        off += 8;
        _Intel_Pragma("loop_count min=1, max=0")
        for (int32_t j = 8; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 64 - dSize;
    if (delta == 8) {
      for (int32_t i = 0; i < length; i++,off+=8) {
        int64_t val = (int64_t)(((int64_t)array[offset++]) & valMask);
        packLong(buf, off, (int64_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int64_t val = (int64_t)(((int64_t)array[offset++]) & valMask);
        packLong(buf, off, (int64_t)(val << shift));
        off += 8;
        _Intel_Pragma("loop_count min=1, max=0")
        for (int32_t j = 8; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int32_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackInts (const void *ptr, int32_t off, int8_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  if (sign) {
    if (dSize == 32) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int8_t)unpackInt(buf, off);
      }
    }
    else {
      int32_t shift  = 32 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int8_t)(unpackInt(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 32) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int8_t)(unpackInt(buf, off) & 0xFFFFFFFF);
      }
    }
    else {
      int32_t shift  = 32 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int8_t)((unpackInt(buf, off) & 0xFFFFFFFF) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int32_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packInts (void *ptr, int32_t off, const int8_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  int32_t valMask = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 32) {
    if (delta == 4) {
      for (int32_t i = 0; i < length; i++,off+=4) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt(buf, off, val);
        off += 4;
        _Intel_Pragma("loop_count min=1, max=4")
        for (int32_t j = 4; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 32 - dSize;
    if (delta == 4) {
      for (int32_t i = 0; i < length; i++,off+=4) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt(buf, off, (int32_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt(buf, off, (int32_t)(val << shift));
        off += 4;
        _Intel_Pragma("loop_count min=1, max=4")
        for (int32_t j = 4; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int32_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackInt24s (const void *ptr, int32_t off, int8_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  if (sign) {
    if (dSize == 24) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int8_t)unpackInt24(buf, off);
      }
    }
    else {
      int32_t shift  = 24 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int8_t)(unpackInt24(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 24) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int8_t)(unpackInt24(buf, off) & 0xFFFFFF);
      }
    }
    else {
      int32_t shift  = 24 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int8_t)((unpackInt24(buf, off) & 0xFFFFFF) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int32_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packInt24s (void *ptr, int32_t off, const int8_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // int8_t offset delta
  int32_t valMask = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 24) {
    if (delta == 3) {
      for (int32_t i = 0; i < length; i++,off+=3) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt24(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt24(buf, off, val);
        off += 3;
        _Intel_Pragma("loop_count min=1, max=5")
        for (int32_t j = 3; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 24 - dSize;
    if (delta == 3) {
      for (int32_t i = 0; i < length; i++,off+=3) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt24(buf, off, (int32_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int32_t val = (int32_t)(((int32_t)array[offset++]) & valMask);
        packInt24(buf, off, (int32_t)(val << shift));
        off += 3;
        _Intel_Pragma("loop_count min=1, max=5")
        for (int32_t j = 3; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int16_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackShorts (const void *ptr, int32_t off, int8_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t delta = fSize / 8; // int8_t offset delta
  if (sign) {
    if (dSize == 16) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int8_t)unpackShort(buf, off);
      }
    }
    else {
      int32_t shift  = 16 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int8_t)(unpackShort(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 16) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int8_t)(unpackShort(buf, off) & 0xFFFF);
      }
    }
    else {
      int32_t shift  = 16 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int8_t)((unpackShort(buf, off) & 0xFFFF) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int16_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packShorts (void *ptr, int32_t off, const int8_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t delta = fSize / 8; // int8_t offset delta
  int16_t valMask = (sign)? ((int16_t)-1) : ((int16_t)__INT64_C(0xFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 16) {
    if (delta == 2) {
      for (int32_t i = 0; i < length; i++,off+=2) {
        int16_t val = (int16_t)(((int16_t)array[offset++]) & valMask);
        packShort(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int16_t val = (int16_t)(((int16_t)array[offset++]) & valMask);
        packShort(buf, off, val);
        off += 2;
        _Intel_Pragma("loop_count min=1, max=6")
        for (int32_t j = 2; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 16 - dSize;
    if (delta == 2) {
      for (int32_t i = 0; i < length; i++,off+=2) {
        int16_t val = (int16_t)(((int16_t)array[offset++]) & valMask);
        packShort(buf, off, (int16_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int16_t val = (int16_t)(((int16_t)array[offset++]) & valMask);
        packShort(buf, off, (int16_t)(val << shift));
        off += 2;
        _Intel_Pragma("loop_count min=1, max=6")
        for (int32_t j = 2; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed Int12 data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 12)
 *  @param dSize  (IN)  Data item size in bits (must be 12)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackInt12s (const void *ptr, int32_t off, int8_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  int32_t skip = (align)? 1 : 0;
  if (sign) {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t a = (int32_t)buf[off++];
      int32_t b = (int32_t)buf[off++];
      int32_t c = (int32_t)buf[off++];
      int32_t x = (a << 4) | ((b >> 4) & 0x000F);
      int32_t y = (b << 8) | ((c     ) & 0x00FF);
      array[offset++] = (int8_t)((x << 20) >> 20); // sign extend
      array[offset++] = (int8_t)((y << 20) >> 20); // sign extend
      off += skip; // skip extra int8_t in processing-efficient mode
    }
  }
  else {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t a = (int32_t)buf[off++];
      int32_t b = (int32_t)buf[off++];
      int32_t c = (int32_t)buf[off++];
      int32_t x = (a << 4) | ((b >> 4) & 0x000F);
      int32_t y = (b << 8) | ((c     ) & 0x00FF);
      array[offset++] = (int8_t)(x & 0x0FFF); // clear high-order bits
      array[offset++] = (int8_t)(y & 0x0FFF); // clear high-order bits
      off += skip; // skip extra int8_t in processing-efficient mode
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for signed Int12 data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 12)
 *  @param dSize  (IN)  Data item size in bits (must be 12)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packInt12s (void *ptr, int32_t off, const int8_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  int32_t skip = (align)?  1 : 0;
  int32_t mask = (sign )? -1 : ((int32_t)__INT64_C(0xFF));
  for (int32_t i = 0; i < length; i+=2) {
    int32_t first  = ((int32_t)array[offset++]) & mask;
    int32_t second = ((int32_t)array[offset++]) & mask;
    buf[off++] = (int8_t)(first >> 4);
    buf[off++] = (int8_t)((first << 4) | ((second >> 8) & 0x0F));
    buf[off++] = (int8_t)(second);
    off += skip; // skip extra int8_t in processing-efficient mode
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed int8_t data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void unpackBytes (const void *ptr, int32_t off, int8_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
#if (1 == 1) || (BYTE_ORDER == BIG_ENDIAN)
  if ((fSize == 8) && (dSize == 8)) {
    // Fast array copy
    memcpy(&array[offset], &buf[off], length*1);
    return;
  }
#endif
  int32_t delta = fSize / 8; // int8_t offset delta
  if (sign) {
    if (dSize == 8) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int8_t)unpackByte(buf, off);
      }
    }
    else {
      int32_t shift  = 8 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int8_t)(unpackByte(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == 8) {
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int8_t)(unpackByte(buf, off) & 0xFF);
      }
    }
    else {
      int32_t shift  = 8 - dSize;
      for (int32_t i = 0; i < length; i++,off+=delta) {
        array[offset++] = (int8_t)((unpackByte(buf, off) & 0xFF) >> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned int8_t data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static __attribute__((flatten)) void packBytes (void *ptr, int32_t off, const int8_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
#if (1 == 1) || (BYTE_ORDER == BIG_ENDIAN)
  if ((fSize == 8) && (dSize == 8)) {
    // Fast array copy
    memcpy(&buf[off], &array[offset], length*1);
    return;
  }
#endif
  int32_t delta = fSize / 8; // int8_t offset delta
  int8_t valMask = (sign)? ((int8_t)-1) : ((int8_t)__INT64_C(0xFF)); // Bit mask for input value (controls sign-extend)
  if (dSize == 8) {
    if (delta == 1) {
      for (int32_t i = 0; i < length; i++,off+=1) {
        int8_t val = (int8_t)(((int8_t)array[offset++]) & valMask);
        packByte(buf, off, val);
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int8_t val = (int8_t)(((int8_t)array[offset++]) & valMask);
        packByte(buf, off, val);
        off += 1;
        _Intel_Pragma("loop_count min=1, max=7")
        for (int32_t j = 1; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int32_t shift = 8 - dSize;
    if (delta == 1) {
      for (int32_t i = 0; i < length; i++,off+=1) {
        int8_t val = (int8_t)(((int8_t)array[offset++]) & valMask);
        packByte(buf, off, (int8_t)(val << shift));
      }
    }
    else {
      for (int32_t i = 0; i < length; i++) {
        int8_t val = (int8_t)(((int8_t)array[offset++]) & valMask);
        packByte(buf, off, (int8_t)(val << shift));
        off += 1;
        _Intel_Pragma("loop_count min=1, max=7")
        for (int32_t j = 1; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for signed Int4 (nibble) data.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 4)
 *  @param dSize  (IN)  Data item size in bits (must be 4)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackNibbles (const void *ptr, int32_t off, int8_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  if (sign) {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (int8_t)((b << 24) >> 28); // shift & sign extend
      array[offset++] = (int8_t)((b << 28) >> 28); // shift & sign extend
    }
  }
  else {
    for (int32_t i = 0; i < length; i+=2) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (int8_t)((b >> 4) & 0xF);
      array[offset++] = (int8_t)((b     ) & 0xF);
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for signed Int4 (nibble) data.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 4)
 *  @param dSize  (IN)  Data item size in bits (must be 4)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packNibbles (void *ptr, int32_t off, const int8_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Pack function for signed and unsigned are identical for nibble data, hence
  // 'sign' is unused here, but included in function definition for consistency.
  for (int32_t i = 0; i < length; i+=2) {
    int32_t first  = (int32_t)array[offset++];
    int32_t second = (int32_t)array[offset++];
    buf[off++] = (int8_t)((first << 4) | (second & 0xF));
  }
}
/** <b>Internal Use Only:</b> Fast unpack method for bit data. Each bit in the
 *  input buffer will be checked, a 0 bit will correspond to the value 0 and a
 *  1 bit will correspond to the value 1.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
 *  @param fSize  (IN)  Item packing field size in bits (must be 1)
 *  @param dSize  (IN)  Data item size in bits (must be 1)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackBits (const void *ptr, int32_t off, int8_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  if (sign) {
    // This uses sign-extending principles to get each bit as 0 or -1 which reflects
    // the fact that 0/-1 and not 0/+1 are the available values in a one-bit use of
    // twos-complement.
    for (int32_t i = 0; i < length; i+=8) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (int8_t)((b << 24) >> 31);
      array[offset++] = (int8_t)((b << 25) >> 31);
      array[offset++] = (int8_t)((b << 26) >> 31);
      array[offset++] = (int8_t)((b << 27) >> 31);
      array[offset++] = (int8_t)((b << 28) >> 31);
      array[offset++] = (int8_t)((b << 29) >> 31);
      array[offset++] = (int8_t)((b << 30) >> 31);
      array[offset++] = (int8_t)((b << 31) >> 31);
    }
  }
  else {
    for (int32_t i = 0; i < length; i+=8) {
      int32_t b = (int32_t)buf[off++];
      array[offset++] = (int8_t)((b >> 7) & 0x1);
      array[offset++] = (int8_t)((b >> 6) & 0x1);
      array[offset++] = (int8_t)((b >> 5) & 0x1);
      array[offset++] = (int8_t)((b >> 4) & 0x1);
      array[offset++] = (int8_t)((b >> 3) & 0x1);
      array[offset++] = (int8_t)((b >> 2) & 0x1);
      array[offset++] = (int8_t)((b >> 1) & 0x1);
      array[offset++] = (int8_t)((b     ) & 0x1);
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for bit data. Each value in the
 *  input array will be checked, a zero value will correspond to the bit 0 and
 *  any non-zero value will correspond to the bit 1.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
 *  @param fSize  (IN)  Item packing field size in bits (must be 1)
 *  @param dSize  (IN)  Data item size in bits (must be 1)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packBits (void *ptr, int32_t off, const int8_t *array, int32_t offset, int32_t length, int32_t fSize, int32_t dSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Pack function for signed and unsigned are identical for bit data, hence
  // 'sign' is unused here, but included in function definition for consistency.
  for (int32_t i = 0; i < length; i+=8) {
    int32_t b = 0;
    b |= (((int32_t)array[offset++]) << 7) & 0x80;
    b |= (((int32_t)array[offset++]) << 6) & 0x40;
    b |= (((int32_t)array[offset++]) << 5) & 0x20;
    b |= (((int32_t)array[offset++]) << 4) & 0x10;
    b |= (((int32_t)array[offset++]) << 3) & 0x08;
    b |= (((int32_t)array[offset++]) << 2) & 0x04;
    b |= (((int32_t)array[offset++]) << 1) & 0x02;
    b |= (((int32_t)array[offset++])     ) & 0x01;
    buf[off++] = (int8_t)b;
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array, where the data is
 *  aligned to 32-bit word boundaries.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array  (OUT) Output value array (not null)
 *  @param chan   (OUT) Output channel tag array (null if n/a)
 *  @param evt    (OUT) Output event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntWord32 (const void *ptr, int32_t off, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 32 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int32_t valMask  = (sign)? ((int32_t)-1) : (~(((int32_t)-1) << dSize));
  for (int32_t i = 0; i < length; i++,off+=4) {
    int32_t value = unpackInt(buf, off);
    array[i] = (int8_t)((value >> (32-dSize)) & valMask);
    if (chan != NULL) chan[i] = (value >> (pSize      )) & chanMask;
    if (evt  != NULL) evt[i]  = (value >> (pSize+cSize)) & evtMask;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array, where the data is
 *  aligned to 32-bit word boundaries.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input value array
 *  @param chan   (IN)  Input channel tag array (null if n/a)
 *  @param evt    (IN)  Input event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntWord32 (void *ptr, int32_t off, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 32 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int32_t valMask  = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFF));
  for (int32_t i = 0; i < length; i++,off+=4) {
    int32_t val   = (int32_t)(((int32_t)array[i]) & valMask);
    int32_t value = val << (32-dSize);
    if (chan != NULL) value |= (chan[i] & chanMask) << (pSize);
    if (evt  != NULL) value |= (evt[i]  & evtMask ) << (pSize+cSize);
    packInt(buf, off, value);
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array  (OUT) Output value array (not null)
 *  @param chan   (OUT) Output channel tag array (null if n/a)
 *  @param evt    (OUT) Output event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntWord64 (const void *ptr, int32_t off, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int64_t valMask  = (sign)? ((int64_t)-1) : (~(((int64_t)-1) << dSize));
  if (dSize == 32) {
    // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
    // value, so use 32-bit operations to improve performance
    for (int32_t i = 0; i < length; i++,off+=8) {
      int32_t val   = unpackInt(buf, off);
      int32_t value = unpackInt(buf, off+4);
      array[i] = (int8_t)(val & valMask);
      if (chan != NULL) chan[i] = ((int32_t)(value >> (pSize      ))) & chanMask;
      if (evt  != NULL) evt[i]  = ((int32_t)(value >> (pSize+cSize))) & evtMask;
    }
  }
  else {
    for (int32_t i = 0; i < length; i++,off+=8) {
      int64_t value = unpackLong(buf, off);
      array[i] = (int8_t)((value >> (64-dSize)) & valMask);
      if (chan != NULL) chan[i] = ((int32_t)(value >> (pSize      ))) & chanMask;
      if (evt  != NULL) evt[i]  = ((int32_t)(value >> (pSize+cSize))) & evtMask;
    }
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input value array
 *  @param chan   (IN)  Input channel tag array (null if n/a)
 *  @param evt    (IN)  Input event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntWord64 (void *ptr, int32_t off, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  int64_t valMask  = (sign)? ((int64_t)-1) : ((int64_t)__INT64_C(0xFF));
  if (dSize == 32) {
    // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
    // value, so use 32-bit operations to improve performance
    for (int32_t i = 0; i < length; i++,off+=8) {
      int32_t val   = (int32_t)(((int64_t)array[i]) & valMask);
      int32_t value = 0;
      if (chan != NULL) value  = (chan[i] & chanMask) << (pSize);
      if (evt  != NULL) value |= (evt[i]  & evtMask ) << (pSize+cSize);
      packInt(buf, off,   val);
      packInt(buf, off+4, value);
    }
  }
  else {
    for (int32_t i = 0; i < length; i++,off+=8) {
      int64_t val   = (int64_t)(((int64_t)array[i]) & valMask);
      int64_t value = val << (64-dSize);
      if (chan != NULL) value |= ((int64_t)(chan[i] & chanMask)) << (pSize);
      if (evt  != NULL) value |= ((int64_t)(evt[i]  & evtMask )) << (pSize+cSize);
      packLong(buf, off, value);
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (IN)  Packet payload buffer pointer
 *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array  (OUT) Output value array (not null)
 *  @param chan   (OUT) Output channel tag array (null if n/a)
 *  @param evt    (OUT) Output event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackFloatWord64 (const void *ptr, int32_t off, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  // When using Float32 the first 32-bits will always the the Float32 value, so
  // use 32-bit operations to improve performance
  for (int32_t i = 0; i < length; i++,off+=8) {
    array[i] = (int8_t)unpackFloat(buf, off);
    int32_t value = unpackInt(buf, off+4);
    if (chan != NULL) chan[i] = (value >> (pSize      )) & chanMask;
    if (evt  != NULL) evt[i]  = (value >> (pSize+cSize)) & evtMask;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array, where the data is
 *  aligned to 64-bit word boundaries.
 *  @param ptr    (I/O) Packet payload buffer pointer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input value array
 *  @param chan   (IN)  Input channel tag array (null if n/a)
 *  @param evt    (IN)  Input event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
static void packFloatWord64 (void *ptr, int32_t off, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int32_t    pSize    = 64 - fSize;
  int32_t    evtMask  = ~(((int32_t)-1) << eSize);
  int32_t    chanMask = ~(((int32_t)-1) << cSize);
  // When using Float32 the first 32-bits will always the the Float32 value, so
  // use 32-bit operations to improve performance
  for (int32_t i = 0; i < length; i++,off+=8) {
    float val   = (float)array[i];
    int32_t   value = 0;
    if (chan != NULL) value  = (chan[i] & chanMask) << (pSize);
    if (evt  != NULL) value |= (evt[i]  & evtMask ) << (pSize+cSize);
    packFloat(buf, off,   val);
    packInt(  buf, off+4, value);
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntBuffer32 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_dSize  = 32 - dSize;    // pre-compute "32 - dSize" for efficiency
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      if (sign) {
        // sign extend
        array[offset] = (int8_t)((value << _bits_dSize) >>  _bits_dSize);
      }
      else {
        // leave top bits (which default to 0) as 0
        array[offset] = (int8_t)value;
      }
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntBuffer32 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  int32_t valMask      = (sign)? ((int32_t)-1) : ((int32_t)__INT64_C(0xFF)); // Bit mask for input value (controls sign-extend)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t arrayValue = ((int32_t)array[offset]) & valMask;
      int32_t value      = (int32_t)((arrayValue) << (32 - dSize));
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackIntBuffer64 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_dSize  = 64 - dSize;    // pre-compute "64 - dSize" for efficiency
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      if (sign) {
        // sign extend
        array[offset] = (int8_t)((value << _bits_dSize) >>  _bits_dSize);
      }
      else {
        // leave top bits (which default to 0) as 0
        array[offset] = (int8_t)value;
      }
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packIntBuffer64 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  int64_t valMask      = (sign)? ((int64_t)-1) : ((int64_t)__INT64_C(0xFF)); // Bit mask for input value (controls sign-extend)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t arrayValue = ((int64_t)array[offset]) & valMask;
      int64_t value      = (int64_t)((arrayValue) << (64 - dSize));
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackFloatBuffer64 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)intBitsToFloat((int32_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packFloatBuffer64 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      float  arrayValue = (float)array[offset];
      int64_t   value      = ((int64_t)floatToRawIntBits(arrayValue)) << 32;
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT1Buffer32 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_SignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT1Buffer32 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT1, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT1Buffer64 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_SignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT1Buffer64 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT1, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT2Buffer32 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_SignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT2Buffer32 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT2, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT2Buffer64 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_SignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT2Buffer64 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT2, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT3Buffer32 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_SignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT3Buffer32 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT3, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT3Buffer64 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_SignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT3Buffer64 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT3, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT4Buffer32 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_SignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT4Buffer32 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT4, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT4Buffer64 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_SignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT4Buffer64 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT4, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT5Buffer32 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_SignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT5Buffer32 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT5, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT5Buffer64 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_SignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT5Buffer64 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT5, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT6Buffer32 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_SignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT6Buffer32 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_SignedVRT6, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackSignedVRT6Buffer64 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_SignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packSignedVRT6Buffer64 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_SignedVRT6, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT1Buffer32 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_UnsignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT1Buffer32 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT1, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT1Buffer64 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_UnsignedVRT1, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT1Buffer64 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT1, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT2Buffer32 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_UnsignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT2Buffer32 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT2, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT2Buffer64 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_UnsignedVRT2, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT2Buffer64 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT2, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT3Buffer32 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_UnsignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT3Buffer32 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT3, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT3Buffer64 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_UnsignedVRT3, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT3Buffer64 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT3, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT4Buffer32 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_UnsignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT4Buffer32 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT4, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT4Buffer64 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_UnsignedVRT4, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT4Buffer64 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT4, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT5Buffer32 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_UnsignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT5Buffer32 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT5, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT5Buffer64 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_UnsignedVRT5, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT5Buffer64 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT5, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT6Buffer32 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t allBitsSet   = (int32_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int32_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int32_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_UnsignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 32-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT6Buffer32 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
  int32_t    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int32_t value      = (int32_t)toVRTFloat(DataItemFormat_UnsignedVRT6, dSize, arrayValue) << (32 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 32 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 32)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param ptr       (IN)  Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void unpackUnsignedVRT6Buffer64 (const void *ptr, int32_t bitOffset, int8_t *array, int32_t *chan, int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  const char *buf = (const char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int64_t allBitsSet   = (int64_t)(-1);          // Mask value with all bits set
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }
    // ==== Step 1 =============================================================
    if (true) {
      int64_t value    = 0; // Bit accumulator
      int32_t    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int32_t    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t   octet   = buf[bitOffset>>3];
        int64_t mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      array[offset] = (int8_t)fromVRTFloat(DataItemFormat_UnsignedVRT6, dSize, (int64_t)value);
    }
    // ==== Step 2 =============================================================
    bitOffset += uSize;
    // ==== Step 3 =============================================================
    if (evt != NULL) {
      int32_t value    = 0;
      int32_t needBits = eSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }
    // ==== Step 4 =============================================================
    if (chan != NULL) {
      int32_t value    = 0;
      int32_t needBits = cSize; // bits remaining to get
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t octet   = buf[bitOffset>>3];
        int32_t  mask    = ~(((int32_t)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match 64-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param ptr       (I/O) Packet payload buffer pointer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
static void packUnsignedVRT6Buffer64 (void *ptr, int32_t bitOffset, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length, int32_t fSize, int32_t dSize, int32_t eSize, int32_t cSize, bool align, bool sign) {
  char *buf = (char*)ptr;
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int32_t    uSize        = fSize - dSize - eSize - cSize;
  int32_t    offset       = 0;
  int32_t    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
  int32_t    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int32_t    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  if ((evt == NULL) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    if (chan == NULL) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  for (int32_t i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
        _Intel_Pragma("loop_count min=1, max=8")
        while (needBits > 0) {
          int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
          int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
          int32_t old = (int32_t)buf[bitOffset>>3];
          buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }
    // ==== Step 1 =============================================================
    if (true) {
      double arrayValue = (double)array[offset];
      int64_t value      = (int64_t)toVRTFloat(DataItemFormat_UnsignedVRT6, dSize, arrayValue) << (64 - dSize);
      int32_t    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int64_t old = (int64_t)buf[bitOffset>>3];
        int64_t val = value >> (64 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int32_t needBits = uSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=8")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int32_t value    = evt[offset] << (32 - eSize);
      int32_t needBits = eSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=2")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int32_t value    = chan[offset] << (32 - cSize);
      int32_t needBits = cSize; // bits remaining to set
      _Intel_Pragma("loop_count min=1, max=3")
      while (needBits > 0) {
        int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
        int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
        int32_t old = (int32_t)buf[bitOffset>>3];
        int32_t val = value >> (32 - avail);
        buf[bitOffset>>3] = (int8_t)((old & keepMask) | (val & ~keepMask));
        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }
    // ==== Done ===============================================================
    offset++;
  }
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int32_t needBits = 64 - (bitOffset & bitmask); // bits remaining to set
    _Intel_Pragma("loop_count min=0, max=8")
    while ((needBits > 0) && (needBits < 64)) {
      int32_t  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int32_t  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      int8_t keepHi   = (int8_t)(0xFF << avail);                 // High-order bits to keep
      int8_t keepLo   = (int8_t)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      int8_t keepMask = (int8_t)(keepHi | keepLo);               // Bits to keep
      int32_t old = (int32_t)buf[bitOffset>>3];
      buf[bitOffset>>3] = (int8_t)(old & keepMask); // <-- this differs from the others since val is always 0
      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
int8_t* vrt::PackUnpack::unpackAsByte (PayloadFormat pf, const void *ptr, int32_t off, int8_t *array, int32_t *chan, int32_t *evt, int32_t length) {
  const char *buf = (const char*)ptr;
  if (!pf.isValid()) {
    throw VRTException(pf.getValid());
  }
  int32_t            fSize  = pf.getItemPackingFieldSize();
  int32_t            dSize  = pf.getDataItemSize();
  int32_t            eSize  = pf.getEventTagSize();
  int32_t            cSize  = pf.getChannelTagSize();
  bool        proc   = pf.isProcessingEfficient();
  bool        sign   = pf.isSigned();
  DataItemFormat format = pf.getDataItemFormat();
  bool        noTags;
  if (eSize == 0) evt  = NULL; // no event tags, ignore any array passed in
  if (cSize == 0) chan = NULL; // no channel tags, ignore any array passed in
  noTags = (chan == NULL) && (evt == NULL);
  if (proc && noTags && (fSize >= 17)) {
    // Use faster "effective field size" when ignoring Event & Channel Tags
    fSize = (fSize <= 32)? 32 : 64;
  }
  switch (format) {
    case DataItemFormat_SignedInt:   // FALLTHROUGH
    case DataItemFormat_UnsignedInt:
      // ---- Try fast methods -------------------------------------------------
      if (noTags) {
        switch (fSize) {
          case  8: unpackBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 16: unpackShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 24: unpackInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 32: unpackInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 64: unpackLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
        }
      }
      if (fSize == dSize) { // implicit noTags=true in this case
        switch (fSize) {
          case  1: if ((length % 8) == 0) { unpackBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          case  4: if ((length % 2) == 0) { unpackNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          case 12: if ((length % 2) == 0) { unpackInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
        }
      }
      if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
        if (fSize <= 32) {
          unpackIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      }
      // ---- Fall back to slow method -----------------------------------------
      if (fSize <= 32) {
        unpackIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_Float:
      // ---- Try fast methods -------------------------------------------------
      if (fSize == dSize) { // implicit noTags=true in this case
        unpackFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
      }
      if ((proc && (fSize >= 33)) || (fSize == 64)) {
        unpackFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      // ---- Fall back to slow method -----------------------------------------
      unpackFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
    case DataItemFormat_Double:
      // ---- Only fast method for double (yea!) -------------------------------
      unpackDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
    case DataItemFormat_SignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    default:
      throw VRTException("Unpacking of VRT float types not supported yet");
  }
}
void vrt::PackUnpack::packAsByte (PayloadFormat pf, void *ptr, int32_t off, const int8_t *array, const int32_t *chan, const int32_t *evt, int32_t length) {
  char *buf = (char*)ptr;
  if (!pf.isValid()) {
    throw VRTException(pf.getValid());
  }
  int32_t            fSize  = pf.getItemPackingFieldSize();
  int32_t            dSize  = pf.getDataItemSize();
  int32_t            eSize  = pf.getEventTagSize();
  int32_t            cSize  = pf.getChannelTagSize();
  bool        proc   = pf.isProcessingEfficient();
  bool        sign   = pf.isSigned();
  DataItemFormat format = pf.getDataItemFormat();
  bool        noTags;
  if (eSize == 0) evt  = NULL; // no event tags, ignore any array passed in
  if (cSize == 0) chan = NULL; // no channel tags, ignore any array passed in
  noTags = (chan == NULL) && (evt == NULL);
  if (proc && noTags && (fSize >= 17)) {
    // Use faster "effective field size" when ignoring Event & Channel Tags
    fSize = (fSize <= 32)? 32 : 64;
  }
  switch (format) {
    case DataItemFormat_SignedInt:   // FALLTHROUGH
    case DataItemFormat_UnsignedInt:
      // ---- Try fast methods -------------------------------------------------
      if (noTags) {
        switch (fSize) {
          case  8: packBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 16: packShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 24: packInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 32: packInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 64: packLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
        }
      }
      if (fSize == dSize) { // implicit noTags=true in this case
        switch (fSize) {
          case  1: if ((length % 8) == 0) { packBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          case  4: if ((length % 2) == 0) { packNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          case 12: if ((length % 2) == 0) { packInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
        }
      }
      if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
        if (fSize <= 32) {
          packIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      }
      // ---- Fall back to slow method -----------------------------------------
      if (fSize <= 32) {
        packIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_Float:
      // ---- Try fast methods -------------------------------------------------
      if (fSize == dSize) { // implicit noTags=true in this case
        packFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
      }
      if ((proc && (fSize >= 33)) || (fSize == 64)) {
        packFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      // ---- Fall back to slow method -----------------------------------------
      packFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
    case DataItemFormat_Double:
      // ---- Only fast method for double (yea!) -------------------------------
      packDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
    case DataItemFormat_SignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    default:
      throw VRTException("Packing of VRT float types not supported yet");
  }
}


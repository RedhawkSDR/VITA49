##
## This file is protected by Copyright. Please refer to the COPYRIGHT file
## distributed with this source distribution.
##
## This file is part of REDHAWK.
##
## REDHAWK is free software: you can redistribute it and/or modify it
## under the terms of the GNU Lesser General Public License as published by the
## Free Software Foundation, either version 3 of the License, or (at your
## option) any later version.
##
## REDHAWK is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
## for more details.
##
## You should have received a copy of the GNU Lesser General Public License
## along with this program.  If not, see http://www.gnu.org/licenses/.
##

## START COMMENTS
/** <b>Internal Use Only:</b> Pack/unpack methods used by {@link BasicDataPacket}. <br>
 *  <br>
 *  <h2>Usage Notes</h2>
 *  <ul>
 *    <li>If the data type of the array given does not match the PayloadFormat,
 *        the handling of any values outside of the mutual range limits is
 *        undefined. <i>(For example inserting the value 1024 from an Int32
 *        array into a PayloadFormat of Int8.)</i></li>
 *    <li>If the data type of the array given does not match the PayloadFormat,
 *        the handling of any values outside of the mutual precision limits
 *        will result in a loss of precision. (For example inserting the value
 *        3.14 from an Float32 array into a PayloadFormat of Int8 will result in
 *        the value 3 being set.)</li>
 *    <li>The handling of NaN, +Inf, and -Inf when converting from a floating-point
 *        type to an integer type is undefined.</li>
 *    <li>All floating-point NaN values are considered equal any NaN may be
 *        converted to any other NaN (i.e. "signaling NaN values" are not
 *        preserved).</li>
 *    <li>All floating-point 0.0 values (i.e. -0.0 and +0.0) are considered equal
 *        and any 0.0 may be converted to any other 0.0 (i.e. the sign bit on
 *        a 0.0 is not preserved).</li>
 *  </ul>
 *  <h2>Performance Characteristics</h2>
 *  Great effort has been made to optimize the most commonly used pack/unpack
 *  conversions. The table below shows the relative speed at which a given
 *  PayloadFormat can be packed/unpacked from a buffer.
 *  <pre>
 *       Speed   | Item Packing | Data Item |  Event   | Channel  | Efficient | Notes |
 *        [0]    |  Field Size  | Size [1]  | Tag Size | Tag Size |   Mode    |       |
 *    -----------+--------------+-----------+----------+----------+-----------+-------+
 *         A+    |       8      |     8     |    0     |     0    | Link/Proc |       |
 *     (Fastest) |              |           |          |          |           |       |
 *    -----------+--------------+-----------+----------+----------+-----------+-------+
 *         A     |       1      |     1     |    0     |     0    | Link/Proc |  [2]  |
 *               |       4      |     4     |    0     |     0    | Link/Proc |  [2]  |
 *               |      12      |    12     |    0     |     0    | Link/Proc |  [2]  |
 *               |      16      |    16     |    0     |     0    | Link/Proc |       |
 *               |      24      |    24     |    0     |     0    | Link/Proc |       |
 *               |      32      |    32     |    0     |     0    | Link/Proc |       |
 *               |      64      |    64     |    0     |     0    | Link/Proc |       |
 *               |      32      |   float   |    0     |     0    | Link/Proc |       |
 *               |      64      |   double  |    0     |     0    | Link/Proc |       |
 *    -----------+--------------+-----------+----------+----------+-----------+-------+
 *         A-    |       8      |  1 to  7  |    -     |     -    | Link/Proc |  [3]  |
 *               |      16      |  1 to 15  |    -     |     -    | Link/Proc |  [3]  |
 *               |      24      |  1 to 23  |    -     |     -    | Link/Proc |  [3]  |
 *               |      32      |  1 to 31  |    -     |     -    | Link/Proc |  [3]  |
 *               |      64      |  1 to 63  |    -     |     -    | Link/Proc |  [3]  |
 *               |   17 to 63   |  1 to 63  |    -     |     -    |    Proc   |       |
 *    -----------+--------------+-----------+----------+----------+-----------+-------+
 *         B     |      32      |  1 to 31  |  0 to 7  |  0 to 15 | Link/Proc |       |
 *               |      64      |  1 to 63  |  0 to 7  |  0 to 15 | Link/Proc |       |
 *               |      64      |   float   |  0 to 7  |  0 to 15 | Link/Proc |       |
 *               |   17 to 63   |  1 to 63  |  0 to 7  |  0 to 15 |    Proc   |       |
 *               |   33 to 63   |   float   |  0 to 7  |  0 to 15 |    Proc   |       |
 *    -----------+--------------+-----------+----------+----------+-----------+-------+
 *         D+    |    1 to 15   |  1 to 15  |    -     |     -    | Link/Proc | [3,4] |
 *               |   17 to 63   |  1 to 63  |    -     |     -    |    Link   |  [3]  |
 *               |   33 to 63   |   float   |    -     |     -    |    Link   |  [3]  |
 *    -----------+--------------+-----------+----------+----------+-----------+-------+
 *         D     |    1 to 15   |  1 to 15  |  0 to 7  |  0 to 15 | Link/Proc |  [4]  |
 *     (Slowest) |   17 to 63   |  1 to 63  |  0 to 7  |  0 to 15 |    Link   |       |
 *               |   33 to 63   |   float   |  0 to 7  |  0 to 15 |    Link   |       |
 *    -----------+--------------+-----------+----------+----------+-----------+-------+
 *
 *    Notes:
 *      [0] The "speed" rating is an arbitrary "grade" indicating how fast the accessing
 *          of a given Payload Format is relative to other Payload Formats, where an
 *          "A+" equates to a simple memcpy in C++ and a "D" equates to a complex
 *          processing algorithm with nested loops and heavy use of bit manipulation.
 *          In practice the speed difference in speed between a "B" and an "A" is
 *          small whereas the difference between a "B" and a "D" is many orders of
 *          magnitude slower. <i>(For example, on one test of ~2 million iterations using
 *          both link efficient ("D") and processing efficient ("B") and with Packing
 *          Field Sizes between 33 and 63 bits it took 38.2 sec for link efficient vs
 *          &lt;0.1 sec for processing efficient.)</i>
 *      [1] All Data items are signed/unsigned integers with the bit count as shown,
 *          except for "float" and "double" which represent IEEE-754 floating-point
 *          values.
 *      [2] Fast handling of Int1 and Int4/Int12 data by unpacking eight/two elements
 *          at a time. Total length must be a multiple of 8/2 to use this mode.
 *      [3] Event/Channel tags (if present) are not read and set to zero on write.
 *      [4] Future versions may provide a faster implementation for 1 to 15 bit
 *          field sizes when in Processing Efficient mode.
 *  </pre>
 *  Currently all of the VRT floating-point formats are using algorithms that
 *  are similar to the "D+" and "D" ones used for IEEE-754 float data. Future
 *  versions may provide a faster implementation for situations where the data
 *  item size is 8/16/32/64 bits and/or processing-efficient mode is used. <br>
 *  <br>
 *  Regardless of the algorithm used herein, the accessing of IEEE-754
 *  floating-point values will always be faster than the accessing of VRT
 *  floating-point values since the former benefit from hardware acceleration.
 * 
 *  @author Auto-Generated   (source code)
 *  @author  (code template)
 */
## END

## START BITS
/** <b>Internal Use Only:</b> Fast unpack method for bit data. Each bit in the
 *  input buffer will be checked, a 0 bit will correspond to the value 0 and a
 *  1 bit will correspond to the value 1.
 *  @param buf    (IN)  Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
 *  @param fSize  (IN)  Item packing field size in bits (must be 1)
 *  @param dSize  (IN)  Data item size in bits (must be 1)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
private static void #namespace#unpackBits (const byte[] buf, int off, #type#[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
  if (sign) {
    // This uses sign-extending principles to get each bit as 0 or -1 which reflects
    // the fact that 0/-1 and not 0/+1 are the available values in a one-bit use of
    // twos-complement.
    for (int i = 0; i < length; i+=8) {
      int b = (int)buf[off++];
      array[offset++] = (#type#)((b << 24) >> 31);
      array[offset++] = (#type#)((b << 25) >> 31);
      array[offset++] = (#type#)((b << 26) >> 31);
      array[offset++] = (#type#)((b << 27) >> 31);
      array[offset++] = (#type#)((b << 28) >> 31);
      array[offset++] = (#type#)((b << 29) >> 31);
      array[offset++] = (#type#)((b << 30) >> 31);
      array[offset++] = (#type#)((b << 31) >> 31);
    }
  }
  else {
    for (int i = 0; i < length; i+=8) {
      int b = (int)buf[off++];
      array[offset++] = (#type#)((b >> 7) & 0x1);
      array[offset++] = (#type#)((b >> 6) & 0x1);
      array[offset++] = (#type#)((b >> 5) & 0x1);
      array[offset++] = (#type#)((b >> 4) & 0x1);
      array[offset++] = (#type#)((b >> 3) & 0x1);
      array[offset++] = (#type#)((b >> 2) & 0x1);
      array[offset++] = (#type#)((b >> 1) & 0x1);
      array[offset++] = (#type#)((b     ) & 0x1);
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for bit data. Each value in the
 *  input array will be checked, a zero value will correspond to the bit 0 and
 *  any non-zero value will correspond to the bit 1.
 *  @param buf    (I/O) Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
 *  @param fSize  (IN)  Item packing field size in bits (must be 1)
 *  @param dSize  (IN)  Data item size in bits (must be 1)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
private static void #namespace#packBits (byte[] buf, int off, const #type#[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
  // Pack function for signed and unsigned are identical for bit data, hence
  // 'sign' is unused here, but included in function definition for consistency.
  for (int i = 0; i < length; i+=8) {
    int b = 0;
    b |= (((#container#)array[offset++]) << 7) & 0x80;
    b |= (((#container#)array[offset++]) << 6) & 0x40;
    b |= (((#container#)array[offset++]) << 5) & 0x20;
    b |= (((#container#)array[offset++]) << 4) & 0x10;
    b |= (((#container#)array[offset++]) << 3) & 0x08;
    b |= (((#container#)array[offset++]) << 2) & 0x04;
    b |= (((#container#)array[offset++]) << 1) & 0x02;
    b |= (((#container#)array[offset++])     ) & 0x01;
    buf[off++] = (byte)b;
  }
}
## END

## START BOOLEAN_BITS
/** <b>Internal Use Only:</b> Fast unpack method for bit data. Each bit in the
 *  input buffer will be checked, a 0 bit will correspond to the value false and
 *  a 1 bit will correspond to the value true.
 *  @param buf    (IN)  Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
 *  @param fSize  (IN)  Item packing field size in bits (must be 1)
 *  @param dSize  (IN)  Data item size in bits (must be 1)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
private static void #namespace#unpackBits (const byte[] buf, int off, boolean[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
  // Unpack function for signed and unsigned are identical for bit data, hence
  // 'sign' is unused here, but included in function definition for consistency.
  for (int i = 0; i < length; i+=8) {
    byte b = buf[off++];
    array[offset++] = ((b & 0x80) != 0);
    array[offset++] = ((b & 0x40) != 0);
    array[offset++] = ((b & 0x20) != 0);
    array[offset++] = ((b & 0x10) != 0);
    array[offset++] = ((b & 0x08) != 0);
    array[offset++] = ((b & 0x04) != 0);
    array[offset++] = ((b & 0x02) != 0);
    array[offset++] = ((b & 0x01) != 0);
  }
}
/** <b>Internal Use Only:</b> Fast pack method for bit data. Each value in the
 *  input array will be checked, a false value will correspond to the bit 0 and
 *  a true value will correspond to the bit 1.
 *  @param buf    (I/O) Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
 *  @param fSize  (IN)  Item packing field size in bits (must be 1)
 *  @param dSize  (IN)  Data item size in bits (must be 1)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
private static void #namespace#packBits (byte[] buf, int off, const boolean[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
  // Pack function for signed and unsigned are identical for bit data, hence
  // 'sign' is unused here, but included in function definition for consistency.
  for (int i = 0; i < length; i+=8) {
    int b = 0;
    b |= (array[offset++])? 0x80 : 0x00;
    b |= (array[offset++])? 0x40 : 0x00;
    b |= (array[offset++])? 0x20 : 0x00;
    b |= (array[offset++])? 0x10 : 0x00;
    b |= (array[offset++])? 0x08 : 0x00;
    b |= (array[offset++])? 0x04 : 0x00;
    b |= (array[offset++])? 0x02 : 0x00;
    b |= (array[offset++])? 0x01 : 0x00;
    buf[off++] = (byte)b;
  }
}
## END

## START NIBBLES
/** <b>Internal Use Only:</b> Fast unpack method for signed Int4 (nibble) data.
 *  @param buf    (IN)  Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 4)
 *  @param dSize  (IN)  Data item size in bits (must be 4)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
private static void #namespace#unpackNibbles (const byte[] buf, int off, #type#[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
  if (sign) {
    for (int i = 0; i < length; i+=2) {
      int b = (int)buf[off++];
      array[offset++] = (#type#)((b << 24) >> 28); // shift & sign extend
      array[offset++] = (#type#)((b << 28) >> 28); // shift & sign extend
    }
  }
  else {
    for (int i = 0; i < length; i+=2) {
      int b = (int)buf[off++];
      array[offset++] = (#type#)((b >> 4) & 0xF);
      array[offset++] = (#type#)((b     ) & 0xF);
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for signed Int4 (nibble) data.
 *  @param buf    (I/O) Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 4)
 *  @param dSize  (IN)  Data item size in bits (must be 4)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
private static void #namespace#packNibbles (byte[] buf, int off, const #type#[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
  // Pack function for signed and unsigned are identical for nibble data, hence
  // 'sign' is unused here, but included in function definition for consistency.
  for (int i = 0; i < length; i+=2) {
    int first  = (int)(#ct#)array[offset++];
    int second = (int)(#ct#)array[offset++];
    buf[off++] = (byte)((first << 4) | (second & 0xF));
  }
}
## END

## START INT12S
/** <b>Internal Use Only:</b> Fast unpack method for signed Int12 data.
 *  @param buf    (IN)  Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 12)
 *  @param dSize  (IN)  Data item size in bits (must be 12)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
private static void #namespace#unpackInt12s (const byte[] buf, int off, #type#[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
  int skip = (align)? 1 : 0;
  if (sign) {
    for (int i = 0; i < length; i+=2) {
      int a = (int)buf[off++];
      int b = (int)buf[off++];
      int c = (int)buf[off++];

      int x = (a << 4) | ((b >> 4) & 0x000F);
      int y = (b << 8) | ((c     ) & 0x00FF);

      array[offset++] = (#type#)((x << 20) >> 20); // sign extend
      array[offset++] = (#type#)((y << 20) >> 20); // sign extend
      off += skip; // skip extra byte in processing-efficient mode
    }
  }
  else {
    for (int i = 0; i < length; i+=2) {
      int a = (int)buf[off++];
      int b = (int)buf[off++];
      int c = (int)buf[off++];

      int x = (a << 4) | ((b >> 4) & 0x000F);
      int y = (b << 8) | ((c     ) & 0x00FF);

      array[offset++] = (#type#)(x & 0x0FFF); // clear high-order bits
      array[offset++] = (#type#)(y & 0x0FFF); // clear high-order bits
      off += skip; // skip extra byte in processing-efficient mode
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for signed Int12 data.
 *  @param buf    (I/O) Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 12)
 *  @param dSize  (IN)  Data item size in bits (must be 12)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
private static void #namespace#packInt12s (byte[] buf, int off, const #type#[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
  int skip = (align)?  1 : 0;
  int mask = (sign )? -1 : ((int)#typemask#);
  for (int i = 0; i < length; i+=2) {
    int first  = ((int)(#ct#)array[offset++]) & mask;
    int second = ((int)(#ct#)array[offset++]) & mask;
    buf[off++] = (byte)(first >> 4);
    buf[off++] = (byte)((first << 4) | ((second >> 8) & 0x0F));
    buf[off++] = (byte)(second);
    off += skip; // skip extra byte in processing-efficient mode
  }
}
## END

## START INTEGER
/** <b>Internal Use Only:</b> Fast unpack method for signed #form# data.
 *  @param buf    (IN)  Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
private static #flatten# void #namespace#unpack#Form#s (const byte[] buf, int off, #type#[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
#IF (#typecheck# == #formbytes#) && (#typecheck# == 1) && #JAVA#
  if ((fSize == #formbits#) && (dSize == #formbits#)) {
    // Fast array copy
    System.arraycopy(buf, off, array, offset, length);
    return;
  }
#ELSEIF (#typecheck# == #formbytes#) && #CPP#
#if (#typebytes# == 1) || (BYTE_ORDER == BIG_ENDIAN)
  if ((fSize == #formbits#) && (dSize == #formbits#)) {
    // Fast array copy
    memcpy(&array[offset], &buf[off], length*#typebytes#);
    return;
  }
#endif
#ENDIF

#IF (#formbytes# < 3)
  int delta = fSize / 8; // byte offset delta
#ELSE
  int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
#ENDIF

  if (sign) {
    if (dSize == #formbits#) {
      #inline_recursive#
      for (int i = 0; i < length; i++,off+=delta) {
        array[offset++] = (#type#)unpack#Form#(buf, off);
      }
    }
    else {
      int shift  = #formbits# - dSize;
      #inline_recursive#
      for (int i = 0; i < length; i++,off+=delta) {
        array[offset++] = (#type#)(unpack#Form#(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == #formbits#) {
      #inline_recursive#
      for (int i = 0; i < length; i++,off+=delta) {
        array[offset++] = (#type#)(unpack#Form#(buf, off) & #mask#);
      }
    }
    else {
      int shift  = #formbits# - dSize;
      #inline_recursive#
      for (int i = 0; i < length; i++,off+=delta) {
        array[offset++] = (#type#)((unpack#Form#(buf, off) & #mask#) >>> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned #form# data.
 *  @param buf    (I/O) Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
private static #flatten# void #namespace#pack#Form#s (byte[] buf, int off, const #type#[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
#IF (#typecheck# == #formcheck#) && (#typecheck# == 1) && #JAVA#
  if ((fSize == #formbits#) && (dSize == #formbits#)) {
    // Fast array copy
    System.arraycopy(array, offset, buf, off, length);
    return;
  }
#ELSEIF (#typecheck# == #formcheck#) && ((#typecheck# == 1) || (#typecheck# == 2) || (#typecheck# == 4) || (#typecheck# == 8)) && #CPP#
#if (#typebytes# == 1) || (BYTE_ORDER == BIG_ENDIAN)
  if ((fSize == #formbits#) && (dSize == #formbits#)) {
    // Fast array copy
    memcpy(&buf[off], &array[offset], length*#typebytes#);
    return;
  }
#endif
#ENDIF

#IF (#formbytes# < 3)
  int delta = fSize / 8; // byte offset delta
#ELSE
  int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
#ENDIF
  #form# valMask = (sign)? ((#form#)-1) : ((#form#)#typemask#); // Bit mask for input value (controls sign-extend)

  if (dSize == #formbits#) {
    if (delta == #formbytes#) {
      #inline_recursive#
      for (int i = 0; i < length; i++,off+=#formbytes#) {
        #form# val = (#form#)(((#form#)(#ct#)array[offset++]) & valMask);
        pack#Form#(buf, off, val);
      }
    }
    else {
      for (int i = 0; i < length; i++) {
        #form# val = (#form#)(((#form#)(#ct#)array[offset++]) & valMask);
        pack#Form#(buf, off, val);
        off += #formbytes#;
        #loop1N#
        for (int j = #formbytes#; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int shift = #formbits# - dSize;
    if (delta == #formbytes#) {
      #inline_recursive#
      for (int i = 0; i < length; i++,off+=#formbytes#) {
        #form# val = (#form#)(((#form#)(#ct#)array[offset++]) & valMask);
        pack#Form#(buf, off, (#form#)(val << shift));
      }
    }
    else {
      for (int i = 0; i < length; i++) {
        #form# val = (#form#)(((#form#)(#ct#)array[offset++]) & valMask);
        pack#Form#(buf, off, (#form#)(val << shift));
        off += #formbytes#;
        #loop1N#
        for (int j = #formbytes#; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
## END


## START FPOINT
/** <b>Internal Use Only:</b> Fast unpack method for #form# data.
 *  @param buf    (IN)  Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be #formbits#)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
@SuppressWarnings("cast")
private static #flatten# void #namespace#unpack#Form#s (const byte[] buf, int off, #type#[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
#IF (#formbits# == 64)
  // When using #Form# data, it is required that dSize=64 and fSize=64 so we can
  // skip some of the normal checks we would otherwise do here.
  #inline_recursive#
  for (int i = 0; i < length; i++,off+=#formbytes#) {
    array[offset++] = (#type#)unpack#Form#(buf, off);
  }
#ELSE
  int delta; // byte offset delta
  if (align) delta = (fSize <= 32)? 4 : 8;
  else       delta = fSize / 8;

  #inline_recursive#
  for (int i = 0; i < length; i++,off+=delta) {
    array[offset++] = (#type#)unpack#Form#(buf, off);
  }
#ENDIF
}
/** <b>Internal Use Only:</b>
 *  Fast pack method for #form# data.
 *  @param buf    (I/O) Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be #formbits#)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
@SuppressWarnings("cast")
private static #flatten# void #namespace#pack#Form#s (byte[] buf, int off, const #type#[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
#IF (#formbits# == 64)
  // When using #Form# data, it is required that dSize=64 and fSize=64 so we can
  // skip some of the normal checks we would otherwise do here.
  #inline_recursive#
  for (int i = 0; i < length; i++,off+=#formbytes#) {
    pack#Form#(buf, off, (#form#)array[offset++]);
  }
#ELSE
  int delta; // byte offset delta
  if (align) delta = (fSize <= 32)? 4 : 8;
  else       delta = fSize / 8;

  if (delta == #formbytes#) {
    #inline_recursive#
    for (int i = 0; i < length; i++,off+=#formbytes#) {
      pack#Form#(buf, off, (#form#)array[offset++]);
    }
  }
  else {
    #inline_recursive#
    for (int i = 0; i < length; i++) {
      pack#Form#(buf, off, (#form#)array[offset++]);
      off += #formbytes#;
      #loop1N#
      for (int j = #formbytes#; j < delta; j++) {
        buf[off++] = 0; // set unused bits to zero
      }
    }
  }
#ENDIF
}
## END

## START BUFFER
/** <b>Internal Use Only:</b> Gets the data into an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Unpack 15-bit value mid-buffer:
 *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1a. Pull in the bits from each byte setting them in the accumulator.
 *           Initial:
 *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             value    = [ oooo oooo | oooo oo11 ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             value    = [ oooo oo11 | 1111 1111 ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             value    = [ o111 1111 | 1111 1111 ]
 *             needBits = 0
 *
 *     1b. Clear top bits/sign extend for integers (float would fill value field)
 *         and then set value in output array.
 *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
 *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
 *
 *     2.  Skip over the unused bits
 *
 *     3.  Extract the event tag if present and evt is not null, otherwise skip
 *         over the event tag field.
 *
 *     4.  Extract the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field.
 *  </pre>
 *  @param buf       (IN)  Packet payload buffer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of #wordbits# bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
private static void #namespace#unpack#Form#Buffer#wordbits# (const byte[] buf, int bitOffset, #type#[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int    uSize        = fSize - dSize - eSize - cSize;
  int    offset       = 0;
  #word# allBitsSet   = (#word#)(-1);          // Mask value with all bits set
#IF ((#formcheck# != -4) && (#formcheck# != -100))
  int    _bits_dSize  = #wordbits# - dSize;    // pre-compute "#wordbits# - dSize" for efficiency
#ENDIF
  int    _bits_fSize  = #wordbits# - fSize;    // pre-compute "#wordbits# - fSize" for efficiency
  int    bitmask      = #wordbits# - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)

  for (int i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }

    // ==== Step 1 =============================================================
    if (true) {
      #word# value    = 0; // Bit accumulator
      int    needBits = dSize; // bits remaining to get
      while (needBits > 0) {
        int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte   octet   = buf[bitOffset>>3];
        #word# mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);

        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
#IF (#formcheck# == -4)
      array[offset] = (#type#)intBitsToFloat((int)value);
#ELSEIF (#formcheck# == -100)
      array[offset] = (#type#)fromVRTFloat(DataItemFormat_#Form#, dSize, (long)value);
#ELSE
      if (sign) {
        // sign extend
        array[offset] = (#type#)((value << _bits_dSize) >>  _bits_dSize);
      }
      else {
        // leave top bits (which default to 0) as 0
        array[offset] = (#type#)value;
      }
#ENDIF
    }

    // ==== Step 2 =============================================================
    bitOffset += uSize;

    // ==== Step 3 =============================================================
    if (evt != null) {
      int value    = 0;
      int needBits = eSize; // bits remaining to get
      #loop12#
      while (needBits > 0) {
        int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte octet   = buf[bitOffset>>3];
        int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);

        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      evt[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += eSize;
    }

    // ==== Step 4 =============================================================
    if (chan != null) {
      int value    = 0;
      int needBits = cSize; // bits remaining to get
      #loop13#
      while (needBits > 0) {
        int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte octet   = buf[bitOffset>>3];
        int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);

        value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
        needBits  -= numBits;
        bitOffset += numBits;
      }
      chan[offset] = value; // leave top bits (which default to 0) as 0
    }
    else {
      bitOffset += cSize;
    }
    
    // ==== Done ===============================================================
    offset++;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array. <br>
 *  <br>
 *  Algorithm example:
 *  <pre>
 *     Pack 15-bit value mid-buffer:
 *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
 *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
 *       bitOffset = N*8 + 6;
 *
 *     0.  If using processing-efficient mode to prevent crossing word boundaries
 *         (align) and there are not enough bits available, skip the remaining
 *         bits and start at the next word.
 *
 *     1.  Cast incoming value to match #wordbits#-bit container and then push
 *         bits from the given value and set them in the octets.
 *           Initial:
 *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
 *             needBits = 15
 *
 *           Pass #1:
 *             avail    = 2
 *             numBits  = 2
 *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
 *             needBits = 13
 *
 *           Pass #2:
 *             avail    = 8
 *             numBits  = 8
 *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
 *             needBits = 5
 *
 *           Pass #3:
 *             avail    = 8
 *             numBits  = 5  (only need 5 more)
 *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
 *             needBits = 0
 *
 *     2.  Set the unused bits to 0.
 *
 *     3.  Insert the event tag if present and evt is not null, otherwise skip
 *         over the event tag field. If the event tag is present, but evt is
 *         null, set the event tag to 0.
 *
 *     4.  Insert the channel tag if present and chan is not null, otherwise
 *         skip over the channel tag field. If the channel tag is present, but
 *         chan is null, set the channel tag to 0.
 *  </pre>
 *  @param buf       (I/O) Packet payload buffer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
private static void #namespace#pack#Form#Buffer#wordbits# (byte[] buf, int bitOffset, const #type#[] array, const int[] chan, const int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int    uSize        = fSize - dSize - eSize - cSize;
  int    offset       = 0;
  int    _bits_fSize  = #wordbits# - fSize;    // pre-compute "#wordbits# - fSize" for efficiency
  int    bitmask      = #wordbits# - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
#IF ((#formcheck# != -4) && (#formcheck# != -100))
  #word# valMask      = (sign)? ((#word#)-1) : ((#word#)#typemask#); // Bit mask for input value (controls sign-extend)
#ENDIF

  if ((evt == null) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    
    if (chan == null) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
    }
  }
  
  for (int i = 0; i < length; i++) {
    // ==== Step 0 =============================================================
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int needBits = #wordbits# - (bitOffset & bitmask); // bits remaining to set
        #loop18#
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep

          int old = (int)buf[bitOffset>>3];

          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0

          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }

    // ==== Step 1 =============================================================
    if (true) {
#IF (#formcheck# == -4)
      float  arrayValue = (float)array[offset];
      long   value      = ((long)floatToRawIntBits(arrayValue)) << 32;
#ELSEIF (#formcheck# == -100)
      double arrayValue = (double)array[offset];
      #word# value      = (#word#)toVRTFloat(DataItemFormat_#Form#, dSize, arrayValue) << (#wordbits# - dSize);
#ELSE
      #word# arrayValue = ((#word#)(#ct#)array[offset]) & valMask;
      #word# value      = (#word#)((arrayValue) << (#wordbits# - dSize));
#ENDIF
      int    needBits   = dSize; // bits remaining to set
      while (needBits > 0) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep

        #word# old = (#word#)buf[bitOffset>>3];
        #word# val = value >> (#wordbits# - avail);

        buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));

        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }

    // ==== Step 2 =============================================================
    if (uSize > 0) {
      int needBits = uSize; // bits remaining to set
      #loop18#
      while (needBits > 0) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep

        int old = (int)buf[bitOffset>>3];

        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0

        needBits  -= numBits;
        bitOffset += numBits;
      }
    }

    // ==== Step 3 =============================================================
    if (eSize > 0) {
      int value    = evt[offset] << (32 - eSize);
      int needBits = eSize; // bits remaining to set
      #loop12#
      while (needBits > 0) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep

        int old = (int)buf[bitOffset>>3];
        int val = value >> (32 - avail);

        buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));

        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }

    // ==== Step 4 =============================================================
    if (cSize > 0) {
      int value    = chan[offset] << (32 - cSize);
      int needBits = cSize; // bits remaining to set
      #loop13#
      while (needBits > 0) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep

        int old = (int)buf[bitOffset>>3];
        int val = value >> (32 - avail);

        buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));

        needBits  -= numBits;
        bitOffset += numBits;
        value      = value << numBits;
      }
    }

    // ==== Done ===============================================================
    offset++;
  }
  
  // ==== End of Packet Pad Bits =============================================
  if (true) { //TODO: make this optional
    // Clear out any bits remaining in the current word that would be at the end
    // of the packet, this applies to both link and processing efficient.
    int needBits = #wordbits# - (bitOffset & bitmask); // bits remaining to set
    #loop08#
    while ((needBits > 0) && (needBits < #wordbits#)) {
      int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
      int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
      byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
      byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
      byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep

      int old = (int)buf[bitOffset>>3];

      buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0

      needBits  -= numBits;
      bitOffset += numBits;
    }
  }
}
## END

## START WORD
/** <b>Internal Use Only:</b> Gets the data into an array, where the data is
 *  aligned to #wordbits#-bit word boundaries.
 *  @param buf    (IN)  Packet payload buffer
 *  @param off    (IN)  Bit offset into buf (must be multiple of #wordbits# bits)
 *  @param array  (OUT) Output value array (not null)
 *  @param chan   (OUT) Output channel tag array (null if n/a)
 *  @param evt    (OUT) Output event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
private static void #namespace#unpack#Form#Word#wordbits# (const byte[] buf, int off, #type#[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int    pSize    = #wordbits# - fSize;
  int    evtMask  = ~(((int)-1) << eSize);
  int    chanMask = ~(((int)-1) << cSize);

#IF (#formcheck# == -4)
  // When using Float32 the first 32-bits will always the the Float32 value, so
  // use 32-bit operations to improve performance
  #inline_recursive#
  for (int i = 0; i < length; i++,off+=#wordbytes#) {
    array[i] = (#type#)unpackFloat(buf, off);
    int value = unpackInt(buf, off+4);
    if (chan != null) chan[i] = (value >> (pSize      )) & chanMask;
    if (evt  != null) evt[i]  = (value >> (pSize+cSize)) & evtMask;
  }
#ELSEIF (#wordbits# == 64)
  #word# valMask  = (sign)? ((#word#)-1) : (~(((#word#)-1) << dSize));
  if (dSize == 32) {
    // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
    // value, so use 32-bit operations to improve performance
    #inline_recursive#
    for (int i = 0; i < length; i++,off+=#wordbytes#) {
      int val   = unpackInt(buf, off);
      int value = unpackInt(buf, off+4);
      array[i] = (#type#)(val & valMask);
      if (chan != null) chan[i] = ((int)(value >> (pSize      ))) & chanMask;
      if (evt  != null) evt[i]  = ((int)(value >> (pSize+cSize))) & evtMask;
    }
  }
  else {
    #inline_recursive#
    for (int i = 0; i < length; i++,off+=#wordbytes#) {
      long value = unpackLong(buf, off);
      array[i] = (#type#)((value >> (64-dSize)) & valMask);
      if (chan != null) chan[i] = ((int)(value >> (pSize      ))) & chanMask;
      if (evt  != null) evt[i]  = ((int)(value >> (pSize+cSize))) & evtMask;
    }
  }
#ELSE
  #word# valMask  = (sign)? ((#word#)-1) : (~(((#word#)-1) << dSize));
  #inline_recursive#
  for (int i = 0; i < length; i++,off+=#wordbytes#) {
    int value = unpackInt(buf, off);
    array[i] = (#type#)((value >> (32-dSize)) & valMask);
    if (chan != null) chan[i] = (value >> (pSize      )) & chanMask;
    if (evt  != null) evt[i]  = (value >> (pSize+cSize)) & evtMask;
  }
#ENDIF
}
/** <b>Internal Use Only:</b> Sets the data from an array, where the data is
 *  aligned to #wordbits#-bit word boundaries.
 *  @param buf    (I/O) Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input value array
 *  @param chan   (IN)  Input channel tag array (null if n/a)
 *  @param evt    (IN)  Input event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
private static void #namespace#pack#Form#Word#wordbits# (byte[] buf, int off, const #type#[] array, const int[] chan, const int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int    pSize    = #wordbits# - fSize;
  int    evtMask  = ~(((int)-1) << eSize);
  int    chanMask = ~(((int)-1) << cSize);
  
#IF (#formcheck# == -4)
  // When using Float32 the first 32-bits will always the the Float32 value, so
  // use 32-bit operations to improve performance
  #inline_recursive#
  for (int i = 0; i < length; i++,off+=#wordbytes#) {
    float val   = (float)array[i];
    int   value = 0;
    if (chan != null) value  = (chan[i] & chanMask) << (pSize);
    if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
    packFloat(buf, off,   val);
    packInt(  buf, off+4, value);
  }
#ELSEIF (#wordbits# == 64)
  #word# valMask  = (sign)? ((#word#)-1) : ((#word#)#typemask#);
  if (dSize == 32) {
    // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
    // value, so use 32-bit operations to improve performance
    #inline_recursive#
    for (int i = 0; i < length; i++,off+=#wordbytes#) {
      int val   = (int)(((#word#)(#ct#)array[i]) & valMask);
      int value = 0;
      if (chan != null) value  = (chan[i] & chanMask) << (pSize);
      if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
      packInt(buf, off,   val);
      packInt(buf, off+4, value);
    }
  }
  else {
    #inline_recursive#
    for (int i = 0; i < length; i++,off+=#wordbytes#) {
      long val   = (long)(((#word#)(#ct#)array[i]) & valMask);
      long value = val << (64-dSize);
      if (chan != null) value |= ((long)(chan[i] & chanMask)) << (pSize);
      if (evt  != null) value |= ((long)(evt[i]  & evtMask )) << (pSize+cSize);
      packLong(buf, off, value);
    }
  }
#ELSE
  #word# valMask  = (sign)? ((#word#)-1) : ((#word#)#typemask#);
  #inline_recursive#
  for (int i = 0; i < length; i++,off+=#wordbytes#) {
    int val   = (int)(((#word#)(#ct#)array[i]) & valMask);
    int value = val << (32-dSize);
    if (chan != null) value |= (chan[i] & chanMask) << (pSize);
    if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
    packInt(buf, off, value);
  }
#ENDIF
}
## END

## START GENERIC
/** <b>Internal Use Only:</b> Unpacks values with the given format specifier as
 *  an array of <tt>#type#</tt>. <br>
 *  <br>
 *  Setting the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>)
 *  arrays to null will cause any channel or event tags present to be ignored.
 *  In most cases this results in a performance improvement. <br>
 *  <br>
 *  If the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>) arrays
 *  are non-null when there are no channel or event tags present, the values in
 *  the arrays will not be modified.
 *  @param pf     (IN)  The data format
 *  @param buf    (IN)  The buffer
 *  @param off    (IN)  The buffer offset
 *  @param array  (OUT) The output array for the values
 *  @param chan   (OUT) The output array for the channel tags (null if n/a)
 *  @param evt    (OUT) The output array for the event tags (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @return The output array (same as <tt>array</tt>).
 */
@SuppressWarnings("fallthrough")
public static #type#[] #namespace#unpackAs#Type# (PayloadFormat pf, const byte[] buf, int off, #type#[] array, int[] chan, int[] evt, int length) {
  if (!pf.isValid()) {
    throw IllegalArgumentError(pf.getValid());
  }
  int            fSize  = pf.getItemPackingFieldSize();
  int            dSize  = pf.getDataItemSize();
  int            eSize  = pf.getEventTagSize();
  int            cSize  = pf.getChannelTagSize();
  boolean        proc   = pf.isProcessingEfficient();
  boolean        sign   = pf.isSigned();
  DataItemFormat format = pf.getDataItemFormat();
  boolean        noTags;

  if (eSize == 0) evt  = null; // no event tags, ignore any array passed in
  if (cSize == 0) chan = null; // no channel tags, ignore any array passed in

  noTags = (chan == null) && (evt == null);

  if (proc && noTags && (fSize >= 17)) {
    // Use faster "effective field size" when ignoring Event & Channel Tags
    fSize = (fSize <= 32)? 32 : 64;
  }

  switch (format) {
    case DataItemFormat_SignedInt:   // FALLTHROUGH
    case DataItemFormat_UnsignedInt:
      // ---- Try fast methods -------------------------------------------------
      if (noTags) {
        switch (fSize) {
          case  8: unpackBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 16: unpackShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 24: unpackInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 32: unpackInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 64: unpackLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
        }
      }
      if (fSize == dSize) { // implicit noTags=true in this case
        switch (fSize) {
          case  1: if ((length % 8) == 0) { unpackBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          case  4: if ((length % 2) == 0) { unpackNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          case 12: if ((length % 2) == 0) { unpackInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
        }
      }
      if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
        if (fSize <= 32) {
          unpackIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      }
      // ---- Fall back to slow method -----------------------------------------
      if (fSize <= 32) {
        unpackIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_Float:
      // ---- Try fast methods -------------------------------------------------
      if (fSize == dSize) { // implicit noTags=true in this case
        unpackFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
      }
      if ((proc && (fSize >= 33)) || (fSize == 64)) {
        unpackFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      // ---- Fall back to slow method -----------------------------------------
      unpackFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
    case DataItemFormat_Double:
      // ---- Only fast method for double (yea!) -------------------------------
      unpackDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
    case DataItemFormat_SignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_SignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_UnsignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        unpackUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        unpackUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    default:
      throw UnsupportedError("Unpacking of VRT float types not supported yet");
  }
}
/** <b>Internal Use Only:</b> Packs values with the given format specifier from
 *  an array of #type#. <br>
 *  <br>
 *  Setting the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>)
 *  arrays to null will cause any channel or event tags present to be set to
 *  zero. In most cases this results in a performance improvement over passing
 *  in an array of zeros. <br>
 *  <br>
 *  If the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>) arrays
 *  are non-null when there are no channel or event tags present, the values in
 *  the arrays will be ignored.
 *  @param pf     (IN)  The data format
 *  @param buf    (I/O) The buffer
 *  @param off    (IN)  The buffer offset
 *  @param array  (IN)  The values to pack
 *  @param chan   (OUT) The output array for the channel tags (null if n/a)
 *  @param evt    (OUT) The output array for the event tags (null if n/a)
 *  @param length (IN)  Number of elements to convert
 */
@SuppressWarnings("fallthrough")
public static void #namespace#packAs#Type# (PayloadFormat pf, byte[] buf, int off, const #type#[] array, const int[] chan, const int[] evt, int length) {
  if (!pf.isValid()) {
    throw IllegalArgumentError(pf.getValid());
  }
  int            fSize  = pf.getItemPackingFieldSize();
  int            dSize  = pf.getDataItemSize();
  int            eSize  = pf.getEventTagSize();
  int            cSize  = pf.getChannelTagSize();
  boolean        proc   = pf.isProcessingEfficient();
  boolean        sign   = pf.isSigned();
  DataItemFormat format = pf.getDataItemFormat();
  boolean        noTags;

  if (eSize == 0) evt  = null; // no event tags, ignore any array passed in
  if (cSize == 0) chan = null; // no channel tags, ignore any array passed in

  noTags = (chan == null) && (evt == null);

  if (proc && noTags && (fSize >= 17)) {
    // Use faster "effective field size" when ignoring Event & Channel Tags
    fSize = (fSize <= 32)? 32 : 64;
  }

  switch (format) {
    case DataItemFormat_SignedInt:   // FALLTHROUGH
    case DataItemFormat_UnsignedInt:
      // ---- Try fast methods -------------------------------------------------
      if (noTags) {
        switch (fSize) {
          case  8: packBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 16: packShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 24: packInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 32: packInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 64: packLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
        }
      }
      if (fSize == dSize) { // implicit noTags=true in this case
        switch (fSize) {
          case  1: if ((length % 8) == 0) { packBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          case  4: if ((length % 2) == 0) { packNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          case 12: if ((length % 2) == 0) { packInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
        }
      }
      if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
        if (fSize <= 32) {
          packIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      }
      // ---- Fall back to slow method -----------------------------------------
      if (fSize <= 32) {
        packIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_Float:
      // ---- Try fast methods -------------------------------------------------
      if (fSize == dSize) { // implicit noTags=true in this case
        packFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
      }
      if ((proc && (fSize >= 33)) || (fSize == 64)) {
        packFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      // ---- Fall back to slow method -----------------------------------------
      packFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
    case DataItemFormat_Double:
      // ---- Only fast method for double (yea!) -------------------------------
      packDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
    case DataItemFormat_SignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_SignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT1:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT2:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT3:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT4:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT5:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_UnsignedVRT6:
      // ---- Only have slow method for now ------------------------------------
      if (fSize <= 32) {
        packUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        packUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    default:
      throw UnsupportedError("Packing of VRT float types not supported yet");
  }
}
## END

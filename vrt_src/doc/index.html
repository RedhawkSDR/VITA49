<!--
This file is protected by Copyright. Please refer to the COPYRIGHT file
distributed with this source distribution.

This file is part of REDHAWK.

REDHAWK is free software: you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at your
option) any later version.

REDHAWK is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see http://www.gnu.org/licenses/.
-->

<html>
  <head>
    <title>VRT Library for Java and C++</title>
    <link rel="StyleSheet" href="style.css" title="StyleSheet">
  </head>
  <body bgcolor="#FFFFFF">
    <h1>VRT Library for Java and C++</h1>
  
    <h2>WARNING!!!</h2>
    <p>
      <b class="red">This is a highly-experimental alpha version. There are bugs in it and
      the API is likely to change before the next version. Use at your own risk!</b>
    </p>
  
    <h2>Table of Contents</h2>
    <p>
       This page:
    </p>
    <ul>
      <li><a href="#Introduction">Introduction</a></li>
      <li><a href="#What_is_Included">What is Included</a></li>
      <li><a href="#Installation">Installation</a></li>
      <li><a href="#Using_the_Library">Using the Library</a></li>
      <li><a href="#Programming">Programming</a></li>
    </ul>
    <p>
       Supplemental <i>(only available after installation)</i>:
    </p>
    <ul>
      <li><a href="../pkt_doc/index.html">User-Defined VITA-49 Packet Definitions (ANSI/VITA format)</a>
          <i>(includes any definitions that have been compiled in with this build)</i></li>
      <li><a href="../cpp_doc/html/index.html">C++ Source Code Documentation (Doxygen format)</a></li>
      <li><a href="../java_doc/index.html">Java Source Code Documentation (Javadoc format)</a></li>
    </ul>

    <hr>
    <h2><a name="Introduction">Introduction</a></h2>
    <p>
      The VRT libraries for Java and C++ are (currently) distributed together. They
      represent a (nearly-complete) software-based implementation of the following
      ANSI specifications:
    </p>
    <ul>
      <li>VITA Radio Transport (VRT) / VITA 49.0</li>
      <li>VITA Radio Link Layer (VRL) / VITA 49.1</li>
    </ul>
    <p>
      The libraries are intended to be a generic implementation that can support
      everything a sender or receiver may require. Since the VRT specification is
      very rich in what it supports, the libraries are not small. The good news is
      that the libraries take care of most of the "tricky bits" and the average
      user will only ever need to be familiar with about 10% of the API (the
      <a href="#Programming">Programming</a> section provides good examples of
      this).
    </p>
    <p>
      The Java and C++ libraries are both full-up implementations (i.e. they
      do not depend on each other) and share 95% of the API. The reason for having
      two full implementations is that Java and C++ are the two primary languages
      used by the initial set of users <i>(Python is also common, and future versions
      will likely include Python wrappers for the C++ library)</i>. Although both
      are full-up implementations, the Java version is the gold-standard. Almost
      everything is written and tested in Java before porting it to C++ (debugging
      tends to be easier in Java). Owing to enhanced language-level support, the
      Java version also has better support for error-checking and treading.
    </p>
    <p>
      The libraries VRT come with corresponding option trees (VITA) that
      makes them easy to use in NeXtMidas (Java). It is important
      to note that although the VRT libraries are logically structured in a "NeXtMidas
      friendly" manner, they have absolutely no dependency on NeXtMidas (either for
      building or running).
    </p>

    <hr>
    <h2><a name="What_is_Included">What is Included</a></h2>
    <p>
       After building everything, the directory structure of this package will
      look like the following:
    </p>
    <pre>
      vrt
       +- bin/             <i>Executable scripts that support developing with VRT,</i>
       |                     <i>but are not needed at compile-time or run-time</i>
       +- c_src/           <i>C header file for "VRT Lite" that provides extremely-</i>
       |                     <i>limited access to VRT packets and VRL frames from C</i>
       +- cpp_doc/         <i>C++ source code documentation</i>
       +- cpp_lib/         <i>C++ shared objects and run-time dependencies</i>
       +- cpp_src/
       |    +- vrt/        <i>C++ VRT source code</i>
       |    |    + lib/        <i>-- Libraries for working with standard VITA 49 packets</i>
       |    |    + libm/       <i>-- Libraries for working with user-defined VITA 49 packets (autogenerated)</i>
       |    |    + net/        <i>-- Libraries to support sending/receiving VITA 49 packets</i>
       +- doc/             <i>User documentation (e.g. this file)</i>
       +- java_doc/        <i>Java source code documentation</i>
       +- java_lib/        <i>Java JAR files and run-time dependencies</i>
       +- java_src/
       |    +- nxm/
       |        +- vrt/    <i>Java VRT source code</i>
       |        |    + cfg/    <i>-- Configuration information (for compatibility with NeXtMidas)</i>
       |        |    + dat/    <i>-- Data files (includes tai-utc.dat file)</i>
       |        |    + jars/   <i>-- Required JAR files</i>
       |        |    + lib/    <i>-- Libraries for working with standard VITA 49 packets</i>
       |        |    + libg/   <i>-- Libraries for generating packet classes (internal use only)</i>
       |        |    + libm/   <i>-- Libraries for working with user-defined VITA 49 packets (autogenerated)</i>
       |        |    + net/    <i>-- Libraries to support sending/receiving VITA 49 packets</i>
       |        +- vita/       <i>-+</i>
       |             + cfg/    <i> |</i>
       |             + exp/    <i> | Optional NeXtMidas option tree</i>
       |             + inc/    <i> | (requires NeXtMidas and VRT)</i>
       |             + intr/   <i> |</i>
       |             + prim/   <i> |</i>
       |             + test/   <i>-+</i>
       +- pkt_doc/             <i>User-defined VITA 49 packet documentation</i>
       +- pkt_src/             <i>User-defined VITA 49 packet definitions (XML)</i>
       +- README
       +- Makefile             <i>Build file for use with make</i>
       +- doxygen.cfg
    </pre>
    <p>
      Both the C++ and Java versions have two important sub-packages. The VRT package
      is the primary one used for reading/writing VRT packets. It is designed to be 100%
      self-contained and only uses standard C++/Java language features. 
    </p>
    <p>
      The VITA package is dependent on the VRT package. The VITA package is a NeXtMidas
      option tree and provides easy access to VRT data. <i>(Future versions
      will have <tt>SOURCEVRT</tt> and <tt>SINKVRT</tt> commands to directly interface
      between a VRT multicast stream and a pipe.)</i>
    </p>
    <p>
      A C header file (<a href="../c_src/vrt_lite.h"><tt>vrt_lite.h</tt></a>) is
      provided that gives extremely-limited access to VRT packets and VLR frames from
      strict ANSI C 89. It is not user-friendly and assumes the user is well-versed in
      both C and the VITA 49 specifications. It is intended for use in situations where
      C++ (or Java) is not an option. The rest of this document is not relevent to use
      of the C header file, please see <a href="../c_src/vrt_lite.h"><tt>vrt_lite.h</tt></a>
      for more information.
    </p>
    
    
    
    
    
    <hr>
    <h2><a name="Installation">Installation</a></h2>
    <p>
       This section provided details on how to build and install the VRT libraries.
    </p>
    
    <h3>Requirements</h3>
    <p>
      The <b>Java JAR</b> version is platform-independent and does not need to be built. For all
      other versions, the tested configurations include:
    </p>
    <table border="1">
      <tr>
        <th>O/S</th>
        <th>Red Hat Enterprise Linux 4<br>32-bit</th>
        <th>Red Hat Enterprise Linux 5<br>32-bit</th>
        <th><font color="blue">Red Hat Enterprise Linux 5<br>64-bit</font></th>
      </tr>
      <tr>
        <th>Java Compiler<sup>[1]</sup></th>
        <td align="center">Java Development Kit (JDK) 6<br>(32-bit version)</td>
        <td align="center">Java Development Kit (JDK) 6<br>(32-bit version)</td>
        <td align="center"><font color="blue">Java Development Kit (JDK) 6<br>(64-bit version)</font><sup>[2]</sup></td>
      </tr>
      <tr>
        <th>C++ Compiler</th>
        <td align="center">GNU C++ compiler (g++) 3.4.6</td>
        <td align="center">GNU C++ compiler (g++) 4.1.2</td>
        <td align="center"><font color="blue">GNU C++ compiler (g++) 4.1.2</font><br>
                           Intel C Compiler (ICC) 10.1<sup>[3]</sup><br>
                           <font color="blue">Intel C Compiler (ICC) 11.1</font><sup>[3]</sup></td>
      </tr>
      <tr>
        <th>Doxygen</th>
        <td align="center">Doxygen 1.3.9.1</td>
        <td align="center">Doxygen 1.4.7</td>
        <td align="center"><font color="blue">Doxygen 1.4.7</font></td>
      </tr>
      <tr>
        <th>make</th>
        <td align="center">GNU Make 3.80</td>
        <td align="center">GNU Make 3.81</td>
        <td align="center"><font color="blue">GNU Make 3.81</font></td>
      </tr>
      <tr>
        <th>NeXtMidas<br><i>(Optional)</i></th>
        <td align="center">NeXtMidas 2.8</td>
        <td align="center">NeXtMidas 2.8</td>
        <td align="center">NeXtMidas 2.8<br>
                           <font color="blue">NeXtMidas 2.9</font><br>
                           NeXtMidas 3.0</td>
      </tr>
      <tr>
        <td colspan="4"><i>Entries in <font color="blue"><b>blue</b></font> are part of the primary
        test and development suite, those in <b>black</b> have been tested by the user community
        and are believed to work.</i> <br>
        <br>
        Notes:<br>
        &nbsp; [1] Optional with a "C++ Only" version.<br>
        &nbsp; [2] The <u>64-bit</u> version of the JDK should be used on <u>64-bit</u> platforms.<br>
        &nbsp; [3] Requires a "setenv VRT_CC icc" before building.<br>

        </td>
      </tr>
    </table>

    <p>
      Note that each of the compilers/tools must be on the path prior to use. You can check this
      by using:
    </p>
    <pre>
      java -version
      g++ --version
      icc --version       <i>(optional)</i>
      doxygen --version
      make --version
    </pre>
    <p>
      Similar and/or newer versions of the above should work, they are just untested at this
      time. GCJ and Java 1.4.2 (default on some older Linux systems) will not work. Take care
      when installing the Java versions; the 32-bit version should be used on 32-bit platforms
      and the 64-bit version on 64-bit platforms (when "<tt>java -version</tt>" is run, it will
      list "64-Bit" if it is a 64-bit version).
    </p>
    <p>
      The libraries were developed using <tt>csh</tt>/<tt>tcsh</tt>
      and all of the examples here assume use of <tt>csh</tt>/<tt>tcsh</tt>, but <tt>sh</tt> and
      <tt>bash</tt> should work equally well.
    </p>
    
    
    <h3>Building</h3>
    <p>
      After unpacking the archive, <tt>cd</tt> into the root <tt>vrt</tt> directory, then
      run <tt>make</tt> with no arguments to see details on build targets. In most cases
      "<tt>make all</tt>" will suffice, but a "<tt>make cleanall</tt>" may be required first
      if doing a full re-build.
    </p>
    <p>
      Both the C++ and Java versions make use of auto-generated code. Since the
      auto-generated code is produced via a custom Java app, the builds are distributed in
      three forms:
    </p>
    <ul>
      <li><b>Full Source</b> - Complete source code, Java and/or C++ libraries built from scratch
                                   but requires Java to create the auto-generated code.</li>
      <li><b>Java JAR</b>    - Pre-build Java JAR (plus dependancies) that platform-independent
                                   and does not need to be build.</li>
      <li><b>C++ Only</b>    - Complete source code, C++ libraries can be built without a Java
                                   requirement (though some of the utilities may need Java). This
                                   version comes with the the auto-generated C++ code pre-built.</li>
    </ul>
    <p>
      If you have a <b>C++ Only</b> version it is possible to convert it to a <b>Full Source</b>
      version simply by running "<tt>make cleanall</tt>". This will remove any of the pre-build parts
      and reset everything to support a full build when "<tt>make all</tt>" is next called.
    </p>

    

    <hr>
    <h2><a name="Using_the_Library">Using the Library</a></h2>
    <p>
      This section explains how to build and run with the library. Writing code
      that uses the library is discussed in the <a href="#Programming">Programming</a>
      section.
    </p>
    
    <h3>Stand-Alone C++</h3>
    <p>
      Set the following environment variables (where &lt;VRTHOME&gt; is the VRT
      installation directory):
    </p>
    <pre>
       setenv VRTHOME         &lt;VRTHOME&gt;
       setenv PATH            "${VRTHOME}/bin/:${PATH}"
       setenv LD_LIBRARY_PATH "${VRTHOME}/cpp_lib/:${LD_LIBRARY_PATH}"
    </pre>
    <p>
      As of version 1.1, the setting of VRTHOME is strictly optional, though it may
      result in an warning message as this causes it to use the internal leap-seconds
      table rather than the official <tt>tai-utc.dat</tt> file.
    </p>
    <p>
      Setting <tt>LD_LIBRARY_PATH</tt> allows the library to be used at run-time;
      if you want to build against it, add the following flags on the compiler line:
    </p>
    <pre>
      -L ${VRTHOME}/cpp_lib -lvrt -I ${VRTHOME}/cpp_src/vrt/lib/
                                  -I ${VRTHOME}/cpp_src/vrt/libm/
                                  -I ${VRTHOME}/cpp_src/vrt/net/
    </pre>
    <p>
      Check out <a href="../cpp_doc/html/namespacevrt_1_1VRTConfig.html"><tt>VRTConfig</tt></a>
      for a list of environment variables that can be used to alter the behavior of the
      library.
    </p>
    
    <h3>Stand-Alone Java</h3>
    <p>
      Simply add all of the JAR files in <tt>java_lib/</tt> to your Java
      classpath and you are good to go. Check out
      <a href="../java_doc/nxm/vrt/lib/VRTConfig.html"><tt>VRTConfig</tt></a> for
      a list of command-line options that can be used to alter the behavior of the
      library. <i>(The <tt>tai-utc.dat</tt> file is included in the <tt>vrt.jar</tt>
      file.)</i>
    </p>
    
    <h3>Java Version Within NeXtMidas</h3>
    <p>
      <i>Requires NeXtMidas 2.8.0 or later</i>
    </p>
    <p>
      The VITA option tree provides the <tt>SOURCEVRT</tt> and <tt>SINKVRT</tt>
      commands that support converting between a VRT stream and apipe. These
      commands can be built using the standard build commands. Example usages
      can be seen via the test macros in <tt>vita/test/</tt> directory and the
      applicable explain files.
    </p>
    <p>
       The option tree can added to the path using:
    </p>
    <pre>
      nM> option VRT  &lt;VRTHOME&gt;/java_src/
      nM> option VITA &lt;VRTHOME&gt;/java_src/
      nM> path add VITA
    </pre>
    <p>
      The VITA option tree will automatically add VRT to the path and will configure some
      additional settings. This allows NeXtMidas to directly interact with the VRT libraries
      at run-time from the command line and/or a macro (such as via NEW and INVOKE). This also
      eliminates any need to put the VRT jar files on the path.
    </p>
    <p>
      After adding the option tree to the path it can be built using (the
      VRT library should be built via the above instructions):
    </p>
    <pre>
      nM> make all VITA
    </pre>
    <p>
      Custom primitives that make use of the VRT libraries should build without any additional
      configuration settings provided that the VRT and VITA option trees are on the path.
    </p>
    
    
    
    <hr>
    <h2><a name="Programming">Programming</a></h2>

    <h3>Overview</h3>

    <p>
      There are seven main classes you need to be familiar with in either Java or C++:
    </p>
    <pre>
                    +----------------+
                    | BasicVRLFrame  |
                    +----------------+
                            :
                            :
                    +----------------+             +-----------------------+     +-----------+
                    | BasicVRTPacket |             | AbstractPacketFactory |     | TimeStamp |
                    +----------------+             +-----------------------+     +-----------+
                            ^
                            |
                +-----------+-----------+
                |                       |
       +-----------------+     +--------------------+
       | BasicDataPacket |     | BasicContextPacket |
       +-----------------+     +--------------------+
                ^
                |
      +--------------------+
      | StandardDataPacket |
      +--------------------+
    </pre>
    <p>
      In the Java version, each of the classes that starts with <tt>Basic</tt> is
      tied to an interface; this allows for future extension where the implementing
      class may map to a hardware device or even a "virtual" packet. All of the C++
      classes listed here extend a generic
      <a href="../cpp_doc/html/classvrt_1_1VRTObject.html"><tt>VRTObject</tt></a> class
      which provides basic functionality for <tt>toString()</tt> and <tt>equals(..)</tt>
      and allows any of them to be added to a C++ <tt>string</tt> or written to <tt>cout</tt>
      with only a <tt>&lt;&lt;</tt> operator.
    </p>
    <dl>
      <dt><tt><b>BasicVRLFrame</b></tt>
          (<a href="../java_doc/nxm/vrt/lib/BasicVRLFrame.html">Java</a>,
          <a href="../cpp_doc/html/classvrt_1_1BasicVRLFrame.html">C++</a>)
          <tt><b>implements VRLFrame</b></tt>
          (<a href="../java_doc/nxm/vrt/lib/VRLFrame.html">Java</a>)</dt>
      <dd>- Transmission frame that can contain [0,N] VRT packets in it as specified
          by VITA 49.1.</dd>

      <dt><tt><b>BasicVRTPacket</b></tt>
          (<a href="../java_doc/nxm/vrt/lib/BasicVRTPacket.html">Java</a>,
          <a href="../cpp_doc/html/classvrt_1_1BasicVRTPacket.html">C++</a>)
          <tt><b>implements VRTPacket</b></tt>
          (<a href="../java_doc/nxm/vrt/lib/VRTPacket.html">Java</a>)</dt>
      <dd>- This is the parent of all other VRT packets. Its purpose is to
          read the VRT packet header and make sense of the header. It knows
          nothing about the payload other than its size.</dd>
      <dd>- The most valuable functionality this class provides is the ability
          to take <u>any</u> unknown VRT packet and pull out the header information
          necessary to differentiate it further.</dd>
      <dd>- Any user-defined <b>Extension Context</b> packets will use this
          as a base class.</dd>

      <dt><tt><b>BasicDataPacket</b></tt>
          (<a href="../java_doc/nxm/vrt/lib/BasicDataPacket.html">Java</a>,
          <a href="../cpp_doc/html/classvrt_1_1BasicDataPacket.html">C++</a>)
          <tt><b>implements DataPacket</b></tt>
          (<a href="../java_doc/nxm/vrt/lib/DataPacket.html">Java</a>)</dt>
      <dd>- This is a simple extension of <tt>BasicVRTPacket</tt> that
          can work with <b>IF Data</b> and <b>Extension Data</b> packets.</dd>

      <dt><tt><b>StandardDataPacket</b></tt>
          (<a href="../java_doc/nxm/vrt/lib/StandardDataPacket.html">Java</a>,
          <a href="../cpp_doc/html/classvrt_1_1StandardDataPacket.html">C++</a>)</dt>
      <dd>- This is a simple extension of <tt>BasicDataPacket</tt> that
          provides a standardized way of transmitting most PreD and PostD
          data without extra "paperwork" to describe the data being sent.</dd>

      <dt><tt><b>BasicContextPacket</b></tt>
          (<a href="../java_doc/nxm/vrt/lib/BasicContextPacket.html">Java</a>,
          <a href="../cpp_doc/html/classvrt_1_1BasicContextPacket.html">C++</a>)
          <tt><b>implements ContextPacket</b></tt>
          (<a href="../java_doc/nxm/vrt/lib/DataPacket.html">Java</a>)</dt>
      <dd>- This is a fairly complex class that handles all of the features
          of a <b>IF Context</b> packet.</dd>

      <dt><tt><b>AbstractPacketFactory</b></tt>
          (<a href="../java_doc/nxm/vrt/lib/AbstractPacketFactory.html">Java</a>,
          <a href="../cpp_doc/html/classvrt_1_1AbstractPacketFactory.html">C++</a>)</dt>
      <dd>- Subclasses of this class support the ability to auto-identify input packets.</dd>

      <dt><tt><b>TimeStamp</b></tt>
          (<a href="../java_doc/nxm/vrt/lib/TimeStamp.html">Java</a>,
          <a href="../cpp_doc/html/classvrt_1_1TimeStamp.html">C++</a>)</dt>
      <dd>- This is a container for a VRT-compatible time stamp, the most common use
          is storing UTC or GPS time with picosecond precision.</dd>
      <dd>- Although seemingly-trivial, this class supports full conversion between
          the GPS, UTC and NORAD time epochs and can convert UTC and GPS time
          to and from a string.</dd>
      <dd>- In Java all <tt>TimeStamp</tt>s are immutable. In C++ they are immutable,
          except on assignment.</dd>
    </dl>


    <h3>Creating VRT Packets</h3>
    <p>
      Creating a VRT packet can be as simple as instantiating the class and
      setting some necessary values. The following example will create both a
      data packet and a context packet. It should be obvious from the following
      example that the Java and C++ versions have a nearly identical API. This
      commonality makes it easy for developers to quickly go between the Java
      and C++ versions.
    </p>
    <pre>
      <i class="blue">Java</i>
      <i class="blue">==============================================================================================</i>
      int       streamID   = 0;                        // The stream ID for the stream (usually 0
                                                       // for the primary stream)
      byte[]    dataBuffer = ...;                      // Byte buffer with the data to send
      int       numBytes   = ...;                      // The length of the data in bytes

      // Create a time stamp and payload format to use with both packets
      TimeStamp     ts = TimeStamp.parseTime("2010-04-01T12:34:56.789", IntegerMode.UTC);
      PayloadFormat pf = PayloadFormat.FLOAT32;        // Pre-defined type for 32-bit IEEE float

      // Create a context packet to describe the data
      ContextPacket cp = new BasicContextPacket();
      cp.setStreamIdentifier(streamID);                // The stream ID
      cp.setClassIdentifier("FF-FF-FF:0001.0001");     // A class ID (this is just a sample one)
      cp.setTimeStamp(ts);                             // The time stamp created above
      cp.setChangePacket(true);                        // First packet must be a change packet
      cp.setDataPayloadFormat(pf);
      cp.setSampleRate(1e6);                           // 1 MHz

      // Creates a data packet to hold the data
      DataPacket dp = new BasicDataPacket();
      dp.setStreamIdentifier(streamID);                // The stream ID
      dp.setClassIdentifier("FF-FF-FF:0001.0002");     // A class ID (this is just a sample one)
      dp.setTimeStamp(ts);                             // The time stamp created above
      dp.setPacketType(PacketType.Data);               // Use the default data type
      dp.setData(pf, dataBuffer, 0, numBytes);         // Sets the packet data

      // Print the packets to standard out
      System.out.println(cp);
      System.out.println(dp);


      <i class="blue">C++</i>
      <i class="blue">==============================================================================================</i>
      int32_t   streamID   = 0;                        // The stream ID for the stream (usually 0
                                                       // for the primary stream)
      void     *dataBuffer = ...;                      // Pointer to the data to send
      int32_t   numBytes   = ...;                      // The length of the data in bytes
      
      // Create a time stamp and payload format to use with both packets
      TimeStamp     ts = TimeStamp::parseTime("2010-04-01T12:34:56.789", IntegerMode_UTC);
      PayloadFormat pf = PayloadFormat_FLOAT32;        // Pre-defined type for 32-bit IEEE float

      // Create a context packet to describe the data
      BasicContextPacket cp;
      cp.setStreamIdentifier(streamID);                // The stream ID
      cp.setClassIdentifier("FF-FF-FF:0001.0001");     // A class ID (this is just a sample one)
      cp.setTimeStamp(ts);                             // The time stamp created above
      cp.setChangePacket(true);                        // First packet must be a change packet
      cp.setDataPayloadFormat(pf);
      cp.setSampleRate(1e6);                           // 1 MHz

      // Creates a data packet to hold the data
      BasicDataPacket dp;
      dp.setStreamIdentifier(streamID);                // The stream ID
      dp.setClassIdentifier("FF-FF-FF:0001.0002");     // A class ID (this is just a sample one)
      dp.setTimeStamp(ts);                             // The time stamp created above
      dp.setPacketType(PacketType_Data);               // Use the default data type
      dp.setData(pf, dataBuffer, 0, numBytes);         // Sets the packet data

      // Print the packets to standard out
      cout &lt;&lt; cp &lt;&lt; endl;
      cout &lt;&lt; dp &lt;&lt; endl;
    </pre>


    <h3>Sending and Receiving VRT Packets</h3>
    <p>
      The VRT library includes both a sender and receiver for passing VRT packets over
      UDP Multicast. Though the class names and basic utility are similar, the implementations
      differ significantly between the Java and C++ version. The Java version of the reader
      uses a listener model where a separate thread is responsible for socket reads, while
      the C++ version employs a model where the socket read is directly instigated by the
      user. <i>Since version 1.1, the C++ version also supports the listener model. This
      follows successful testing of both versions where the listener model was shown to
      out-perform on high-rate streams (i.e. fewer dropped packets) and was simpler to
      write code for.</i>
    </p>
    <pre>
       +-----------+     +-----------+                    +------------------+
       | VRTWriter |     | VRTReader |                    | VRTEventListener |
       +-----------+     +-----------+                    +------------------+
                                                                   ^
                                                                   |
                                                    +--------------+--------------+
                                                    |                             |
                                          +--------------------+          +-----------------+
                                          | VRTContextListener |          | VRTEventAdaptor |
                                          +--------------------+          +-----------------+
    </pre>
    <dl>
      <dt><tt><b>VRTWriter</b></tt>
          (<a href="../java_doc/nxm/vrt/net/VRTWriter.html">Java</a>,
          <a href="../cpp_doc/html/classvrt_1_1VRTWriter.html">C++</a>)</dt>
      <dd>- Sends VRT packets over UDP multicast.</dd>

      <dt><tt><b>VRTReader</b></tt>
          (<a href="../java_doc/nxm/vrt/net/VRTReader.html">Java</a>,
          <a href="../cpp_doc/html/classvrt_1_1VRTReader.html">C++</a>)</dt>
      <dd>- Reads VRT packets received over UDP multicast.</dd>

      <dt><tt><b>VRTEventListener</b></tt>
          (<a href="../java_doc/nxm/vrt/net/VRTEventListener.html">Java</a>,
          <a href="../cpp_doc/html/classvrt_1_1VRTEventListener.html">C++</a>)</dt>
      <dd>- Provides the call-back interface that is used when a packet is received
          by a VRTReader (or sent by a VRTWriter).</dd>
      <dd>- Also provides a mechanism whereby errors/warnings can be reported back.</dd>

      <dt><tt><b>VRTContextListener</b></tt>
          (<a href="../java_doc/nxm/vrt/net/VRTContextListener.html">Java</a>,
          <a href="../cpp_doc/html/classvrt_1_1VRTContextListener.html">C++</a>)</dt>
      <dd>- An extension to <tt>VRTEventListener</tt> that simplifies the process of
          connecting to a stream by permitting the <tt>VRTReader</tt> to do the work
          required to gather the complete set of initial context information and
          to differentiate between context and data packets received.</dd>
      <dd>- <i>This was added in version 1.1 in a manner that is backwards-compatible
          with the existing users of <tt>VRTEventListener</tt>, see the class
          documentation for details.</i></dd>

      <dt><tt><b>VRTEventAdaptor</b></tt>
          (<a href="../java_doc/nxm/vrt/net/VRTEventAdaptor.html">Java</a>)</dt>
      <dd>- An basic Java implementation of <tt>VRTEventListener</tt> following the model
          established for call-backs in Java's AWT libraries.</dd>
      <dd>- There is no C++ version of <tt>VRTEventAdaptor</tt> since the C++ versions of
          <tt>VRTEventListener</tt> and <tt>VRTContextListener</tt> are fully-defined
          classes that can be subclassed <i>(this works because C++ permits
          multiple-inheritance while Java does not)</i>.</dd>
    </dl>
    <p>
      Once a packet has been created, it is ready to send via the <b>VRTWriter</b>. This writer
      will handle all of the other "stuff" required to prepare a packet for sending (i.e. updating
      the packet count, etc.) -- if you choose to send the packet via another mechanism, it will
      need to do this same work.
    </p>
    <p>
      Once a packet stream exists on the network, the <b>VRTReader</b> can read it. The reader
      handles the corresponding recipient "stuff" (i.e. checking the packet count, etc.) on the
      receive end. Once a packet has been received it can be worked with.
    </p>


    <h4>Receiving VRT Packets</h4>
    <pre>
      <i class="blue">Java (using VRTContextListener)</i>
      <i class="blue">==============================================================================================</i>
      import nxm.vrt.lib.*;
      import nxm.vrt.net.*;

      /** Handles received packets. */
      public class MyListener implements VRTContextListener {
        @Override
        public void receivedContextPacket (VRTEvent e, VRTPacket p) {
          System.out.println("Context packet received: "+p);
          ...
        }
        ...
      }
      <i class="blue">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - </i>
      String host    = ...;   // Multicast host
      int    port    = ...;   // Multicast port
      String device  = ...;   // Ethernet device (e.g. "eth1" or "eth2.101"), null to use default
      double timeout = 60.0;  // Initial status timeout in sec (suggest using 60.0)

      MyListener listener     = new MyListener();
      VRTReader  packetReader = new VRTReader(host, port, device, listener, timeout);

      packetReader.start(); // starts the reader on a separate thread
      ...
      packetReader.stop();  // stops the reader when done with it


      <i class="blue">C++ (using VRTContextListener)</i>
      <i class="blue">==============================================================================================</i>
      #include "VRTReader.h"
      #include "AbstractPacketFactory.h" // Required for VRTConfig::getPacket(..)

      /** Handles received packets. */
      class MyListener : public VRTContextListener {

        public: MyListener () : VRTContextListener() { }

        public: ~MyListener () { }

        public: inline void receivedContextPacket (const VRTEvent &amp;e, const BasicVRTPacket &amp;p) {
          BasicVRTPacket *pkt = VRTConfig::getPacket(p);
          cout &lt;&lt; "Context packet received: " &lt;&lt; pkt->toString() &lt;&lt; endl;
          ...
          delete pkt;
        }
        ...
      };
      <i class="blue">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - </i>
      string  host    = ...;   // Multicast host
      int32_t port    = ...;   // Multicast port
      string  device  = ...;   // Ethernet device (e.g. "eth1" or "eth2.101"), "" to use default
      double  timeout = 60.0;  // Initial status timeout in sec (suggest using 60.0)

      MyListener listener;
      VRTReader  packetReader(host, port, device, &amp;listener, timeout);

      packetReader.start(); // starts the reader on a separate thread
      ...
      packetReader.stop();  // stops the reader when done with it


      <i class="blue">Java (traditional version)</i>
      <i class="blue">==============================================================================================</i>
      /**  Handles received packets. This can either extend VRTEventAdaptor or implement
          VRTEventListener. The VRTEventAdaptor class implements VRTEventListener and provides
          basic functionality to most methods.
       */
      public class MyClass extends VRTEventAdaptor {
        @Override
        public void reveivedPacket (VRTEvent e, VRTPacket p) {
          System.out.println("Packet received: "+p);
          ...
        }
      }
      <i class="blue">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - </i>
      VRTEventListener listener     = new MyClass();
      String           hostPort     = ...; // Multicast "host:port"
      String           device       = ...; // Ethernet device (e.g. "eth1" or "eth2.101"), null to use default
      VRTReader        packetReader = new VRTReader(hostPort, device, listener);

      packetReader.addErrorWarningListener(listener);
      packetReader.addReveivedPacketListener(listener, null); // null=NoFiltering
      packetReader.start(); // starts the reader on a separate thread
      ...
      packetReader.close(); // closes the reader when done with it


      <i class="blue">C++ (traditional version)</i>
      <i class="blue">==============================================================================================</i>
      string    host         = ...;   // Multicast host
      int32_t   port         = ...;   // Multicast port
      string    device       = ...;   // Ethernet device (e.g. "eth1" or "eth2.101"), "" to use default
      float     timeout      = ...;   // Multicast read timeout
      VRTReader packetReader(host, port, device);

      ...
      while (!done) {
        vector&lt;BasicVRTPacket&gt; packets = receivePackets(timeout); // will have size=0 on timeout

        for (size_t i = 0; i &lt; packets.size(); i++) {
          BasicVRTPacket p = packets[i];
          if (!isNull(p)) {
            cout &lt;&lt; "Packet received: " &lt;&lt; p &lt;&lt; endl;
            ...
          }
        }
      }
      packetReader.close(); // closes the reader when done with it
    </pre>
    <p>
      In the Java version, the listener methods are automatically called with the most-specific
      subclass of <tt>VRTPacket</tt> available (see
      <a href="../java_doc/nxm/vrt/lib/VRTConfig.html#getPacket(nxm.vrt.lib.VRTPacket,boolean)">VRTConfig.getPacket(..)</a>)
      whereas in C++ they must be called with a basic instance of <tt>BasicVRTPacket</tt>. Accordingly
      it is necessary to manually convert a C++ to the most-specific subclass using
      <a href="../cpp_doc/html/namespacevrt_1_1VRTConfig.html">VRTConfig::getPacket(..)</a> as shown
      below:
    </p>
    <pre>
      <i class="blue">This simply prints the most basic packet information:</i>
        public: inline void receivedContextPacket (const VRTEvent &amp;e, const BasicVRTPacket &amp;p) {
          cout &lt;&lt; "Context packet received: " &lt;&lt; p.toString() &lt;&lt; endl;
        }
    
      <i class="blue">This converts to the specific packet type and prints out the full details:</i>
        public: inline void receivedContextPacket (const VRTEvent &amp;e, const BasicVRTPacket &amp;p) {
          BasicVRTPacket *pkt = VRTConfig::getPacket(p);
          cout &lt;&lt; "Context packet received: " &lt;&lt; pkt->toString() &lt;&lt; endl;
          delete pkt;
        }
    </pre>
    <p>
      The reason for this difference between Java and C++ is that the object returned from
      <tt>VRTConfig::getPacket(..)</tt> must be manually deleted when done, whereas the Java
      version benefits from automatic garbage collection. (The <tt>BasicVRTPacket&amp;</tt>
      passed in to the C++ callback is allocated on the stack and is automatically cleaned
      up once the callback returns.)
    </p>
    
    <h4>Sending VRT Packets</h4>
    <pre>
      <i class="blue">Java</i>
      <i class="blue">==============================================================================================</i>
      VRTEventListener listener     = new VRTEventAdaptor(true); // Just use the stock adaptor with debug turned on
      String           hostPort     = ...;   // Multicast "host:port"
      String           device       = ...;   // Ethernet device (e.g. "eth1" or "eth2.101"), null to use default
      boolean          useFrames    = true;  // Should we use VRL frames when sending (usually a good idea)?
      boolean          useCRC       = false; // Should we use CRC protection for VRL frames (usually unnecessary)?
      VRTWriter        packetWriter = new VRTWriter(hostPort, device, listener, useFrames, useCRC);

      packetReader.addErrorWarningListener(listener);
      if (verbose) {
        // We know the packet we just sent, so we usually don't need to print it out again. This
        // is here to provide confirmation that the packet was sent and to show that the packet
        // counters have been updated accordingly.
        packetWriter.addSentPacketListener(listener, null); // null=NoFiltering
      }

      ...
      // Send a single packet
      VRTPacket packet = ...; // Create a packet (see above example)
      packetWriter.sendPacket(packet);

      // Send multiple packets (in a single datagram, if possible)
      VRTPacket context = ...;
      VRTPacket data    = ...;
      packetWriter.sendPackets(context, data);

      ...
      packetWriter.close(); // closes the writer when done with it


      <i class="blue">C++</i>
      <i class="blue">==============================================================================================</i>
      string    host         = ...;   // Multicast host
      int32_t   port         = ...;   // Multicast port
      string    device       = ...;   // Ethernet device (e.g. "eth1" or "eth2.101"), "" to use default
      bool      useFrames    = true;  // Should we use VRL frames when sending (usually a good idea)?
      bool      useCRC       = false; // Should we use CRC protection for VRL frames (usually unnecessary)?
      VRTWriter packetWriter(host, port, device, useFrames, useCRC);

      ...
      // Send a single packet (note that sendPacket(..) can take in a packet or a pointer to a packet)
      BasicVRTPacket packet = ...; // Create a packet (see above example)
      packetWriter.sendPacket(packet); // or packetWriter.sendPacket(&amp;packet);

      // Send multiple packets (note that sendPackets(..) only takes in pointers to packets)
      BasicVRTPacket context = ...;
      BasicVRTPacket data    = ...;
      packetWriter.sendPackets(&amp;context, &amp;data); // Must use pointers here
      
      ...
      packetWriter.close(); // closes the writer when done with it
    </pre>

    <h3>Auto-Generating Classes to Map to a VRT Packet Definition</h3>
    <p>
      The <tt>${VRTHOME}/bin/packetgen</tt> command will generate Java and C++
      classes to easily read and write user-defined VRT packet classes specified
      in a standard XML format. This approach is very similar to what is done for
      XML parsers. Once the file is created, the <tt>packetgen</tt> program (which
      requires Java to run) can be used to generate the applicable Java and/or C++
      classes. Running <tt>packetgen</tt> with no arguments will display usage
      syntax and examples.
    </p>
    <p>
      The advantage of this approach over a customized approach is that
      <tt>packetgen</tt> will generate a full Java and C++ class to handle each
      specified packet type. Any packet definitions defined in this way and
      included in <tt>$NMROOT/pkt_src/*.xml</tt> will be automatically built
      into the VRT library when "make" is called. This allows simple "extension"
      of the VRT library by merely copying additional definition files into
      <tt>$NMROOT/pkt_src/</tt> prior to building.
    </p>
    <h4>Packet Definition File Overview</h4>
    <p>
      The XML files in <tt>${VRTHOME}/pkt_src/</tt> serves as an example of
      the packet definition.
    </p>
    <p>
       The start basic layout of the packet definition file looks as follows:
    </p>
    <pre>
      &lt;?xml version="1.0" encoding="UTF-8"?&gt;
      &lt;XML&gt;
        &lt;HEAD&gt;
          &lt;TITLE&gt;<i class="blue">title</i>&lt;/TITLE&gt;
          &lt;AUTHOR&gt;<i class="blue">author</i>&lt;/AUTHOR&gt;
          &lt;DESCRIPTION&gt;
            <i class="blue">description</i>
          &lt;/DESCRIPTION&gt;
        &lt;/HEAD&gt;
        &lt;PACKET_TYPES&gt;
          &lt;PACKET_TYPE&gt; ... &lt;/PACKET_TYPE&gt;
          &lt;PACKET_TYPE&gt; ... &lt;/PACKET_TYPE&gt;
          ...
        &lt;/PACKET_TYPES&gt;
      &lt;/XML&gt;
    </pre>
    <p>
      Within the <tt>&lt;HEAD&gt;</tt> block the 
      <i class="blue">title</i>, <i class="blue">author</i>, and <i class="blue">description</i>
      provide an overall summary of the document. The bulk of the file is then made up of
      a number of <tt>&lt;PACKET_TYPE&gt;</tt> definitions.
    </p>
    <h4>Packet Type Definition</h4>
    <p>
       Each <tt>&lt;PACKET_TYPE&gt;</tt> looks like this:
    </p>
    <pre>
      &lt;PACKET_TYPE&gt;
        &lt;CLASS_ID&gt;<i class="blue">class_id</i>&lt;/CLASS_ID&gt;
        &lt;NAME&gt;<i class="blue">name</i>&lt;/NAME&gt;
        &lt;PACKET_TYPE&gt;<i class="blue">packet_type</i>&lt;/PACKET_TYPE&gt;
        &lt;SECTION_TITLE&gt;<i class="blue">section_title</i>&lt;/SECTION_TITLE&gt;
        &lt;TABLE_TITLE&gt;<i class="blue">table_title</i>&lt;/TABLE_TITLE&gt;
        &lt;DESCRIPTION&gt;
          <i class="blue">description</i>
        &lt;/DESCRIPTION&gt;
        &lt;FIELDS&gt;
          &lt;FIELD ... /&gt;
          &lt;FIELD ... /&gt;
          ...
        &lt;/FIELDS&gt;
        &lt;RECORDS&gt;
          &lt;RECORD&gt; ... &lt;/RECORD&gt;
          &lt;RECORD&gt; ... &lt;/RECORD&gt;
          ...
        &lt;/RECORDS&gt;
        &lt;ENUMERATIONS&gt;
          &lt;ENUMERATION&gt; ... &lt;/ENUMERATION&gt;
          &lt;ENUMERATION&gt; ... &lt;/ENUMERATION&gt;
          ...
        &lt;/ENUMERATIONS&gt;
      &lt;/PACKET_TYPE&gt;
    </pre>
    <p>
      The <i class="blue">class_id</i> specifies the packet's class ID in the form
      <tt>xx-xx-xx:yyyy.zzzz</tt> where <tt>xx-xx-xx</tt> is the OUI in IEEE standard,
      and <tt>yyyy</tt> and <tt>zzzz</tt> are the hex forms of the ICC (information
      class code) and PCC (packet class code). For example <tt>FF-FF-00:0001.0001</tt>.
    </p>
    <p>
      The <i class="blue">name</i> specifies the class name for the Java and C++
      code used to handle this packet class. By convention the naming scheme follows
      Java class naming conventions and ends with "Packet" (e.g. <tt>DataSourceLookupPacket</tt>).
      Note that the Java package and C++ namespace are command-line arguments to
      <tt>packetgen</tt> and are not included in this file.
    </p>
    <p>
      The <i class="blue">packet_type</i> specifies the code number for the packet
      type. Currently, this should always be <tt>5</tt> identifying an Extension Context
      Packet, however this will certainly change in a future release.
    </p>
    <p>
      The <i class="blue">section_title</i> and <i class="blue">table_title</i> are
      free-form titles of the section and table (these apply more to the LaTeX/PDF output
      option rather than the code output).
    </p>
    <p>
       The <i class="blue">description</i> provides a description of the packet. It
      is written in a modified-HTML format that will be turned into HTML and included
      at the top-of-class comments for Java and C++ output or it is turned into LaTeX
      markup for the LaTeX/PDF output options. <i>The exact syntax for this will be
      detailed at a later time.</i>
    </p>
    <h4>Field Definitions</h4>
    <p>
      The <tt>&lt;FIELDS&gt;</tt> section the layout of the packet by listings the
      fields in the order in which they appear. Each field entry looks like the following:
    </p>
    <pre>
      &lt;FIELD TYPE='<i class="blue">type</i>' NAME='<i class="blue">name</i>' UNITS='<i class="blue">units</i>' RANGE='<i class="blue">range</i>' DESCRIPTION='<i class="blue">description</i>' /&gt;
    </pre>
    <p>
      The <i class="blue">type</i> specifies the field type, it must be one of
      the following:
    </p>
    <table border="1">
      <tr><th>Type    </th><th>Bytes</th><th>Description</th></tr>
      <tr><td><tt>boolean </tt></td><td> 1</td><td>Boolean value (+1=true, -1=false, 0=false). Note that
                                                   this is not a C boolean, the fact that -1 and 0 are both
                                                   false is not accidental. <i>Although writers must use
                                                   values 0, -1 or +1, readers are encouraged to consider
                                                   any positive values to be true and any negative values
                                                   to be false.</i></td></tr>
      <tr><td><tt>boolNull</tt></td><td> 1</td><td>Boolean value or null (+1=true, -1=false, 0=null). <i>Although
                                                   writers must use values 0, -1 or +1, readers are encouraged
                                                   to consider any positive values to be true and any negative
                                                   values to be false.</i></td></tr>
      <tr><td><tt>byte    </tt></td><td> 1</td><td>8-bit signed twos-complement integer</td></tr>
      <tr><td><tt>short   </tt></td><td> 2</td><td>16-bit signed twos-complement integer</td></tr>
      <tr><td><tt>int     </tt></td><td> 4</td><td>32-bit signed twos-complement integer</td></tr>
      <tr><td><tt>long    </tt></td><td> 8</td><td>64-bit signed twos-complement integer</td></tr>
      <tr><td><tt>float   </tt></td><td> 4</td><td>IEEE 754 single-precision floating-point</td></tr>
      <tr><td><tt>double  </tt></td><td> 8</td><td>IEEE 754 double-precision floating-point</td></tr>
      <tr><td><tt>gpsTime </tt></td><td>12</td><td>GPS time stamp composed of whole number of seconds and
                                                   picoseconds (similar to a GPS+real-time time stamp in VITA 49.0)</td></tr>
      <tr><td><tt>utcTime </tt></td><td>12</td><td>UTC time stamp composed of whole number of seconds and
                                                   picoseconds (similar to a UTC+real-time time stamp in VITA 49.0)</td></tr>
      <tr><td><tt>inetAddr</tt></td><td>16</td><td>16-byte IPv6 internet address. A 4-byte IPv4 address
                                                   can also be placed in this field using an IPv4 mapped
                                                   address of the form <tt>::ffff:w.x.y.z</tt>.</td></tr>
      <tr><td><tt>uuid    </tt></td><td>16</td><td>16-byte UUID value.</td></tr>
      <tr><td><tt>ascii[n]</tt></td><td> n</td><td>An ASCII string of length n. If the text is shorter than n,
                                                   the remaining bytes are passed with NUL values, no non-NUL
                                                   may appear after the first NUL. Note that this is not a
                                                   C string in that a string of exactly length n will not
                                                   have a terminating NUL. ASCII control characters are not
                                                   permitted within the body of the string.</td></tr>
      <tr><td><tt>utf8[n] </tt></td><td> n</td><td>A modified UTF-8 string of length n. If the text is shorter
                                                   than n, the remaining bytes are passed with NUL values. The
                                                   "modified UTF-8" form used here differs from the standard in
                                                   that NUL values are encoded using the two-octet form; this
                                                   allows embedded NUL characters within the string.</td></tr>
      <tr><td><tt>meta[n] </tt></td><td> n</td><td>A metadata block of length n. If the metadata is shorter
                                                   than n, the remaining bytes are passed with null (0x00) values.
                                                   Each entry within the metadata block has a LEVEL (integer),
                                                   a KEY (ASCII) and a VALUE (UTF-8).</td></tr>
      <tr><td><tt>/<i class="blue">enum</i>/  </tt></td><td>1</td> <td>Ordinal representing an enumerated value
                                                   of type <i class="blue">enum</i> (see below).</td></tr>
      <tr><td><tt>/<i class="blue">record</i>/</tt></td><td>n</td> <td>A record of type <i class="blue">record</i>
                                                   with implicit length n (see below).</td></tr>
    </table>
    <p>
      Any of the above types can be specified as an array (excepting <tt>ascii</tt>, <tt>utf8</tt>
      and <tt>meta</tt> which are always specified as an array), for example <tt>int[7]</tt> would
      be an array of seven <tt>int</tt> values listed sequentially and <tt>/MyRecord/[3]</tt> would
      be an array of three records of type <tt>MyRecord</tt>. The very last field in the packet
      (but not a record) can take one of two special forms:
    </p>
    <ul>
      <li>
        <tt><i>type</i>[*]</tt> -- The length of the array/string/block extends to the end of the
        packet (padded as necessary to be a multiple of four octets).
      </li>
      <li>
        <tt><i>type</i>[0-N]</tt> -- <b>Only applies to <tt>ascii</tt> and <tt>utf8</tt> types:</b>
        The length of the string extends to the end of the packet (padded as necessary to be a
        multiple of four octets). The max length of the string that will be written is N octets
        (for <tt>ascii</tt> this translates to number of characters,  for <tt>utf8</tt> the maximum
        number of characters will vary based on the characters used). <i class="blue">This is the
        preferred form for use with strings since it will cause excessively-long strings to be
        truncated (without warning/error) to fit into a pre-determined max packet size as may be
        required by the underlying transport protocol (e.g. UDP).</i>
      </li>
    </ul>
    <p>
      The <i class="blue">name</i> specifies the name of the field. This name must follow
      the naming rules for Java and C++ identifiers since it is used to form the names of the
      accessor and modifier functions. For example a name <tt>NAME='MyValue'</tt> will result
      in the Java and C++ functions <tt>getMyValue(..)</tt> and <tt>setMyValue(..)</tt>. By
      convention the name is specifies with an initial capital and additional capitals at the
      start of each word (this results is function names that match Java naming conventions).
      If the <i class="blue">name</i> is blank (i.e. <tt>NAME=''</tt>) the field is assumed
      to be reserved for future use. It is not uncommon to see something like the following
      used to pad out entries so that they are naturally aligned:
    </p>
    <pre>
      &lt;FIELDS&gt;
        &lt;FIELD TYPE='short'   NAME='ShortValue' ...  DESCRIPTION='A 2-byte value' /&gt;
        <i class="blue">&lt;FIELD TYPE='byte[6]' NAME=''                DESCRIPTION='' /&gt;</i>
        &lt;FIELD TYPE='double'  NAME='DoubleValue' ... DESCRIPTION='An 8-byte value' /&gt;
        ...
      &lt;/FIELDS&gt;
    </pre>
    <p>
      The <i class="blue">units</i> and <i class="blue">range</i> fields are optional and
      specify the units used (e.g. <tt>UNITS='m/s'</tt>) and range allowed
      (e.g. <tt>RANGE='(0,1e6]'</tt>) allowed. At this time, these values are only used for
      documentation purposes and no limits checking is done in the auto-generated code. It is
      not uncommon to use 0 to indicate that a value was unspecified even if 0 is not within
      the <i class="blue">range</i> specified. The <i class="blue">description</i> is simply a
      free-form description of the field.
    </p>
    <h4>Record Definitions</h4>
    <p>
      The &lt;RECORDS&gt; block is only required if the &lt;FIELDS&gt; specified records
      to be made part of the packet definition. The structure of a &lt;RECORD&gt; definition
      looks like the following:
    </p>
    <pre>
      &lt;RECORD&gt;
        &lt;NAME&gt;<i class="blue">name</i>&lt;/NAME&gt;
        &lt;TITLE&gt;<i class="blue">title</i>&lt;/TITLE&gt;
        &lt;FIELDS&gt;
          &lt;FIELD ... /&gt;
          &lt;FIELD ... /&gt;
          ...
        &lt;FIELDS&gt;
      &lt;/RECORD&gt;
    </pre>
    <p>
      The <i class="blue">name</i> is the name for the record while <i class="blue">title</i>
      is a free-form title for it.  The name used here will also be used within the field
      definitions of the packet and must match a valid Java and C++ class name. The individual
      &lt;FIELD&gt; entries follow the same rules as above, except that the special
      <tt><i>type</i>[*]</tt> syntax is disallowed.
    </p>
    <h4>Enumeration Definitions</h4>
    <p>
       The &lt;ENUMERATIONS&gt; block is only required if the &lt;FIELDS&gt; specified
      enumerated values to be made part of the packet definition. The structure of an
      &lt;ENUMERATION&gt; definition looks like the following:
    </p>
    <pre>
      &lt;ENUMERATION&gt;
        &lt;NAME&gt;<i class="blue">name</i>&lt;/NAME&gt;
        &lt;TITLE&gt;<i class="blue">title</i>&lt;/TITLE&gt;
        &lt;VALUES&gt;
          &lt;VALUE VAL='<i class="blue">val</i>' NAME='<i class="blue">name</i>' DESCRIPTION='<i class="blue">description</i>' /&gt;
          &lt;VALUE VAL='<i class="blue">val</i>' NAME='<i class="blue">name</i>' DESCRIPTION='<i class="blue">description</i>' /&gt;
          ...
        &lt;/VALUES&gt;
      &lt;ENUMERATION&gt;
    </pre>
    <p>
      The <i class="blue">name</i> is the name for the enumeration while <i class="blue">title</i>
      is a free-form title for it. The name used here will also be used within the field definitions
      of the packet and must match a valid Java and C++ class name.
    </p>
    <p>
      Within each of the &lt;VALUE&gt; definitions, the <i class="blue">val</i> is the
      unique numeric value corresponding with the enumerated name. The value can be specified
      as a decimal integer between -128 and +127 or a hex value between 0x00 and 0xFF.
    </p>
    <p>
      The <i class="blue">name</i> for a &lt;VALUE&gt; specifies the enumerated value
      name. This name must match a valid Java or C++ identifier or the special value
      "null" and each name must be unique. Within Java and these names become the names
      for the enumeration values, excepting "null" which is represented simply as the
      <tt>null</tt> value. In C++ a slightly different syntax is used to prevent
      name-conflicts. By convention all of the names (other than "null") are listed in
      all upper-case. Except where the enumeration values mirror an external interface,
      the value 0 is conventionally reserved for use as the "null" value.
    </p>
  </body>
</html>
